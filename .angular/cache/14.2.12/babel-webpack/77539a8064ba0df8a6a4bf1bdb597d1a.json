{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nexport class SearchSortedProgram {\n  constructor(batchSize, numInputs, numValues, side) {\n    this.variableNames = ['sortedSequence', 'values'];\n    this.customUniforms = [{\n      name: 'numInputs',\n      type: 'int'\n    }];\n    this.outputShape = [batchSize, numValues];\n    const webGL2LoopHead = 'while (left < right) {'; // WebGL1 doesn't accept non constant loop conditions, so upper bound loop\n    // iterations.\n\n    const webGL1LoopHead = `for (int i = 0; i < ${Math.ceil(Math.log2(numInputs + 1))}; ++i) { if (left >= right) break;`;\n    const loopHead = env().getNumber('WEBGL_VERSION') === 2 ? webGL2LoopHead : webGL1LoopHead; // left corresponds to lower bound and right to upper bound.\n\n    const boundComparator = side === 'left' ? '<' : '<=';\n    this.userCode = `\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${loopHead}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${boundComparator} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `;\n  }\n\n}","map":{"version":3,"names":["env","SearchSortedProgram","constructor","batchSize","numInputs","numValues","side","variableNames","customUniforms","name","type","outputShape","webGL2LoopHead","webGL1LoopHead","Math","ceil","log2","loopHead","getNumber","boundComparator","userCode"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-webgl/dist/search_sorted_gpu.js"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nexport class SearchSortedProgram {\n    constructor(batchSize, numInputs, numValues, side) {\n        this.variableNames = ['sortedSequence', 'values'];\n        this.customUniforms = [{ name: 'numInputs', type: 'int' }];\n        this.outputShape = [batchSize, numValues];\n        const webGL2LoopHead = 'while (left < right) {';\n        // WebGL1 doesn't accept non constant loop conditions, so upper bound loop\n        // iterations.\n        const webGL1LoopHead = `for (int i = 0; i < ${Math.ceil(Math.log2(numInputs + 1))}; ++i) { if (left >= right) break;`;\n        const loopHead = env().getNumber('WEBGL_VERSION') === 2 ? webGL2LoopHead :\n            webGL1LoopHead;\n        // left corresponds to lower bound and right to upper bound.\n        const boundComparator = side === 'left' ? '<' : '<=';\n        this.userCode = `\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${loopHead}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${boundComparator} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `;\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,GAAT,QAAoB,uBAApB;AACA,OAAO,MAAMC,mBAAN,CAA0B;EAC7BC,WAAW,CAACC,SAAD,EAAYC,SAAZ,EAAuBC,SAAvB,EAAkCC,IAAlC,EAAwC;IAC/C,KAAKC,aAAL,GAAqB,CAAC,gBAAD,EAAmB,QAAnB,CAArB;IACA,KAAKC,cAAL,GAAsB,CAAC;MAAEC,IAAI,EAAE,WAAR;MAAqBC,IAAI,EAAE;IAA3B,CAAD,CAAtB;IACA,KAAKC,WAAL,GAAmB,CAACR,SAAD,EAAYE,SAAZ,CAAnB;IACA,MAAMO,cAAc,GAAG,wBAAvB,CAJ+C,CAK/C;IACA;;IACA,MAAMC,cAAc,GAAI,uBAAsBC,IAAI,CAACC,IAAL,CAAUD,IAAI,CAACE,IAAL,CAAUZ,SAAS,GAAG,CAAtB,CAAV,CAAoC,oCAAlF;IACA,MAAMa,QAAQ,GAAGjB,GAAG,GAAGkB,SAAN,CAAgB,eAAhB,MAAqC,CAArC,GAAyCN,cAAzC,GACbC,cADJ,CAR+C,CAU/C;;IACA,MAAMM,eAAe,GAAGb,IAAI,KAAK,MAAT,GAAkB,GAAlB,GAAwB,IAAhD;IACA,KAAKc,QAAL,GAAiB;AACzB;AACA;AACA;AACA;AACA,WAAWH,QAAS;AACpB;AACA,+CAA+CE,eAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAzBQ;EA0BH;;AAvC4B"},"metadata":{},"sourceType":"module"}