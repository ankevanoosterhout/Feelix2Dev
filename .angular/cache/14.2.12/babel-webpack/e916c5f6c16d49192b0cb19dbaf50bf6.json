{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext } from './canvas_util';\nimport { getTextureConfig } from './tex_util';\nexport function callAndCheck(gl, func) {\n  const returnValue = func();\n\n  if (env().getBool('DEBUG')) {\n    checkWebGLError(gl);\n  }\n\n  return returnValue;\n}\n\nfunction checkWebGLError(gl) {\n  const error = gl.getError();\n\n  if (error !== gl.NO_ERROR) {\n    throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));\n  }\n} // https://en.wikipedia.org/wiki/Half-precision_floating-point_format\n\n\nconst MIN_FLOAT16 = 5.96e-8;\nconst MAX_FLOAT16 = 65504;\nexport function canBeRepresented(num) {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 || MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16) {\n    return true;\n  }\n\n  return false;\n}\nexport function getWebGLErrorMessage(gl, status) {\n  switch (status) {\n    case gl.NO_ERROR:\n      return 'NO_ERROR';\n\n    case gl.INVALID_ENUM:\n      return 'INVALID_ENUM';\n\n    case gl.INVALID_VALUE:\n      return 'INVALID_VALUE';\n\n    case gl.INVALID_OPERATION:\n      return 'INVALID_OPERATION';\n\n    case gl.INVALID_FRAMEBUFFER_OPERATION:\n      return 'INVALID_FRAMEBUFFER_OPERATION';\n\n    case gl.OUT_OF_MEMORY:\n      return 'OUT_OF_MEMORY';\n\n    case gl.CONTEXT_LOST_WEBGL:\n      return 'CONTEXT_LOST_WEBGL';\n\n    default:\n      return `Unknown error code ${status}`;\n  }\n}\nexport function getExtensionOrThrow(gl, extensionName) {\n  return throwIfNull(gl, () => gl.getExtension(extensionName), 'Extension \"' + extensionName + '\" not supported on this browser.');\n}\nexport function createVertexShader(gl, vertexShaderSource) {\n  const vertexShader = throwIfNull(gl, () => gl.createShader(gl.VERTEX_SHADER), 'Unable to create vertex WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));\n  callAndCheck(gl, () => gl.compileShader(vertexShader));\n\n  if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    throw new Error('Failed to compile vertex shader.');\n  }\n\n  return vertexShader;\n}\nexport function createFragmentShader(gl, fragmentShaderSource) {\n  const fragmentShader = throwIfNull(gl, () => gl.createShader(gl.FRAGMENT_SHADER), 'Unable to create fragment WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));\n  callAndCheck(gl, () => gl.compileShader(fragmentShader));\n\n  if (env().get('ENGINE_COMPILE_ONLY')) {\n    return fragmentShader;\n  }\n\n  if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {\n    logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));\n    throw new Error('Failed to compile fragment shader.');\n  }\n\n  return fragmentShader;\n}\nconst lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\nexport function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {\n  const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);\n\n  if (lineNumberRegexResult == null) {\n    console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);\n    console.log(shaderSource);\n    return;\n  }\n\n  const lineNumber = +lineNumberRegexResult[1];\n  const shaderLines = shaderSource.split('\\n');\n  const pad = shaderLines.length.toString().length + 2;\n  const linesWithLineNumbers = shaderLines.map((line, lineNumber) => util.rightPad((lineNumber + 1).toString(), pad) + line);\n  let maxLineLength = 0;\n\n  for (let i = 0; i < linesWithLineNumbers.length; i++) {\n    maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);\n  }\n\n  const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);\n  const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);\n  const afterErrorLines = linesWithLineNumbers.slice(lineNumber);\n  console.log(beforeErrorLines.join('\\n'));\n  console.log(shaderInfoLog.split('\\n')[0]);\n  console.log(`%c ${util.rightPad(errorLine[0], maxLineLength)}`, 'border:1px solid red; background-color:#e3d2d2; color:#a61717');\n  console.log(afterErrorLines.join('\\n'));\n}\nexport function createProgram(gl) {\n  return throwIfNull(gl, () => gl.createProgram(), 'Unable to create WebGLProgram.');\n}\nexport function linkProgram(gl, program) {\n  callAndCheck(gl, () => gl.linkProgram(program));\n\n  if (env().get('ENGINE_COMPILE_ONLY')) {\n    return;\n  }\n\n  if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Failed to link vertex and fragment shaders.');\n  }\n}\nexport function validateProgram(gl, program) {\n  callAndCheck(gl, () => gl.validateProgram(program));\n\n  if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Shader program validation failed.');\n  }\n}\nexport function createStaticVertexBuffer(gl, data) {\n  const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\nexport function createStaticIndexBuffer(gl, data) {\n  const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer));\n  callAndCheck(gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\nexport function getNumChannels() {\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    return 1;\n  }\n\n  return 4;\n}\nexport function createTexture(gl) {\n  return throwIfNull(gl, () => gl.createTexture(), 'Unable to create WebGLTexture.');\n}\nexport function validateTextureSize(width, height) {\n  const maxTextureSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n\n  if (width <= 0 || height <= 0) {\n    const requested = `[${width}x${height}]`;\n    throw new Error('Requested texture size ' + requested + ' is invalid.');\n  }\n\n  if (width > maxTextureSize || height > maxTextureSize) {\n    const requested = `[${width}x${height}]`;\n    const max = `[${maxTextureSize}x${maxTextureSize}]`;\n    throw new Error('Requested texture size ' + requested + ' greater than WebGL maximum on this browser / GPU ' + max + '.');\n  }\n}\nexport function createFramebuffer(gl) {\n  return throwIfNull(gl, () => gl.createFramebuffer(), 'Unable to create WebGLFramebuffer.');\n}\nexport function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {\n  const loc = gl.getAttribLocation(program, attribute);\n\n  if (loc === -1) {\n    // The GPU compiler decided to strip out this attribute because it's unused,\n    // thus no need to bind.\n    return false;\n  }\n\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(gl, () => gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes));\n  callAndCheck(gl, () => gl.enableVertexAttribArray(loc));\n  return true;\n}\nexport function bindTextureUnit(gl, texture, textureUnit) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n}\nexport function unbindTextureUnit(gl, textureUnit) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function getProgramUniformLocationOrThrow(gl, program, uniformName) {\n  return throwIfNull(gl, () => gl.getUniformLocation(program, uniformName), 'uniform \"' + uniformName + '\" not present in program.');\n}\nexport function getProgramUniformLocation(gl, program, uniformName) {\n  return gl.getUniformLocation(program, uniformName);\n}\nexport function bindTextureToProgramUniformSampler(gl, texture, uniformSamplerLocation, textureUnit) {\n  callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));\n  callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));\n}\nexport function bindCanvasToFramebuffer(gl) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n  callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));\n  callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));\n}\nexport function bindColorTextureToFramebuffer(gl, texture, framebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));\n}\nexport function unbindColorTextureFromFramebuffer(gl, framebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));\n}\nexport function validateFramebuffer(gl) {\n  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n\n  if (status !== gl.FRAMEBUFFER_COMPLETE) {\n    throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));\n  }\n}\nexport function getFramebufferErrorMessage(gl, status) {\n  switch (status) {\n    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';\n\n    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';\n\n    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n      return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';\n\n    case gl.FRAMEBUFFER_UNSUPPORTED:\n      return 'FRAMEBUFFER_UNSUPPORTED';\n\n    default:\n      return `unknown error ${status}`;\n  }\n}\n\nfunction throwIfNull(gl, returnTOrNull, failureMessage) {\n  const tOrNull = callAndCheck(gl, () => returnTOrNull());\n\n  if (tOrNull == null) {\n    throw new Error(failureMessage);\n  }\n\n  return tOrNull;\n}\n\nfunction validateTextureUnit(gl, textureUnit) {\n  const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;\n  const glTextureUnit = textureUnit + gl.TEXTURE0;\n\n  if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {\n    const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;\n    throw new Error(`textureUnit must be in ${textureUnitRange}.`);\n  }\n}\n\nexport function getBatchDim(shape, dimsToSkip = 2) {\n  return util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\nexport function getRowsCols(shape) {\n  if (shape.length === 0) {\n    throw Error('Cannot get rows and columns of an empty shape array.');\n  }\n\n  return [shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]];\n}\nexport function getShapeAs3D(shape) {\n  let shapeAs3D = [1, 1, 1];\n  const isScalar = shape.length === 0 || shape.length === 1 && shape[0] === 1;\n\n  if (!isScalar) {\n    shapeAs3D = [getBatchDim(shape), ...getRowsCols(shape)];\n  }\n\n  return shapeAs3D;\n}\nexport function getTextureShapeFromLogicalShape(logShape, isPacked = false) {\n  let maxTexSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n  let maxSizeForNarrowTex = env().getNumber('WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE');\n\n  if (maxSizeForNarrowTex === Infinity && env().getBool('WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE')) {\n    maxSizeForNarrowTex = maxTexSize / 2;\n  }\n\n  if (isPacked) {\n    maxTexSize = maxTexSize * 2;\n    maxSizeForNarrowTex = maxSizeForNarrowTex * 2; // This logic ensures we accurately count the number of packed texels needed\n    // to accommodate the tensor. We can only pack values in the same texel if\n    // they are from adjacent pairs of rows/cols within the same batch. So if a\n    // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n    // fact that the texels containing the third row are half empty.\n\n    logShape = logShape.map((d, i) => i >= logShape.length - 2 ? util.nearestLargerEven(logShape[i]) : logShape[i]); // Packed texture height is at least 2 (the channel height of a single\n    // texel).\n\n    if (logShape.length === 1) {\n      logShape = [2, logShape[0]];\n    }\n  } // If logical shape is 2, we don't squeeze, since we want to match physical.\n\n\n  if (logShape.length !== 2) {\n    const squeezeResult = util.squeezeShape(logShape);\n    logShape = squeezeResult.newShape;\n  }\n\n  let size = util.sizeFromShape(logShape);\n  let textureShape = null;\n\n  if (logShape.length <= 1 && size <= maxTexSize) {\n    textureShape = [1, size];\n  } else if (logShape.length === 2 && logShape[0] <= maxTexSize && logShape[1] <= maxTexSize) {\n    textureShape = logShape;\n  } else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize && logShape[2] <= maxTexSize) {\n    textureShape = [logShape[0] * logShape[1], logShape[2]];\n  } else if (logShape.length === 3 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] <= maxTexSize) {\n    textureShape = [logShape[0], logShape[1] * logShape[2]];\n  } else if (logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTexSize && logShape[3] <= maxTexSize) {\n    textureShape = [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n  } else if (logShape.length === 4 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {\n    textureShape = [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n  } // true if one edge length is 1 (1 or 2, if packed), while another edge\n  // length exceeds maxSizeForNarrowTex.\n\n\n  const isLongNarrowTex = textureShape != null && Math.max(...textureShape) > maxSizeForNarrowTex && Math.min(...textureShape) <= (isPacked ? 2 : 1) && Math.min(...textureShape) > 0;\n\n  if (textureShape == null || isLongNarrowTex) {\n    if (isPacked) {\n      // For packed textures size equals the number of channels required to\n      // accommodate the texture data. However in order to squarify such that\n      // inner dimensions stay even, we rewrite size to equal the number of\n      // texels. Then in the return statement we rehydrate the squarified\n      // dimensions to channel units.\n      const batchDim = getBatchDim(logShape);\n      let rows = 2,\n          cols = 2;\n\n      if (logShape.length) {\n        [rows, cols] = getRowsCols(logShape);\n      }\n\n      size = batchDim * (rows / 2) * (cols / 2);\n      textureShape = util.sizeToSquarishShape(size).map(d => d * 2);\n    } else {\n      textureShape = util.sizeToSquarishShape(size);\n    }\n  }\n\n  return textureShape;\n}\n\nfunction isEven(n) {\n  return n % 2 === 0;\n}\n/**\n * This determines whether reshaping a packed texture requires rearranging\n * the data within the texture, assuming 2x2 packing.\n */\n\n\nexport function isReshapeFree(shape1, shape2) {\n  shape1 = shape1.slice(-2);\n  shape2 = shape2.slice(-2);\n\n  if (util.arraysEqual(shape1, shape2)) {\n    return true;\n  }\n\n  if (!shape1.length || !shape2.length) {\n    // One of the shapes is a scalar.\n    return true;\n  }\n\n  if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 || shape2[1] === 0) {\n    return true;\n  }\n\n  if (shape1.length !== shape2.length) {\n    // One of the shapes is a vector.\n    const shape1Cols = shape1.slice(-1)[0];\n    const shape2Cols = shape2.slice(-1)[0];\n\n    if (shape1Cols === shape2Cols) {\n      return true;\n    }\n\n    if (isEven(shape1Cols) && isEven(shape2Cols) && (shape1[0] === 1 || shape2[0] === 1)) {\n      return true;\n    }\n  }\n\n  return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);\n} // We cache webgl params because the environment gets reset between\n// unit tests and we don't want to constantly query the WebGLContext for\n// MAX_TEXTURE_SIZE.\n\nlet MAX_TEXTURE_SIZE;\nlet MAX_TEXTURES_IN_SHADER;\nexport function getWebGLMaxTextureSize(webGLVersion) {\n  if (MAX_TEXTURE_SIZE == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n  }\n\n  return MAX_TEXTURE_SIZE;\n}\nexport function resetMaxTextureSize() {\n  MAX_TEXTURE_SIZE = null;\n}\nexport function resetMaxTexturesInShader() {\n  MAX_TEXTURES_IN_SHADER = null;\n}\nexport function getMaxTexturesInShader(webGLVersion) {\n  if (MAX_TEXTURES_IN_SHADER == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  } // We cap at 16 to avoid spurious runtime \"memory exhausted\" error.\n\n\n  return Math.min(16, MAX_TEXTURES_IN_SHADER);\n}\nexport function getWebGLDisjointQueryTimerVersion(webGLVersion) {\n  if (webGLVersion === 0) {\n    return 0;\n  }\n\n  let queryTimerVersion;\n  const gl = getWebGLContext(webGLVersion);\n\n  if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') && webGLVersion === 2) {\n    queryTimerVersion = 2;\n  } else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {\n    queryTimerVersion = 1;\n  } else {\n    queryTimerVersion = 0;\n  }\n\n  return queryTimerVersion;\n}\nexport function hasExtension(gl, extensionName) {\n  const ext = gl.getExtension(extensionName);\n  return ext != null;\n}\nexport function isWebGLVersionEnabled(webGLVersion) {\n  try {\n    const gl = getWebGLContext(webGLVersion);\n\n    if (gl != null) {\n      return true;\n    }\n  } catch (e) {\n    console.log('Error when getting WebGL context: ', e);\n    return false;\n  }\n\n  return false;\n}\nexport function isCapableOfRenderingToFloatTexture(webGLVersion) {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n  } else {\n    if (!hasExtension(gl, 'EXT_color_buffer_float')) {\n      return false;\n    }\n  }\n\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n/**\n * Check if we can download values from a float/half-float texture.\n *\n * Note that for performance reasons we use binding a texture to a framebuffer\n * as a proxy for ability to download float values later using readPixels. The\n * texture params of this texture will not match those in readPixels exactly\n * but if we are unable to bind some kind of float texture to the frameBuffer\n * then we definitely will not be able to read float values from it.\n */\n\nexport function isDownloadFloatTextureEnabled(webGLVersion) {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n\n    if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {\n      return false;\n    }\n  } else {\n    if (hasExtension(gl, 'EXT_color_buffer_float')) {\n      return createFloatTextureAndBindToFramebuffer(gl);\n    }\n\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n\n    if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {\n      const textureHalfFloatExtension = gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      return createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension);\n    }\n\n    return false;\n  }\n\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n\nfunction createFloatTextureAndBindToFramebuffer(gl) {\n  const texConfig = getTextureConfig(gl);\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n  const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n  return isFrameBufferComplete;\n}\n\nfunction createHalfFloatTextureAndBindToFramebuffer( // tslint:disable-next-line:no-any\ngl, textureHalfFloatExtension) {\n  const texConfig = getTextureConfig(gl, textureHalfFloatExtension);\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n  const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n  return isFrameBufferComplete;\n}\n\nexport function isWebGLFenceEnabled(webGLVersion) {\n  if (webGLVersion !== 2) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion); // tslint:disable-next-line:no-any\n\n  const isEnabled = gl.fenceSync != null;\n  return isEnabled;\n}\nexport function assertNotComplex(tensor, opName) {\n  if (!Array.isArray(tensor)) {\n    tensor = [tensor];\n  }\n\n  tensor.forEach(t => {\n    if (t != null) {\n      util.assert(t.dtype !== 'complex64', () => `${opName} does not support complex64 tensors ` + 'in the WebGL backend.');\n    }\n  });\n}","map":{"version":3,"names":["env","util","getWebGLContext","getTextureConfig","callAndCheck","gl","func","returnValue","getBool","checkWebGLError","error","getError","NO_ERROR","Error","getWebGLErrorMessage","MIN_FLOAT16","MAX_FLOAT16","canBeRepresented","num","Math","abs","status","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","INVALID_FRAMEBUFFER_OPERATION","OUT_OF_MEMORY","CONTEXT_LOST_WEBGL","getExtensionOrThrow","extensionName","throwIfNull","getExtension","createVertexShader","vertexShaderSource","vertexShader","createShader","VERTEX_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","log","getShaderInfoLog","createFragmentShader","fragmentShaderSource","fragmentShader","FRAGMENT_SHADER","get","logShaderSourceAndInfoLog","lineNumberRegex","shaderInfoLog","lineNumberRegexResult","exec","lineNumber","shaderLines","split","pad","length","toString","linesWithLineNumbers","map","line","rightPad","maxLineLength","i","max","beforeErrorLines","slice","errorLine","afterErrorLines","join","createProgram","linkProgram","program","getProgramParameter","LINK_STATUS","getProgramInfoLog","validateProgram","VALIDATE_STATUS","createStaticVertexBuffer","data","buffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","createStaticIndexBuffer","ELEMENT_ARRAY_BUFFER","getNumChannels","getNumber","createTexture","validateTextureSize","width","height","maxTextureSize","requested","createFramebuffer","bindVertexBufferToProgramAttribute","attribute","arrayEntriesPerItem","itemStrideInBytes","itemOffsetInBytes","loc","getAttribLocation","vertexAttribPointer","FLOAT","enableVertexAttribArray","bindTextureUnit","texture","textureUnit","validateTextureUnit","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","unbindTextureUnit","getProgramUniformLocationOrThrow","uniformName","getUniformLocation","getProgramUniformLocation","bindTextureToProgramUniformSampler","uniformSamplerLocation","uniform1i","bindCanvasToFramebuffer","bindFramebuffer","FRAMEBUFFER","viewport","canvas","scissor","bindColorTextureToFramebuffer","framebuffer","framebufferTexture2D","COLOR_ATTACHMENT0","unbindColorTextureFromFramebuffer","validateFramebuffer","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","getFramebufferErrorMessage","FRAMEBUFFER_INCOMPLETE_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_DIMENSIONS","FRAMEBUFFER_UNSUPPORTED","returnTOrNull","failureMessage","tOrNull","maxTextureUnit","MAX_COMBINED_TEXTURE_IMAGE_UNITS","glTextureUnit","textureUnitRange","getBatchDim","shape","dimsToSkip","sizeFromShape","getRowsCols","getShapeAs3D","shapeAs3D","isScalar","getTextureShapeFromLogicalShape","logShape","isPacked","maxTexSize","maxSizeForNarrowTex","Infinity","d","nearestLargerEven","squeezeResult","squeezeShape","newShape","size","textureShape","isLongNarrowTex","min","batchDim","rows","cols","sizeToSquarishShape","isEven","n","isReshapeFree","shape1","shape2","arraysEqual","shape1Cols","shape2Cols","MAX_TEXTURE_SIZE","MAX_TEXTURES_IN_SHADER","getWebGLMaxTextureSize","webGLVersion","getParameter","resetMaxTextureSize","resetMaxTexturesInShader","getMaxTexturesInShader","MAX_TEXTURE_IMAGE_UNITS","getWebGLDisjointQueryTimerVersion","queryTimerVersion","hasExtension","ext","isWebGLVersionEnabled","e","isCapableOfRenderingToFloatTexture","isFrameBufferComplete","createFloatTextureAndBindToFramebuffer","isDownloadFloatTextureEnabled","COLOR_BUFFER_HALF_FLOAT","textureHalfFloatExtension","createHalfFloatTextureAndBindToFramebuffer","texConfig","texImage2D","internalFormatFloat","textureFormatFloat","textureTypeFloat","frameBuffer","deleteTexture","deleteFramebuffer","internalFormatHalfFloat","textureTypeHalfFloat","isWebGLFenceEnabled","isEnabled","fenceSync","assertNotComplex","tensor","opName","Array","isArray","forEach","t","assert","dtype"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl_util.js"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext } from './canvas_util';\nimport { getTextureConfig } from './tex_util';\nexport function callAndCheck(gl, func) {\n    const returnValue = func();\n    if (env().getBool('DEBUG')) {\n        checkWebGLError(gl);\n    }\n    return returnValue;\n}\nfunction checkWebGLError(gl) {\n    const error = gl.getError();\n    if (error !== gl.NO_ERROR) {\n        throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));\n    }\n}\n// https://en.wikipedia.org/wiki/Half-precision_floating-point_format\nconst MIN_FLOAT16 = 5.96e-8;\nconst MAX_FLOAT16 = 65504;\nexport function canBeRepresented(num) {\n    if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 ||\n        (MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16)) {\n        return true;\n    }\n    return false;\n}\nexport function getWebGLErrorMessage(gl, status) {\n    switch (status) {\n        case gl.NO_ERROR:\n            return 'NO_ERROR';\n        case gl.INVALID_ENUM:\n            return 'INVALID_ENUM';\n        case gl.INVALID_VALUE:\n            return 'INVALID_VALUE';\n        case gl.INVALID_OPERATION:\n            return 'INVALID_OPERATION';\n        case gl.INVALID_FRAMEBUFFER_OPERATION:\n            return 'INVALID_FRAMEBUFFER_OPERATION';\n        case gl.OUT_OF_MEMORY:\n            return 'OUT_OF_MEMORY';\n        case gl.CONTEXT_LOST_WEBGL:\n            return 'CONTEXT_LOST_WEBGL';\n        default:\n            return `Unknown error code ${status}`;\n    }\n}\nexport function getExtensionOrThrow(gl, extensionName) {\n    return throwIfNull(gl, () => gl.getExtension(extensionName), 'Extension \"' + extensionName + '\" not supported on this browser.');\n}\nexport function createVertexShader(gl, vertexShaderSource) {\n    const vertexShader = throwIfNull(gl, () => gl.createShader(gl.VERTEX_SHADER), 'Unable to create vertex WebGLShader.');\n    callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));\n    callAndCheck(gl, () => gl.compileShader(vertexShader));\n    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {\n        console.log(gl.getShaderInfoLog(vertexShader));\n        throw new Error('Failed to compile vertex shader.');\n    }\n    return vertexShader;\n}\nexport function createFragmentShader(gl, fragmentShaderSource) {\n    const fragmentShader = throwIfNull(gl, () => gl.createShader(gl.FRAGMENT_SHADER), 'Unable to create fragment WebGLShader.');\n    callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));\n    callAndCheck(gl, () => gl.compileShader(fragmentShader));\n    if (env().get('ENGINE_COMPILE_ONLY')) {\n        return fragmentShader;\n    }\n    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {\n        logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));\n        throw new Error('Failed to compile fragment shader.');\n    }\n    return fragmentShader;\n}\nconst lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\nexport function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {\n    const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);\n    if (lineNumberRegexResult == null) {\n        console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);\n        console.log(shaderSource);\n        return;\n    }\n    const lineNumber = +lineNumberRegexResult[1];\n    const shaderLines = shaderSource.split('\\n');\n    const pad = shaderLines.length.toString().length + 2;\n    const linesWithLineNumbers = shaderLines.map((line, lineNumber) => util.rightPad((lineNumber + 1).toString(), pad) + line);\n    let maxLineLength = 0;\n    for (let i = 0; i < linesWithLineNumbers.length; i++) {\n        maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);\n    }\n    const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);\n    const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);\n    const afterErrorLines = linesWithLineNumbers.slice(lineNumber);\n    console.log(beforeErrorLines.join('\\n'));\n    console.log(shaderInfoLog.split('\\n')[0]);\n    console.log(`%c ${util.rightPad(errorLine[0], maxLineLength)}`, 'border:1px solid red; background-color:#e3d2d2; color:#a61717');\n    console.log(afterErrorLines.join('\\n'));\n}\nexport function createProgram(gl) {\n    return throwIfNull(gl, () => gl.createProgram(), 'Unable to create WebGLProgram.');\n}\nexport function linkProgram(gl, program) {\n    callAndCheck(gl, () => gl.linkProgram(program));\n    if (env().get('ENGINE_COMPILE_ONLY')) {\n        return;\n    }\n    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n        console.log(gl.getProgramInfoLog(program));\n        throw new Error('Failed to link vertex and fragment shaders.');\n    }\n}\nexport function validateProgram(gl, program) {\n    callAndCheck(gl, () => gl.validateProgram(program));\n    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {\n        console.log(gl.getProgramInfoLog(program));\n        throw new Error('Shader program validation failed.');\n    }\n}\nexport function createStaticVertexBuffer(gl, data) {\n    const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n    callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));\n    return buffer;\n}\nexport function createStaticIndexBuffer(gl, data) {\n    const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n    callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer));\n    callAndCheck(gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));\n    return buffer;\n}\nexport function getNumChannels() {\n    if (env().getNumber('WEBGL_VERSION') === 2) {\n        return 1;\n    }\n    return 4;\n}\nexport function createTexture(gl) {\n    return throwIfNull(gl, () => gl.createTexture(), 'Unable to create WebGLTexture.');\n}\nexport function validateTextureSize(width, height) {\n    const maxTextureSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n    if ((width <= 0) || (height <= 0)) {\n        const requested = `[${width}x${height}]`;\n        throw new Error('Requested texture size ' + requested + ' is invalid.');\n    }\n    if ((width > maxTextureSize) || (height > maxTextureSize)) {\n        const requested = `[${width}x${height}]`;\n        const max = `[${maxTextureSize}x${maxTextureSize}]`;\n        throw new Error('Requested texture size ' + requested +\n            ' greater than WebGL maximum on this browser / GPU ' + max + '.');\n    }\n}\nexport function createFramebuffer(gl) {\n    return throwIfNull(gl, () => gl.createFramebuffer(), 'Unable to create WebGLFramebuffer.');\n}\nexport function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {\n    const loc = gl.getAttribLocation(program, attribute);\n    if (loc === -1) {\n        // The GPU compiler decided to strip out this attribute because it's unused,\n        // thus no need to bind.\n        return false;\n    }\n    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n    callAndCheck(gl, () => gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes));\n    callAndCheck(gl, () => gl.enableVertexAttribArray(loc));\n    return true;\n}\nexport function bindTextureUnit(gl, texture, textureUnit) {\n    validateTextureUnit(gl, textureUnit);\n    callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n}\nexport function unbindTextureUnit(gl, textureUnit) {\n    validateTextureUnit(gl, textureUnit);\n    callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function getProgramUniformLocationOrThrow(gl, program, uniformName) {\n    return throwIfNull(gl, () => gl.getUniformLocation(program, uniformName), 'uniform \"' + uniformName + '\" not present in program.');\n}\nexport function getProgramUniformLocation(gl, program, uniformName) {\n    return gl.getUniformLocation(program, uniformName);\n}\nexport function bindTextureToProgramUniformSampler(gl, texture, uniformSamplerLocation, textureUnit) {\n    callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));\n    callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));\n}\nexport function bindCanvasToFramebuffer(gl) {\n    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n    callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));\n    callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));\n}\nexport function bindColorTextureToFramebuffer(gl, texture, framebuffer) {\n    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n    callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));\n}\nexport function unbindColorTextureFromFramebuffer(gl, framebuffer) {\n    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n    callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));\n}\nexport function validateFramebuffer(gl) {\n    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    if (status !== gl.FRAMEBUFFER_COMPLETE) {\n        throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));\n    }\n}\nexport function getFramebufferErrorMessage(gl, status) {\n    switch (status) {\n        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n            return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';\n        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n            return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';\n        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n            return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';\n        case gl.FRAMEBUFFER_UNSUPPORTED:\n            return 'FRAMEBUFFER_UNSUPPORTED';\n        default:\n            return `unknown error ${status}`;\n    }\n}\nfunction throwIfNull(gl, returnTOrNull, failureMessage) {\n    const tOrNull = callAndCheck(gl, () => returnTOrNull());\n    if (tOrNull == null) {\n        throw new Error(failureMessage);\n    }\n    return tOrNull;\n}\nfunction validateTextureUnit(gl, textureUnit) {\n    const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;\n    const glTextureUnit = textureUnit + gl.TEXTURE0;\n    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {\n        const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;\n        throw new Error(`textureUnit must be in ${textureUnitRange}.`);\n    }\n}\nexport function getBatchDim(shape, dimsToSkip = 2) {\n    return util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\nexport function getRowsCols(shape) {\n    if (shape.length === 0) {\n        throw Error('Cannot get rows and columns of an empty shape array.');\n    }\n    return [\n        shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]\n    ];\n}\nexport function getShapeAs3D(shape) {\n    let shapeAs3D = [1, 1, 1];\n    const isScalar = shape.length === 0 || (shape.length === 1 && shape[0] === 1);\n    if (!isScalar) {\n        shapeAs3D =\n            [getBatchDim(shape), ...getRowsCols(shape)];\n    }\n    return shapeAs3D;\n}\nexport function getTextureShapeFromLogicalShape(logShape, isPacked = false) {\n    let maxTexSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n    let maxSizeForNarrowTex = env().getNumber('WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE');\n    if (maxSizeForNarrowTex === Infinity &&\n        env().getBool('WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE')) {\n        maxSizeForNarrowTex = maxTexSize / 2;\n    }\n    if (isPacked) {\n        maxTexSize = maxTexSize * 2;\n        maxSizeForNarrowTex = maxSizeForNarrowTex * 2;\n        // This logic ensures we accurately count the number of packed texels needed\n        // to accommodate the tensor. We can only pack values in the same texel if\n        // they are from adjacent pairs of rows/cols within the same batch. So if a\n        // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n        // fact that the texels containing the third row are half empty.\n        logShape = logShape.map((d, i) => i >= logShape.length - 2 ?\n            util.nearestLargerEven(logShape[i]) :\n            logShape[i]);\n        // Packed texture height is at least 2 (the channel height of a single\n        // texel).\n        if (logShape.length === 1) {\n            logShape = [2, logShape[0]];\n        }\n    }\n    // If logical shape is 2, we don't squeeze, since we want to match physical.\n    if (logShape.length !== 2) {\n        const squeezeResult = util.squeezeShape(logShape);\n        logShape = squeezeResult.newShape;\n    }\n    let size = util.sizeFromShape(logShape);\n    let textureShape = null;\n    if (logShape.length <= 1 && size <= maxTexSize) {\n        textureShape = [1, size];\n    }\n    else if (logShape.length === 2 && logShape[0] <= maxTexSize &&\n        logShape[1] <= maxTexSize) {\n        textureShape = logShape;\n    }\n    else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize &&\n        logShape[2] <= maxTexSize) {\n        textureShape = [logShape[0] * logShape[1], logShape[2]];\n    }\n    else if (logShape.length === 3 && logShape[0] <= maxTexSize &&\n        logShape[1] * logShape[2] <= maxTexSize) {\n        textureShape = [logShape[0], logShape[1] * logShape[2]];\n    }\n    else if (logShape.length === 4 &&\n        logShape[0] * logShape[1] * logShape[2] <= maxTexSize &&\n        logShape[3] <= maxTexSize) {\n        textureShape = [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n    }\n    else if (logShape.length === 4 && logShape[0] <= maxTexSize &&\n        logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {\n        textureShape = [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n    }\n    // true if one edge length is 1 (1 or 2, if packed), while another edge\n    // length exceeds maxSizeForNarrowTex.\n    const isLongNarrowTex = textureShape != null &&\n        Math.max(...textureShape) > maxSizeForNarrowTex &&\n        Math.min(...textureShape) <= (isPacked ? 2 : 1) &&\n        Math.min(...textureShape) > 0;\n    if (textureShape == null || isLongNarrowTex) {\n        if (isPacked) {\n            // For packed textures size equals the number of channels required to\n            // accommodate the texture data. However in order to squarify such that\n            // inner dimensions stay even, we rewrite size to equal the number of\n            // texels. Then in the return statement we rehydrate the squarified\n            // dimensions to channel units.\n            const batchDim = getBatchDim(logShape);\n            let rows = 2, cols = 2;\n            if (logShape.length) {\n                [rows, cols] = getRowsCols(logShape);\n            }\n            size = batchDim * (rows / 2) * (cols / 2);\n            textureShape =\n                util.sizeToSquarishShape(size).map(d => d * 2);\n        }\n        else {\n            textureShape = util.sizeToSquarishShape(size);\n        }\n    }\n    return textureShape;\n}\nfunction isEven(n) {\n    return n % 2 === 0;\n}\n/**\n * This determines whether reshaping a packed texture requires rearranging\n * the data within the texture, assuming 2x2 packing.\n */\nexport function isReshapeFree(shape1, shape2) {\n    shape1 = shape1.slice(-2);\n    shape2 = shape2.slice(-2);\n    if (util.arraysEqual(shape1, shape2)) {\n        return true;\n    }\n    if (!shape1.length || !shape2.length) { // One of the shapes is a scalar.\n        return true;\n    }\n    if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 ||\n        shape2[1] === 0) {\n        return true;\n    }\n    if (shape1.length !== shape2.length) { // One of the shapes is a vector.\n        const shape1Cols = shape1.slice(-1)[0];\n        const shape2Cols = shape2.slice(-1)[0];\n        if (shape1Cols === shape2Cols) {\n            return true;\n        }\n        if (isEven(shape1Cols) && isEven(shape2Cols) &&\n            (shape1[0] === 1 || shape2[0] === 1)) {\n            return true;\n        }\n    }\n    return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);\n}\n// We cache webgl params because the environment gets reset between\n// unit tests and we don't want to constantly query the WebGLContext for\n// MAX_TEXTURE_SIZE.\nlet MAX_TEXTURE_SIZE;\nlet MAX_TEXTURES_IN_SHADER;\nexport function getWebGLMaxTextureSize(webGLVersion) {\n    if (MAX_TEXTURE_SIZE == null) {\n        const gl = getWebGLContext(webGLVersion);\n        MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    }\n    return MAX_TEXTURE_SIZE;\n}\nexport function resetMaxTextureSize() {\n    MAX_TEXTURE_SIZE = null;\n}\nexport function resetMaxTexturesInShader() {\n    MAX_TEXTURES_IN_SHADER = null;\n}\nexport function getMaxTexturesInShader(webGLVersion) {\n    if (MAX_TEXTURES_IN_SHADER == null) {\n        const gl = getWebGLContext(webGLVersion);\n        MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    }\n    // We cap at 16 to avoid spurious runtime \"memory exhausted\" error.\n    return Math.min(16, MAX_TEXTURES_IN_SHADER);\n}\nexport function getWebGLDisjointQueryTimerVersion(webGLVersion) {\n    if (webGLVersion === 0) {\n        return 0;\n    }\n    let queryTimerVersion;\n    const gl = getWebGLContext(webGLVersion);\n    if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') &&\n        webGLVersion === 2) {\n        queryTimerVersion = 2;\n    }\n    else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {\n        queryTimerVersion = 1;\n    }\n    else {\n        queryTimerVersion = 0;\n    }\n    return queryTimerVersion;\n}\nexport function hasExtension(gl, extensionName) {\n    const ext = gl.getExtension(extensionName);\n    return ext != null;\n}\nexport function isWebGLVersionEnabled(webGLVersion) {\n    try {\n        const gl = getWebGLContext(webGLVersion);\n        if (gl != null) {\n            return true;\n        }\n    }\n    catch (e) {\n        console.log('Error when getting WebGL context: ', e);\n        return false;\n    }\n    return false;\n}\nexport function isCapableOfRenderingToFloatTexture(webGLVersion) {\n    if (webGLVersion === 0) {\n        return false;\n    }\n    const gl = getWebGLContext(webGLVersion);\n    if (webGLVersion === 1) {\n        if (!hasExtension(gl, 'OES_texture_float')) {\n            return false;\n        }\n    }\n    else {\n        if (!hasExtension(gl, 'EXT_color_buffer_float')) {\n            return false;\n        }\n    }\n    const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n    return isFrameBufferComplete;\n}\n/**\n * Check if we can download values from a float/half-float texture.\n *\n * Note that for performance reasons we use binding a texture to a framebuffer\n * as a proxy for ability to download float values later using readPixels. The\n * texture params of this texture will not match those in readPixels exactly\n * but if we are unable to bind some kind of float texture to the frameBuffer\n * then we definitely will not be able to read float values from it.\n */\nexport function isDownloadFloatTextureEnabled(webGLVersion) {\n    if (webGLVersion === 0) {\n        return false;\n    }\n    const gl = getWebGLContext(webGLVersion);\n    if (webGLVersion === 1) {\n        if (!hasExtension(gl, 'OES_texture_float')) {\n            return false;\n        }\n        if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {\n            return false;\n        }\n    }\n    else {\n        if (hasExtension(gl, 'EXT_color_buffer_float')) {\n            return createFloatTextureAndBindToFramebuffer(gl);\n        }\n        const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n        if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {\n            const textureHalfFloatExtension = gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n            return createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension);\n        }\n        return false;\n    }\n    const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n    return isFrameBufferComplete;\n}\nfunction createFloatTextureAndBindToFramebuffer(gl) {\n    const texConfig = getTextureConfig(gl);\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const width = 1;\n    const height = 1;\n    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(frameBuffer);\n    return isFrameBufferComplete;\n}\nfunction createHalfFloatTextureAndBindToFramebuffer(\n// tslint:disable-next-line:no-any\ngl, textureHalfFloatExtension) {\n    const texConfig = getTextureConfig(gl, textureHalfFloatExtension);\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const width = 1;\n    const height = 1;\n    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(frameBuffer);\n    return isFrameBufferComplete;\n}\nexport function isWebGLFenceEnabled(webGLVersion) {\n    if (webGLVersion !== 2) {\n        return false;\n    }\n    const gl = getWebGLContext(webGLVersion);\n    // tslint:disable-next-line:no-any\n    const isEnabled = gl.fenceSync != null;\n    return isEnabled;\n}\nexport function assertNotComplex(tensor, opName) {\n    if (!Array.isArray(tensor)) {\n        tensor = [tensor];\n    }\n    tensor.forEach(t => {\n        if (t != null) {\n            util.assert(t.dtype !== 'complex64', () => `${opName} does not support complex64 tensors ` +\n                'in the WebGL backend.');\n        }\n    });\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,GAAT,EAAcC,IAAd,QAA0B,uBAA1B;AACA,SAASC,eAAT,QAAgC,eAAhC;AACA,SAASC,gBAAT,QAAiC,YAAjC;AACA,OAAO,SAASC,YAAT,CAAsBC,EAAtB,EAA0BC,IAA1B,EAAgC;EACnC,MAAMC,WAAW,GAAGD,IAAI,EAAxB;;EACA,IAAIN,GAAG,GAAGQ,OAAN,CAAc,OAAd,CAAJ,EAA4B;IACxBC,eAAe,CAACJ,EAAD,CAAf;EACH;;EACD,OAAOE,WAAP;AACH;;AACD,SAASE,eAAT,CAAyBJ,EAAzB,EAA6B;EACzB,MAAMK,KAAK,GAAGL,EAAE,CAACM,QAAH,EAAd;;EACA,IAAID,KAAK,KAAKL,EAAE,CAACO,QAAjB,EAA2B;IACvB,MAAM,IAAIC,KAAJ,CAAU,kBAAkBC,oBAAoB,CAACT,EAAD,EAAKK,KAAL,CAAhD,CAAN;EACH;AACJ,C,CACD;;;AACA,MAAMK,WAAW,GAAG,OAApB;AACA,MAAMC,WAAW,GAAG,KAApB;AACA,OAAO,SAASC,gBAAT,CAA0BC,GAA1B,EAA+B;EAClC,IAAIlB,GAAG,GAAGQ,OAAN,CAAc,8BAAd,KAAiDU,GAAG,KAAK,CAAzD,IACCH,WAAW,GAAGI,IAAI,CAACC,GAAL,CAASF,GAAT,CAAd,IAA+BC,IAAI,CAACC,GAAL,CAASF,GAAT,IAAgBF,WADpD,EACkE;IAC9D,OAAO,IAAP;EACH;;EACD,OAAO,KAAP;AACH;AACD,OAAO,SAASF,oBAAT,CAA8BT,EAA9B,EAAkCgB,MAAlC,EAA0C;EAC7C,QAAQA,MAAR;IACI,KAAKhB,EAAE,CAACO,QAAR;MACI,OAAO,UAAP;;IACJ,KAAKP,EAAE,CAACiB,YAAR;MACI,OAAO,cAAP;;IACJ,KAAKjB,EAAE,CAACkB,aAAR;MACI,OAAO,eAAP;;IACJ,KAAKlB,EAAE,CAACmB,iBAAR;MACI,OAAO,mBAAP;;IACJ,KAAKnB,EAAE,CAACoB,6BAAR;MACI,OAAO,+BAAP;;IACJ,KAAKpB,EAAE,CAACqB,aAAR;MACI,OAAO,eAAP;;IACJ,KAAKrB,EAAE,CAACsB,kBAAR;MACI,OAAO,oBAAP;;IACJ;MACI,OAAQ,sBAAqBN,MAAO,EAApC;EAhBR;AAkBH;AACD,OAAO,SAASO,mBAAT,CAA6BvB,EAA7B,EAAiCwB,aAAjC,EAAgD;EACnD,OAAOC,WAAW,CAACzB,EAAD,EAAK,MAAMA,EAAE,CAAC0B,YAAH,CAAgBF,aAAhB,CAAX,EAA2C,gBAAgBA,aAAhB,GAAgC,kCAA3E,CAAlB;AACH;AACD,OAAO,SAASG,kBAAT,CAA4B3B,EAA5B,EAAgC4B,kBAAhC,EAAoD;EACvD,MAAMC,YAAY,GAAGJ,WAAW,CAACzB,EAAD,EAAK,MAAMA,EAAE,CAAC8B,YAAH,CAAgB9B,EAAE,CAAC+B,aAAnB,CAAX,EAA8C,sCAA9C,CAAhC;EACAhC,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAACgC,YAAH,CAAgBH,YAAhB,EAA8BD,kBAA9B,CAAX,CAAZ;EACA7B,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAACiC,aAAH,CAAiBJ,YAAjB,CAAX,CAAZ;;EACA,IAAI7B,EAAE,CAACkC,kBAAH,CAAsBL,YAAtB,EAAoC7B,EAAE,CAACmC,cAAvC,MAA2D,KAA/D,EAAsE;IAClEC,OAAO,CAACC,GAAR,CAAYrC,EAAE,CAACsC,gBAAH,CAAoBT,YAApB,CAAZ;IACA,MAAM,IAAIrB,KAAJ,CAAU,kCAAV,CAAN;EACH;;EACD,OAAOqB,YAAP;AACH;AACD,OAAO,SAASU,oBAAT,CAA8BvC,EAA9B,EAAkCwC,oBAAlC,EAAwD;EAC3D,MAAMC,cAAc,GAAGhB,WAAW,CAACzB,EAAD,EAAK,MAAMA,EAAE,CAAC8B,YAAH,CAAgB9B,EAAE,CAAC0C,eAAnB,CAAX,EAAgD,wCAAhD,CAAlC;EACA3C,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAACgC,YAAH,CAAgBS,cAAhB,EAAgCD,oBAAhC,CAAX,CAAZ;EACAzC,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAACiC,aAAH,CAAiBQ,cAAjB,CAAX,CAAZ;;EACA,IAAI9C,GAAG,GAAGgD,GAAN,CAAU,qBAAV,CAAJ,EAAsC;IAClC,OAAOF,cAAP;EACH;;EACD,IAAIzC,EAAE,CAACkC,kBAAH,CAAsBO,cAAtB,EAAsCzC,EAAE,CAACmC,cAAzC,MAA6D,KAAjE,EAAwE;IACpES,yBAAyB,CAACJ,oBAAD,EAAuBxC,EAAE,CAACsC,gBAAH,CAAoBG,cAApB,CAAvB,CAAzB;IACA,MAAM,IAAIjC,KAAJ,CAAU,oCAAV,CAAN;EACH;;EACD,OAAOiC,cAAP;AACH;AACD,MAAMI,eAAe,GAAG,0BAAxB;AACA,OAAO,SAASD,yBAAT,CAAmCZ,YAAnC,EAAiDc,aAAjD,EAAgE;EACnE,MAAMC,qBAAqB,GAAGF,eAAe,CAACG,IAAhB,CAAqBF,aAArB,CAA9B;;EACA,IAAIC,qBAAqB,IAAI,IAA7B,EAAmC;IAC/BX,OAAO,CAACC,GAAR,CAAa,wCAAuCS,aAAc,EAAlE;IACAV,OAAO,CAACC,GAAR,CAAYL,YAAZ;IACA;EACH;;EACD,MAAMiB,UAAU,GAAG,CAACF,qBAAqB,CAAC,CAAD,CAAzC;EACA,MAAMG,WAAW,GAAGlB,YAAY,CAACmB,KAAb,CAAmB,IAAnB,CAApB;EACA,MAAMC,GAAG,GAAGF,WAAW,CAACG,MAAZ,CAAmBC,QAAnB,GAA8BD,MAA9B,GAAuC,CAAnD;EACA,MAAME,oBAAoB,GAAGL,WAAW,CAACM,GAAZ,CAAgB,CAACC,IAAD,EAAOR,UAAP,KAAsBrD,IAAI,CAAC8D,QAAL,CAAc,CAACT,UAAU,GAAG,CAAd,EAAiBK,QAAjB,EAAd,EAA2CF,GAA3C,IAAkDK,IAAxF,CAA7B;EACA,IAAIE,aAAa,GAAG,CAApB;;EACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,oBAAoB,CAACF,MAAzC,EAAiDO,CAAC,EAAlD,EAAsD;IAClDD,aAAa,GAAG7C,IAAI,CAAC+C,GAAL,CAASN,oBAAoB,CAACK,CAAD,CAApB,CAAwBP,MAAjC,EAAyCM,aAAzC,CAAhB;EACH;;EACD,MAAMG,gBAAgB,GAAGP,oBAAoB,CAACQ,KAArB,CAA2B,CAA3B,EAA8Bd,UAAU,GAAG,CAA3C,CAAzB;EACA,MAAMe,SAAS,GAAGT,oBAAoB,CAACQ,KAArB,CAA2Bd,UAAU,GAAG,CAAxC,EAA2CA,UAA3C,CAAlB;EACA,MAAMgB,eAAe,GAAGV,oBAAoB,CAACQ,KAArB,CAA2Bd,UAA3B,CAAxB;EACAb,OAAO,CAACC,GAAR,CAAYyB,gBAAgB,CAACI,IAAjB,CAAsB,IAAtB,CAAZ;EACA9B,OAAO,CAACC,GAAR,CAAYS,aAAa,CAACK,KAAd,CAAoB,IAApB,EAA0B,CAA1B,CAAZ;EACAf,OAAO,CAACC,GAAR,CAAa,MAAKzC,IAAI,CAAC8D,QAAL,CAAcM,SAAS,CAAC,CAAD,CAAvB,EAA4BL,aAA5B,CAA2C,EAA7D,EAAgE,+DAAhE;EACAvB,OAAO,CAACC,GAAR,CAAY4B,eAAe,CAACC,IAAhB,CAAqB,IAArB,CAAZ;AACH;AACD,OAAO,SAASC,aAAT,CAAuBnE,EAAvB,EAA2B;EAC9B,OAAOyB,WAAW,CAACzB,EAAD,EAAK,MAAMA,EAAE,CAACmE,aAAH,EAAX,EAA+B,gCAA/B,CAAlB;AACH;AACD,OAAO,SAASC,WAAT,CAAqBpE,EAArB,EAAyBqE,OAAzB,EAAkC;EACrCtE,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAACoE,WAAH,CAAeC,OAAf,CAAX,CAAZ;;EACA,IAAI1E,GAAG,GAAGgD,GAAN,CAAU,qBAAV,CAAJ,EAAsC;IAClC;EACH;;EACD,IAAI3C,EAAE,CAACsE,mBAAH,CAAuBD,OAAvB,EAAgCrE,EAAE,CAACuE,WAAnC,MAAoD,KAAxD,EAA+D;IAC3DnC,OAAO,CAACC,GAAR,CAAYrC,EAAE,CAACwE,iBAAH,CAAqBH,OAArB,CAAZ;IACA,MAAM,IAAI7D,KAAJ,CAAU,6CAAV,CAAN;EACH;AACJ;AACD,OAAO,SAASiE,eAAT,CAAyBzE,EAAzB,EAA6BqE,OAA7B,EAAsC;EACzCtE,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAACyE,eAAH,CAAmBJ,OAAnB,CAAX,CAAZ;;EACA,IAAIrE,EAAE,CAACsE,mBAAH,CAAuBD,OAAvB,EAAgCrE,EAAE,CAAC0E,eAAnC,MAAwD,KAA5D,EAAmE;IAC/DtC,OAAO,CAACC,GAAR,CAAYrC,EAAE,CAACwE,iBAAH,CAAqBH,OAArB,CAAZ;IACA,MAAM,IAAI7D,KAAJ,CAAU,mCAAV,CAAN;EACH;AACJ;AACD,OAAO,SAASmE,wBAAT,CAAkC3E,EAAlC,EAAsC4E,IAAtC,EAA4C;EAC/C,MAAMC,MAAM,GAAGpD,WAAW,CAACzB,EAAD,EAAK,MAAMA,EAAE,CAAC8E,YAAH,EAAX,EAA8B,8BAA9B,CAA1B;EACA/E,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAAC+E,UAAH,CAAc/E,EAAE,CAACgF,YAAjB,EAA+BH,MAA/B,CAAX,CAAZ;EACA9E,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAACiF,UAAH,CAAcjF,EAAE,CAACgF,YAAjB,EAA+BJ,IAA/B,EAAqC5E,EAAE,CAACkF,WAAxC,CAAX,CAAZ;EACA,OAAOL,MAAP;AACH;AACD,OAAO,SAASM,uBAAT,CAAiCnF,EAAjC,EAAqC4E,IAArC,EAA2C;EAC9C,MAAMC,MAAM,GAAGpD,WAAW,CAACzB,EAAD,EAAK,MAAMA,EAAE,CAAC8E,YAAH,EAAX,EAA8B,8BAA9B,CAA1B;EACA/E,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAAC+E,UAAH,CAAc/E,EAAE,CAACoF,oBAAjB,EAAuCP,MAAvC,CAAX,CAAZ;EACA9E,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAACiF,UAAH,CAAcjF,EAAE,CAACoF,oBAAjB,EAAuCR,IAAvC,EAA6C5E,EAAE,CAACkF,WAAhD,CAAX,CAAZ;EACA,OAAOL,MAAP;AACH;AACD,OAAO,SAASQ,cAAT,GAA0B;EAC7B,IAAI1F,GAAG,GAAG2F,SAAN,CAAgB,eAAhB,MAAqC,CAAzC,EAA4C;IACxC,OAAO,CAAP;EACH;;EACD,OAAO,CAAP;AACH;AACD,OAAO,SAASC,aAAT,CAAuBvF,EAAvB,EAA2B;EAC9B,OAAOyB,WAAW,CAACzB,EAAD,EAAK,MAAMA,EAAE,CAACuF,aAAH,EAAX,EAA+B,gCAA/B,CAAlB;AACH;AACD,OAAO,SAASC,mBAAT,CAA6BC,KAA7B,EAAoCC,MAApC,EAA4C;EAC/C,MAAMC,cAAc,GAAGhG,GAAG,GAAG2F,SAAN,CAAgB,wBAAhB,CAAvB;;EACA,IAAKG,KAAK,IAAI,CAAV,IAAiBC,MAAM,IAAI,CAA/B,EAAmC;IAC/B,MAAME,SAAS,GAAI,IAAGH,KAAM,IAAGC,MAAO,GAAtC;IACA,MAAM,IAAIlF,KAAJ,CAAU,4BAA4BoF,SAA5B,GAAwC,cAAlD,CAAN;EACH;;EACD,IAAKH,KAAK,GAAGE,cAAT,IAA6BD,MAAM,GAAGC,cAA1C,EAA2D;IACvD,MAAMC,SAAS,GAAI,IAAGH,KAAM,IAAGC,MAAO,GAAtC;IACA,MAAM7B,GAAG,GAAI,IAAG8B,cAAe,IAAGA,cAAe,GAAjD;IACA,MAAM,IAAInF,KAAJ,CAAU,4BAA4BoF,SAA5B,GACZ,oDADY,GAC2C/B,GAD3C,GACiD,GAD3D,CAAN;EAEH;AACJ;AACD,OAAO,SAASgC,iBAAT,CAA2B7F,EAA3B,EAA+B;EAClC,OAAOyB,WAAW,CAACzB,EAAD,EAAK,MAAMA,EAAE,CAAC6F,iBAAH,EAAX,EAAmC,oCAAnC,CAAlB;AACH;AACD,OAAO,SAASC,kCAAT,CAA4C9F,EAA5C,EAAgDqE,OAAhD,EAAyD0B,SAAzD,EAAoElB,MAApE,EAA4EmB,mBAA5E,EAAiGC,iBAAjG,EAAoHC,iBAApH,EAAuI;EAC1I,MAAMC,GAAG,GAAGnG,EAAE,CAACoG,iBAAH,CAAqB/B,OAArB,EAA8B0B,SAA9B,CAAZ;;EACA,IAAII,GAAG,KAAK,CAAC,CAAb,EAAgB;IACZ;IACA;IACA,OAAO,KAAP;EACH;;EACDpG,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAAC+E,UAAH,CAAc/E,EAAE,CAACgF,YAAjB,EAA+BH,MAA/B,CAAX,CAAZ;EACA9E,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAACqG,mBAAH,CAAuBF,GAAvB,EAA4BH,mBAA5B,EAAiDhG,EAAE,CAACsG,KAApD,EAA2D,KAA3D,EAAkEL,iBAAlE,EAAqFC,iBAArF,CAAX,CAAZ;EACAnG,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAACuG,uBAAH,CAA2BJ,GAA3B,CAAX,CAAZ;EACA,OAAO,IAAP;AACH;AACD,OAAO,SAASK,eAAT,CAAyBxG,EAAzB,EAA6ByG,OAA7B,EAAsCC,WAAtC,EAAmD;EACtDC,mBAAmB,CAAC3G,EAAD,EAAK0G,WAAL,CAAnB;EACA3G,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAAC4G,aAAH,CAAiB5G,EAAE,CAAC6G,QAAH,GAAcH,WAA/B,CAAX,CAAZ;EACA3G,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAAC8G,WAAH,CAAe9G,EAAE,CAAC+G,UAAlB,EAA8BN,OAA9B,CAAX,CAAZ;AACH;AACD,OAAO,SAASO,iBAAT,CAA2BhH,EAA3B,EAA+B0G,WAA/B,EAA4C;EAC/CC,mBAAmB,CAAC3G,EAAD,EAAK0G,WAAL,CAAnB;EACA3G,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAAC4G,aAAH,CAAiB5G,EAAE,CAAC6G,QAAH,GAAcH,WAA/B,CAAX,CAAZ;EACA3G,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAAC8G,WAAH,CAAe9G,EAAE,CAAC+G,UAAlB,EAA8B,IAA9B,CAAX,CAAZ;AACH;AACD,OAAO,SAASE,gCAAT,CAA0CjH,EAA1C,EAA8CqE,OAA9C,EAAuD6C,WAAvD,EAAoE;EACvE,OAAOzF,WAAW,CAACzB,EAAD,EAAK,MAAMA,EAAE,CAACmH,kBAAH,CAAsB9C,OAAtB,EAA+B6C,WAA/B,CAAX,EAAwD,cAAcA,WAAd,GAA4B,2BAApF,CAAlB;AACH;AACD,OAAO,SAASE,yBAAT,CAAmCpH,EAAnC,EAAuCqE,OAAvC,EAAgD6C,WAAhD,EAA6D;EAChE,OAAOlH,EAAE,CAACmH,kBAAH,CAAsB9C,OAAtB,EAA+B6C,WAA/B,CAAP;AACH;AACD,OAAO,SAASG,kCAAT,CAA4CrH,EAA5C,EAAgDyG,OAAhD,EAAyDa,sBAAzD,EAAiFZ,WAAjF,EAA8F;EACjG3G,YAAY,CAACC,EAAD,EAAK,MAAMwG,eAAe,CAACxG,EAAD,EAAKyG,OAAL,EAAcC,WAAd,CAA1B,CAAZ;EACA3G,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAACuH,SAAH,CAAaD,sBAAb,EAAqCZ,WAArC,CAAX,CAAZ;AACH;AACD,OAAO,SAASc,uBAAT,CAAiCxH,EAAjC,EAAqC;EACxCD,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAACyH,eAAH,CAAmBzH,EAAE,CAAC0H,WAAtB,EAAmC,IAAnC,CAAX,CAAZ;EACA3H,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAAC2H,QAAH,CAAY,CAAZ,EAAe,CAAf,EAAkB3H,EAAE,CAAC4H,MAAH,CAAUnC,KAA5B,EAAmCzF,EAAE,CAAC4H,MAAH,CAAUlC,MAA7C,CAAX,CAAZ;EACA3F,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAAC6H,OAAH,CAAW,CAAX,EAAc,CAAd,EAAiB7H,EAAE,CAAC4H,MAAH,CAAUnC,KAA3B,EAAkCzF,EAAE,CAAC4H,MAAH,CAAUlC,MAA5C,CAAX,CAAZ;AACH;AACD,OAAO,SAASoC,6BAAT,CAAuC9H,EAAvC,EAA2CyG,OAA3C,EAAoDsB,WAApD,EAAiE;EACpEhI,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAACyH,eAAH,CAAmBzH,EAAE,CAAC0H,WAAtB,EAAmCK,WAAnC,CAAX,CAAZ;EACAhI,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAACgI,oBAAH,CAAwBhI,EAAE,CAAC0H,WAA3B,EAAwC1H,EAAE,CAACiI,iBAA3C,EAA8DjI,EAAE,CAAC+G,UAAjE,EAA6EN,OAA7E,EAAsF,CAAtF,CAAX,CAAZ;AACH;AACD,OAAO,SAASyB,iCAAT,CAA2ClI,EAA3C,EAA+C+H,WAA/C,EAA4D;EAC/DhI,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAACyH,eAAH,CAAmBzH,EAAE,CAAC0H,WAAtB,EAAmCK,WAAnC,CAAX,CAAZ;EACAhI,YAAY,CAACC,EAAD,EAAK,MAAMA,EAAE,CAACgI,oBAAH,CAAwBhI,EAAE,CAAC0H,WAA3B,EAAwC1H,EAAE,CAACiI,iBAA3C,EAA8DjI,EAAE,CAAC+G,UAAjE,EAA6E,IAA7E,EAAmF,CAAnF,CAAX,CAAZ;AACH;AACD,OAAO,SAASoB,mBAAT,CAA6BnI,EAA7B,EAAiC;EACpC,MAAMgB,MAAM,GAAGhB,EAAE,CAACoI,sBAAH,CAA0BpI,EAAE,CAAC0H,WAA7B,CAAf;;EACA,IAAI1G,MAAM,KAAKhB,EAAE,CAACqI,oBAAlB,EAAwC;IACpC,MAAM,IAAI7H,KAAJ,CAAU,gCAAgC8H,0BAA0B,CAACtI,EAAD,EAAKgB,MAAL,CAApE,CAAN;EACH;AACJ;AACD,OAAO,SAASsH,0BAAT,CAAoCtI,EAApC,EAAwCgB,MAAxC,EAAgD;EACnD,QAAQA,MAAR;IACI,KAAKhB,EAAE,CAACuI,iCAAR;MACI,OAAO,mCAAP;;IACJ,KAAKvI,EAAE,CAACwI,yCAAR;MACI,OAAO,2CAAP;;IACJ,KAAKxI,EAAE,CAACyI,iCAAR;MACI,OAAO,mCAAP;;IACJ,KAAKzI,EAAE,CAAC0I,uBAAR;MACI,OAAO,yBAAP;;IACJ;MACI,OAAQ,iBAAgB1H,MAAO,EAA/B;EAVR;AAYH;;AACD,SAASS,WAAT,CAAqBzB,EAArB,EAAyB2I,aAAzB,EAAwCC,cAAxC,EAAwD;EACpD,MAAMC,OAAO,GAAG9I,YAAY,CAACC,EAAD,EAAK,MAAM2I,aAAa,EAAxB,CAA5B;;EACA,IAAIE,OAAO,IAAI,IAAf,EAAqB;IACjB,MAAM,IAAIrI,KAAJ,CAAUoI,cAAV,CAAN;EACH;;EACD,OAAOC,OAAP;AACH;;AACD,SAASlC,mBAAT,CAA6B3G,EAA7B,EAAiC0G,WAAjC,EAA8C;EAC1C,MAAMoC,cAAc,GAAG9I,EAAE,CAAC+I,gCAAH,GAAsC,CAA7D;EACA,MAAMC,aAAa,GAAGtC,WAAW,GAAG1G,EAAE,CAAC6G,QAAvC;;EACA,IAAImC,aAAa,GAAGhJ,EAAE,CAAC6G,QAAnB,IAA+BmC,aAAa,GAAGF,cAAnD,EAAmE;IAC/D,MAAMG,gBAAgB,GAAI,2BAA0BH,cAAe,GAAnE;IACA,MAAM,IAAItI,KAAJ,CAAW,0BAAyByI,gBAAiB,GAArD,CAAN;EACH;AACJ;;AACD,OAAO,SAASC,WAAT,CAAqBC,KAArB,EAA4BC,UAAU,GAAG,CAAzC,EAA4C;EAC/C,OAAOxJ,IAAI,CAACyJ,aAAL,CAAmBF,KAAK,CAACpF,KAAN,CAAY,CAAZ,EAAeoF,KAAK,CAAC9F,MAAN,GAAe+F,UAA9B,CAAnB,CAAP;AACH;AACD,OAAO,SAASE,WAAT,CAAqBH,KAArB,EAA4B;EAC/B,IAAIA,KAAK,CAAC9F,MAAN,KAAiB,CAArB,EAAwB;IACpB,MAAM7C,KAAK,CAAC,sDAAD,CAAX;EACH;;EACD,OAAO,CACH2I,KAAK,CAAC9F,MAAN,GAAe,CAAf,GAAmB8F,KAAK,CAACA,KAAK,CAAC9F,MAAN,GAAe,CAAhB,CAAxB,GAA6C,CAD1C,EAC6C8F,KAAK,CAACA,KAAK,CAAC9F,MAAN,GAAe,CAAhB,CADlD,CAAP;AAGH;AACD,OAAO,SAASkG,YAAT,CAAsBJ,KAAtB,EAA6B;EAChC,IAAIK,SAAS,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAhB;EACA,MAAMC,QAAQ,GAAGN,KAAK,CAAC9F,MAAN,KAAiB,CAAjB,IAAuB8F,KAAK,CAAC9F,MAAN,KAAiB,CAAjB,IAAsB8F,KAAK,CAAC,CAAD,CAAL,KAAa,CAA3E;;EACA,IAAI,CAACM,QAAL,EAAe;IACXD,SAAS,GACL,CAACN,WAAW,CAACC,KAAD,CAAZ,EAAqB,GAAGG,WAAW,CAACH,KAAD,CAAnC,CADJ;EAEH;;EACD,OAAOK,SAAP;AACH;AACD,OAAO,SAASE,+BAAT,CAAyCC,QAAzC,EAAmDC,QAAQ,GAAG,KAA9D,EAAqE;EACxE,IAAIC,UAAU,GAAGlK,GAAG,GAAG2F,SAAN,CAAgB,wBAAhB,CAAjB;EACA,IAAIwE,mBAAmB,GAAGnK,GAAG,GAAG2F,SAAN,CAAgB,mCAAhB,CAA1B;;EACA,IAAIwE,mBAAmB,KAAKC,QAAxB,IACApK,GAAG,GAAGQ,OAAN,CAAc,0CAAd,CADJ,EAC+D;IAC3D2J,mBAAmB,GAAGD,UAAU,GAAG,CAAnC;EACH;;EACD,IAAID,QAAJ,EAAc;IACVC,UAAU,GAAGA,UAAU,GAAG,CAA1B;IACAC,mBAAmB,GAAGA,mBAAmB,GAAG,CAA5C,CAFU,CAGV;IACA;IACA;IACA;IACA;;IACAH,QAAQ,GAAGA,QAAQ,CAACnG,GAAT,CAAa,CAACwG,CAAD,EAAIpG,CAAJ,KAAUA,CAAC,IAAI+F,QAAQ,CAACtG,MAAT,GAAkB,CAAvB,GAC9BzD,IAAI,CAACqK,iBAAL,CAAuBN,QAAQ,CAAC/F,CAAD,CAA/B,CAD8B,GAE9B+F,QAAQ,CAAC/F,CAAD,CAFD,CAAX,CARU,CAWV;IACA;;IACA,IAAI+F,QAAQ,CAACtG,MAAT,KAAoB,CAAxB,EAA2B;MACvBsG,QAAQ,GAAG,CAAC,CAAD,EAAIA,QAAQ,CAAC,CAAD,CAAZ,CAAX;IACH;EACJ,CAvBuE,CAwBxE;;;EACA,IAAIA,QAAQ,CAACtG,MAAT,KAAoB,CAAxB,EAA2B;IACvB,MAAM6G,aAAa,GAAGtK,IAAI,CAACuK,YAAL,CAAkBR,QAAlB,CAAtB;IACAA,QAAQ,GAAGO,aAAa,CAACE,QAAzB;EACH;;EACD,IAAIC,IAAI,GAAGzK,IAAI,CAACyJ,aAAL,CAAmBM,QAAnB,CAAX;EACA,IAAIW,YAAY,GAAG,IAAnB;;EACA,IAAIX,QAAQ,CAACtG,MAAT,IAAmB,CAAnB,IAAwBgH,IAAI,IAAIR,UAApC,EAAgD;IAC5CS,YAAY,GAAG,CAAC,CAAD,EAAID,IAAJ,CAAf;EACH,CAFD,MAGK,IAAIV,QAAQ,CAACtG,MAAT,KAAoB,CAApB,IAAyBsG,QAAQ,CAAC,CAAD,CAAR,IAAeE,UAAxC,IACLF,QAAQ,CAAC,CAAD,CAAR,IAAeE,UADd,EAC0B;IAC3BS,YAAY,GAAGX,QAAf;EACH,CAHI,MAIA,IAAIA,QAAQ,CAACtG,MAAT,KAAoB,CAApB,IAAyBsG,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAAtB,IAA6BE,UAAtD,IACLF,QAAQ,CAAC,CAAD,CAAR,IAAeE,UADd,EAC0B;IAC3BS,YAAY,GAAG,CAACX,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAAvB,EAA4BA,QAAQ,CAAC,CAAD,CAApC,CAAf;EACH,CAHI,MAIA,IAAIA,QAAQ,CAACtG,MAAT,KAAoB,CAApB,IAAyBsG,QAAQ,CAAC,CAAD,CAAR,IAAeE,UAAxC,IACLF,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAAtB,IAA6BE,UAD5B,EACwC;IACzCS,YAAY,GAAG,CAACX,QAAQ,CAAC,CAAD,CAAT,EAAcA,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAApC,CAAf;EACH,CAHI,MAIA,IAAIA,QAAQ,CAACtG,MAAT,KAAoB,CAApB,IACLsG,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAAtB,GAA4BA,QAAQ,CAAC,CAAD,CAApC,IAA2CE,UADtC,IAELF,QAAQ,CAAC,CAAD,CAAR,IAAeE,UAFd,EAE0B;IAC3BS,YAAY,GAAG,CAACX,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAAtB,GAA4BA,QAAQ,CAAC,CAAD,CAArC,EAA0CA,QAAQ,CAAC,CAAD,CAAlD,CAAf;EACH,CAJI,MAKA,IAAIA,QAAQ,CAACtG,MAAT,KAAoB,CAApB,IAAyBsG,QAAQ,CAAC,CAAD,CAAR,IAAeE,UAAxC,IACLF,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAAtB,GAA4BA,QAAQ,CAAC,CAAD,CAApC,IAA2CE,UAD1C,EACsD;IACvDS,YAAY,GAAG,CAACX,QAAQ,CAAC,CAAD,CAAT,EAAcA,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAAtB,GAA4BA,QAAQ,CAAC,CAAD,CAAlD,CAAf;EACH,CAtDuE,CAuDxE;EACA;;;EACA,MAAMY,eAAe,GAAGD,YAAY,IAAI,IAAhB,IACpBxJ,IAAI,CAAC+C,GAAL,CAAS,GAAGyG,YAAZ,IAA4BR,mBADR,IAEpBhJ,IAAI,CAAC0J,GAAL,CAAS,GAAGF,YAAZ,MAA8BV,QAAQ,GAAG,CAAH,GAAO,CAA7C,CAFoB,IAGpB9I,IAAI,CAAC0J,GAAL,CAAS,GAAGF,YAAZ,IAA4B,CAHhC;;EAIA,IAAIA,YAAY,IAAI,IAAhB,IAAwBC,eAA5B,EAA6C;IACzC,IAAIX,QAAJ,EAAc;MACV;MACA;MACA;MACA;MACA;MACA,MAAMa,QAAQ,GAAGvB,WAAW,CAACS,QAAD,CAA5B;MACA,IAAIe,IAAI,GAAG,CAAX;MAAA,IAAcC,IAAI,GAAG,CAArB;;MACA,IAAIhB,QAAQ,CAACtG,MAAb,EAAqB;QACjB,CAACqH,IAAD,EAAOC,IAAP,IAAerB,WAAW,CAACK,QAAD,CAA1B;MACH;;MACDU,IAAI,GAAGI,QAAQ,IAAIC,IAAI,GAAG,CAAX,CAAR,IAAyBC,IAAI,GAAG,CAAhC,CAAP;MACAL,YAAY,GACR1K,IAAI,CAACgL,mBAAL,CAAyBP,IAAzB,EAA+B7G,GAA/B,CAAmCwG,CAAC,IAAIA,CAAC,GAAG,CAA5C,CADJ;IAEH,CAdD,MAeK;MACDM,YAAY,GAAG1K,IAAI,CAACgL,mBAAL,CAAyBP,IAAzB,CAAf;IACH;EACJ;;EACD,OAAOC,YAAP;AACH;;AACD,SAASO,MAAT,CAAgBC,CAAhB,EAAmB;EACf,OAAOA,CAAC,GAAG,CAAJ,KAAU,CAAjB;AACH;AACD;AACA;AACA;AACA;;;AACA,OAAO,SAASC,aAAT,CAAuBC,MAAvB,EAA+BC,MAA/B,EAAuC;EAC1CD,MAAM,GAAGA,MAAM,CAACjH,KAAP,CAAa,CAAC,CAAd,CAAT;EACAkH,MAAM,GAAGA,MAAM,CAAClH,KAAP,CAAa,CAAC,CAAd,CAAT;;EACA,IAAInE,IAAI,CAACsL,WAAL,CAAiBF,MAAjB,EAAyBC,MAAzB,CAAJ,EAAsC;IAClC,OAAO,IAAP;EACH;;EACD,IAAI,CAACD,MAAM,CAAC3H,MAAR,IAAkB,CAAC4H,MAAM,CAAC5H,MAA9B,EAAsC;IAAE;IACpC,OAAO,IAAP;EACH;;EACD,IAAI2H,MAAM,CAAC,CAAD,CAAN,KAAc,CAAd,IAAmBA,MAAM,CAAC,CAAD,CAAN,KAAc,CAAjC,IAAsCC,MAAM,CAAC,CAAD,CAAN,KAAc,CAApD,IACAA,MAAM,CAAC,CAAD,CAAN,KAAc,CADlB,EACqB;IACjB,OAAO,IAAP;EACH;;EACD,IAAID,MAAM,CAAC3H,MAAP,KAAkB4H,MAAM,CAAC5H,MAA7B,EAAqC;IAAE;IACnC,MAAM8H,UAAU,GAAGH,MAAM,CAACjH,KAAP,CAAa,CAAC,CAAd,EAAiB,CAAjB,CAAnB;IACA,MAAMqH,UAAU,GAAGH,MAAM,CAAClH,KAAP,CAAa,CAAC,CAAd,EAAiB,CAAjB,CAAnB;;IACA,IAAIoH,UAAU,KAAKC,UAAnB,EAA+B;MAC3B,OAAO,IAAP;IACH;;IACD,IAAIP,MAAM,CAACM,UAAD,CAAN,IAAsBN,MAAM,CAACO,UAAD,CAA5B,KACCJ,MAAM,CAAC,CAAD,CAAN,KAAc,CAAd,IAAmBC,MAAM,CAAC,CAAD,CAAN,KAAc,CADlC,CAAJ,EAC0C;MACtC,OAAO,IAAP;IACH;EACJ;;EACD,OAAOD,MAAM,CAAC,CAAD,CAAN,KAAcC,MAAM,CAAC,CAAD,CAApB,IAA2BJ,MAAM,CAACG,MAAM,CAAC,CAAD,CAAP,CAAjC,IAAgDH,MAAM,CAACI,MAAM,CAAC,CAAD,CAAP,CAA7D;AACH,C,CACD;AACA;AACA;;AACA,IAAII,gBAAJ;AACA,IAAIC,sBAAJ;AACA,OAAO,SAASC,sBAAT,CAAgCC,YAAhC,EAA8C;EACjD,IAAIH,gBAAgB,IAAI,IAAxB,EAA8B;IAC1B,MAAMrL,EAAE,GAAGH,eAAe,CAAC2L,YAAD,CAA1B;IACAH,gBAAgB,GAAGrL,EAAE,CAACyL,YAAH,CAAgBzL,EAAE,CAACqL,gBAAnB,CAAnB;EACH;;EACD,OAAOA,gBAAP;AACH;AACD,OAAO,SAASK,mBAAT,GAA+B;EAClCL,gBAAgB,GAAG,IAAnB;AACH;AACD,OAAO,SAASM,wBAAT,GAAoC;EACvCL,sBAAsB,GAAG,IAAzB;AACH;AACD,OAAO,SAASM,sBAAT,CAAgCJ,YAAhC,EAA8C;EACjD,IAAIF,sBAAsB,IAAI,IAA9B,EAAoC;IAChC,MAAMtL,EAAE,GAAGH,eAAe,CAAC2L,YAAD,CAA1B;IACAF,sBAAsB,GAAGtL,EAAE,CAACyL,YAAH,CAAgBzL,EAAE,CAAC6L,uBAAnB,CAAzB;EACH,CAJgD,CAKjD;;;EACA,OAAO/K,IAAI,CAAC0J,GAAL,CAAS,EAAT,EAAac,sBAAb,CAAP;AACH;AACD,OAAO,SAASQ,iCAAT,CAA2CN,YAA3C,EAAyD;EAC5D,IAAIA,YAAY,KAAK,CAArB,EAAwB;IACpB,OAAO,CAAP;EACH;;EACD,IAAIO,iBAAJ;EACA,MAAM/L,EAAE,GAAGH,eAAe,CAAC2L,YAAD,CAA1B;;EACA,IAAIQ,YAAY,CAAChM,EAAD,EAAK,iCAAL,CAAZ,IACAwL,YAAY,KAAK,CADrB,EACwB;IACpBO,iBAAiB,GAAG,CAApB;EACH,CAHD,MAIK,IAAIC,YAAY,CAAChM,EAAD,EAAK,0BAAL,CAAhB,EAAkD;IACnD+L,iBAAiB,GAAG,CAApB;EACH,CAFI,MAGA;IACDA,iBAAiB,GAAG,CAApB;EACH;;EACD,OAAOA,iBAAP;AACH;AACD,OAAO,SAASC,YAAT,CAAsBhM,EAAtB,EAA0BwB,aAA1B,EAAyC;EAC5C,MAAMyK,GAAG,GAAGjM,EAAE,CAAC0B,YAAH,CAAgBF,aAAhB,CAAZ;EACA,OAAOyK,GAAG,IAAI,IAAd;AACH;AACD,OAAO,SAASC,qBAAT,CAA+BV,YAA/B,EAA6C;EAChD,IAAI;IACA,MAAMxL,EAAE,GAAGH,eAAe,CAAC2L,YAAD,CAA1B;;IACA,IAAIxL,EAAE,IAAI,IAAV,EAAgB;MACZ,OAAO,IAAP;IACH;EACJ,CALD,CAMA,OAAOmM,CAAP,EAAU;IACN/J,OAAO,CAACC,GAAR,CAAY,oCAAZ,EAAkD8J,CAAlD;IACA,OAAO,KAAP;EACH;;EACD,OAAO,KAAP;AACH;AACD,OAAO,SAASC,kCAAT,CAA4CZ,YAA5C,EAA0D;EAC7D,IAAIA,YAAY,KAAK,CAArB,EAAwB;IACpB,OAAO,KAAP;EACH;;EACD,MAAMxL,EAAE,GAAGH,eAAe,CAAC2L,YAAD,CAA1B;;EACA,IAAIA,YAAY,KAAK,CAArB,EAAwB;IACpB,IAAI,CAACQ,YAAY,CAAChM,EAAD,EAAK,mBAAL,CAAjB,EAA4C;MACxC,OAAO,KAAP;IACH;EACJ,CAJD,MAKK;IACD,IAAI,CAACgM,YAAY,CAAChM,EAAD,EAAK,wBAAL,CAAjB,EAAiD;MAC7C,OAAO,KAAP;IACH;EACJ;;EACD,MAAMqM,qBAAqB,GAAGC,sCAAsC,CAACtM,EAAD,CAApE;EACA,OAAOqM,qBAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASE,6BAAT,CAAuCf,YAAvC,EAAqD;EACxD,IAAIA,YAAY,KAAK,CAArB,EAAwB;IACpB,OAAO,KAAP;EACH;;EACD,MAAMxL,EAAE,GAAGH,eAAe,CAAC2L,YAAD,CAA1B;;EACA,IAAIA,YAAY,KAAK,CAArB,EAAwB;IACpB,IAAI,CAACQ,YAAY,CAAChM,EAAD,EAAK,mBAAL,CAAjB,EAA4C;MACxC,OAAO,KAAP;IACH;;IACD,IAAI,CAACgM,YAAY,CAAChM,EAAD,EAAK,0BAAL,CAAjB,EAAmD;MAC/C,OAAO,KAAP;IACH;EACJ,CAPD,MAQK;IACD,IAAIgM,YAAY,CAAChM,EAAD,EAAK,wBAAL,CAAhB,EAAgD;MAC5C,OAAOsM,sCAAsC,CAACtM,EAAD,CAA7C;IACH;;IACD,MAAMwM,uBAAuB,GAAG,6BAAhC;;IACA,IAAIR,YAAY,CAAChM,EAAD,EAAKwM,uBAAL,CAAhB,EAA+C;MAC3C,MAAMC,yBAAyB,GAAGzM,EAAE,CAAC0B,YAAH,CAAgB8K,uBAAhB,CAAlC;MACA,OAAOE,0CAA0C,CAAC1M,EAAD,EAAKyM,yBAAL,CAAjD;IACH;;IACD,OAAO,KAAP;EACH;;EACD,MAAMJ,qBAAqB,GAAGC,sCAAsC,CAACtM,EAAD,CAApE;EACA,OAAOqM,qBAAP;AACH;;AACD,SAASC,sCAAT,CAAgDtM,EAAhD,EAAoD;EAChD,MAAM2M,SAAS,GAAG7M,gBAAgB,CAACE,EAAD,CAAlC;EACA,MAAMyG,OAAO,GAAGzG,EAAE,CAACuF,aAAH,EAAhB;EACAvF,EAAE,CAAC8G,WAAH,CAAe9G,EAAE,CAAC+G,UAAlB,EAA8BN,OAA9B;EACA,MAAMhB,KAAK,GAAG,CAAd;EACA,MAAMC,MAAM,GAAG,CAAf;EACA1F,EAAE,CAAC4M,UAAH,CAAc5M,EAAE,CAAC+G,UAAjB,EAA6B,CAA7B,EAAgC4F,SAAS,CAACE,mBAA1C,EAA+DpH,KAA/D,EAAsEC,MAAtE,EAA8E,CAA9E,EAAiFiH,SAAS,CAACG,kBAA3F,EAA+GH,SAAS,CAACI,gBAAzH,EAA2I,IAA3I;EACA,MAAMC,WAAW,GAAGhN,EAAE,CAAC6F,iBAAH,EAApB;EACA7F,EAAE,CAACyH,eAAH,CAAmBzH,EAAE,CAAC0H,WAAtB,EAAmCsF,WAAnC;EACAhN,EAAE,CAACgI,oBAAH,CAAwBhI,EAAE,CAAC0H,WAA3B,EAAwC1H,EAAE,CAACiI,iBAA3C,EAA8DjI,EAAE,CAAC+G,UAAjE,EAA6EN,OAA7E,EAAsF,CAAtF;EACA,MAAM4F,qBAAqB,GAAGrM,EAAE,CAACoI,sBAAH,CAA0BpI,EAAE,CAAC0H,WAA7B,MAA8C1H,EAAE,CAACqI,oBAA/E;EACArI,EAAE,CAAC8G,WAAH,CAAe9G,EAAE,CAAC+G,UAAlB,EAA8B,IAA9B;EACA/G,EAAE,CAACyH,eAAH,CAAmBzH,EAAE,CAAC0H,WAAtB,EAAmC,IAAnC;EACA1H,EAAE,CAACiN,aAAH,CAAiBxG,OAAjB;EACAzG,EAAE,CAACkN,iBAAH,CAAqBF,WAArB;EACA,OAAOX,qBAAP;AACH;;AACD,SAASK,0CAAT,EACA;AACA1M,EAFA,EAEIyM,yBAFJ,EAE+B;EAC3B,MAAME,SAAS,GAAG7M,gBAAgB,CAACE,EAAD,EAAKyM,yBAAL,CAAlC;EACA,MAAMhG,OAAO,GAAGzG,EAAE,CAACuF,aAAH,EAAhB;EACAvF,EAAE,CAAC8G,WAAH,CAAe9G,EAAE,CAAC+G,UAAlB,EAA8BN,OAA9B;EACA,MAAMhB,KAAK,GAAG,CAAd;EACA,MAAMC,MAAM,GAAG,CAAf;EACA1F,EAAE,CAAC4M,UAAH,CAAc5M,EAAE,CAAC+G,UAAjB,EAA6B,CAA7B,EAAgC4F,SAAS,CAACQ,uBAA1C,EAAmE1H,KAAnE,EAA0EC,MAA1E,EAAkF,CAAlF,EAAqFiH,SAAS,CAACG,kBAA/F,EAAmHH,SAAS,CAACS,oBAA7H,EAAmJ,IAAnJ;EACA,MAAMJ,WAAW,GAAGhN,EAAE,CAAC6F,iBAAH,EAApB;EACA7F,EAAE,CAACyH,eAAH,CAAmBzH,EAAE,CAAC0H,WAAtB,EAAmCsF,WAAnC;EACAhN,EAAE,CAACgI,oBAAH,CAAwBhI,EAAE,CAAC0H,WAA3B,EAAwC1H,EAAE,CAACiI,iBAA3C,EAA8DjI,EAAE,CAAC+G,UAAjE,EAA6EN,OAA7E,EAAsF,CAAtF;EACA,MAAM4F,qBAAqB,GAAGrM,EAAE,CAACoI,sBAAH,CAA0BpI,EAAE,CAAC0H,WAA7B,MAA8C1H,EAAE,CAACqI,oBAA/E;EACArI,EAAE,CAAC8G,WAAH,CAAe9G,EAAE,CAAC+G,UAAlB,EAA8B,IAA9B;EACA/G,EAAE,CAACyH,eAAH,CAAmBzH,EAAE,CAAC0H,WAAtB,EAAmC,IAAnC;EACA1H,EAAE,CAACiN,aAAH,CAAiBxG,OAAjB;EACAzG,EAAE,CAACkN,iBAAH,CAAqBF,WAArB;EACA,OAAOX,qBAAP;AACH;;AACD,OAAO,SAASgB,mBAAT,CAA6B7B,YAA7B,EAA2C;EAC9C,IAAIA,YAAY,KAAK,CAArB,EAAwB;IACpB,OAAO,KAAP;EACH;;EACD,MAAMxL,EAAE,GAAGH,eAAe,CAAC2L,YAAD,CAA1B,CAJ8C,CAK9C;;EACA,MAAM8B,SAAS,GAAGtN,EAAE,CAACuN,SAAH,IAAgB,IAAlC;EACA,OAAOD,SAAP;AACH;AACD,OAAO,SAASE,gBAAT,CAA0BC,MAA1B,EAAkCC,MAAlC,EAA0C;EAC7C,IAAI,CAACC,KAAK,CAACC,OAAN,CAAcH,MAAd,CAAL,EAA4B;IACxBA,MAAM,GAAG,CAACA,MAAD,CAAT;EACH;;EACDA,MAAM,CAACI,OAAP,CAAeC,CAAC,IAAI;IAChB,IAAIA,CAAC,IAAI,IAAT,EAAe;MACXlO,IAAI,CAACmO,MAAL,CAAYD,CAAC,CAACE,KAAF,KAAY,WAAxB,EAAqC,MAAO,GAAEN,MAAO,sCAAV,GACvC,uBADJ;IAEH;EACJ,CALD;AAMH"},"metadata":{},"sourceType":"module"}