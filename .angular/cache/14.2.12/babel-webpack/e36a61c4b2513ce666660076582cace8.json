{"ast":null,"code":"import { Euler } from 'three';\nimport { quat } from 'gl-matrix';\nimport { Joint, DOF } from '../core/Joint.js';\nimport { Link } from '../core/Link.js';\nconst tempVec = new Float64Array(3);\nconst tempVec2 = new Float64Array(3);\nconst tempEuler = new Euler();\nexport function urdfRobotToIKRoot(urdfNode, trimUnused = false, isRoot = true) {\n  let rootNode = null;\n  let node;\n  let doReturn = true;\n\n  if (urdfNode.isURDFRobot) {\n    rootNode = new Joint();\n    rootNode.name = '__world_joint__';\n    rootNode.setDoF(DOF.X, DOF.Y, DOF.Z, DOF.EX, DOF.EY, DOF.EZ);\n    node = new Link();\n    node.name = urdfNode.name;\n    rootNode.addChild(node);\n  } else if (urdfNode.isURDFLink) {\n    node = new Link();\n    node.name = urdfNode.name;\n    doReturn = !trimUnused;\n  } else if (urdfNode.isURDFJoint) {\n    rootNode = new Joint();\n    const jointType = urdfNode.jointType;\n\n    switch (jointType) {\n      case 'continuous':\n      case 'revolute':\n      case 'prismatic':\n        {\n          const link = new Link();\n          rootNode.addChild(link);\n          const joint = new Joint();\n          joint.name = urdfNode.name;\n          link.addChild(joint);\n          const fixedLink = new Link();\n          joint.addChild(fixedLink);\n          const fixedJoint = new Joint();\n          fixedLink.addChild(fixedJoint);\n          tempVec[0] = 0;\n          tempVec[1] = 0;\n          tempVec[2] = 1;\n          tempVec2[0] = urdfNode.axis.x;\n          tempVec2[1] = urdfNode.axis.y;\n          tempVec2[2] = urdfNode.axis.z; // orient the joint such that +Z is pointing down the URDF rotation axis\n\n          quat.rotationTo(joint.quaternion, tempVec, tempVec2);\n          quat.invert(fixedJoint.quaternion, joint.quaternion);\n          joint.setMatrixNeedsUpdate();\n          fixedJoint.setMatrixNeedsUpdate();\n\n          if (jointType === 'revolute' || jointType === 'continuous') {\n            joint.setDoF(DOF.EZ);\n          } else {\n            joint.setDoF(DOF.Z);\n          }\n\n          if (jointType !== 'continuous') {\n            joint.setMinLimits(urdfNode.limit.lower);\n            joint.setMaxLimits(urdfNode.limit.upper);\n          }\n\n          node = fixedJoint;\n          break;\n        }\n\n      case 'fixed':\n        {\n          node = rootNode;\n          doReturn = !trimUnused;\n          break;\n        }\n\n      case 'planar':\n      case 'floating':\n      default:\n        console.error(`urdfRobotToIKRoot: Joint type ${jointType} not supported.`);\n        doReturn = !trimUnused;\n    }\n  } else {\n    return null;\n  } // don't position the urdf root because we're treating the positions at\n  // degrees of freedom\n\n\n  if (!isRoot) {\n    (rootNode || node).setPosition(urdfNode.position.x, urdfNode.position.y, urdfNode.position.z);\n    (rootNode || node).setQuaternion(urdfNode.quaternion.x, urdfNode.quaternion.y, urdfNode.quaternion.z, urdfNode.quaternion.w);\n  }\n\n  const children = urdfNode.children;\n\n  for (let i = 0, l = children.length; i < l; i++) {\n    const res = urdfRobotToIKRoot(children[i], trimUnused, false);\n\n    if (res) {\n      node.addChild(res);\n      doReturn = true;\n    }\n  }\n\n  return !trimUnused || doReturn ? rootNode || node : null;\n}\nexport function setIKFromUrdf(ikRoot, urdfRoot) {\n  ikRoot.setDoFValue(DOF.X, urdfRoot.position.x);\n  ikRoot.setDoFValue(DOF.Y, urdfRoot.position.y);\n  ikRoot.setDoFValue(DOF.Z, urdfRoot.position.z);\n  tempEuler.copy(urdfRoot.rotation);\n  tempEuler.reorder('ZYX');\n  ikRoot.setDoFValue(DOF.EX, tempEuler.x);\n  ikRoot.setDoFValue(DOF.EY, tempEuler.y);\n  ikRoot.setDoFValue(DOF.EZ, tempEuler.z);\n  ikRoot.traverse(c => {\n    if (c.isJoint) {\n      const name = c.name;\n\n      if (name in urdfRoot.joints) {\n        c.setDoFValues(urdfRoot.joints[name].angle);\n      }\n    }\n  });\n}\nexport function setUrdfFromIK(urdfRoot, ikRoot) {\n  ikRoot.updateMatrixWorld();\n  urdfRoot.matrix.set(...ikRoot.matrixWorld).transpose();\n  urdfRoot.matrix.decompose(urdfRoot.position, urdfRoot.quaternion, urdfRoot.scale); // urdfRoot.position.set(\n  // \tikRoot.getDoFValue( DOF.X ),\n  // \tikRoot.getDoFValue( DOF.Y ),\n  // \tikRoot.getDoFValue( DOF.Z ),\n  // );\n  // urdfRoot.rotation.set(\n  // \tikRoot.getDoFValue( DOF.EX ),\n  // \tikRoot.getDoFValue( DOF.EY ),\n  // \tikRoot.getDoFValue( DOF.EZ ),\n  // );\n\n  ikRoot.traverse(c => {\n    if (c.isJoint) {\n      const ikJoint = c;\n      const urdfJoint = urdfRoot.joints[c.name];\n\n      if (urdfJoint) {\n        if (urdfJoint.jointType === 'prismatic') {\n          urdfJoint.setJointValue(ikJoint.getDoFValue(DOF.Z));\n        } else {\n          urdfJoint.setJointValue(ikJoint.getDoFValue(DOF.EZ));\n        }\n      }\n    }\n  });\n}","map":{"version":3,"names":["Euler","quat","Joint","DOF","Link","tempVec","Float64Array","tempVec2","tempEuler","urdfRobotToIKRoot","urdfNode","trimUnused","isRoot","rootNode","node","doReturn","isURDFRobot","name","setDoF","X","Y","Z","EX","EY","EZ","addChild","isURDFLink","isURDFJoint","jointType","link","joint","fixedLink","fixedJoint","axis","x","y","z","rotationTo","quaternion","invert","setMatrixNeedsUpdate","setMinLimits","limit","lower","setMaxLimits","upper","console","error","setPosition","position","setQuaternion","w","children","i","l","length","res","setIKFromUrdf","ikRoot","urdfRoot","setDoFValue","copy","rotation","reorder","traverse","c","isJoint","joints","setDoFValues","angle","setUrdfFromIK","updateMatrixWorld","matrix","set","matrixWorld","transpose","decompose","scale","ikJoint","urdfJoint","setJointValue","getDoFValue"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/closed-chain-ik/src/three/urdfHelpers.js"],"sourcesContent":["import { Euler } from 'three';\r\nimport { quat } from 'gl-matrix';\r\nimport { Joint, DOF } from '../core/Joint.js';\r\nimport { Link } from '../core/Link.js';\r\n\r\nconst tempVec = new Float64Array( 3 );\r\nconst tempVec2 = new Float64Array( 3 );\r\nconst tempEuler = new Euler();\r\n\r\nexport function urdfRobotToIKRoot( urdfNode, trimUnused = false, isRoot = true ) {\r\n\r\n\tlet rootNode = null;\r\n\tlet node;\r\n\tlet doReturn = true;\r\n\r\n\tif ( urdfNode.isURDFRobot ) {\r\n\r\n\t\trootNode = new Joint();\r\n\t\trootNode.name = '__world_joint__';\r\n\t\trootNode.setDoF( DOF.X, DOF.Y, DOF.Z, DOF.EX, DOF.EY, DOF.EZ );\r\n\r\n\t\tnode = new Link();\r\n\t\tnode.name = urdfNode.name;\r\n\r\n\t\trootNode.addChild( node );\r\n\r\n\t} else if ( urdfNode.isURDFLink ) {\r\n\r\n\t\tnode = new Link();\r\n\t\tnode.name = urdfNode.name;\r\n\t\tdoReturn = ! trimUnused;\r\n\r\n\t} else if ( urdfNode.isURDFJoint ) {\r\n\r\n\t\trootNode = new Joint();\r\n\r\n\t\tconst jointType = urdfNode.jointType;\r\n\t\tswitch ( jointType ) {\r\n\r\n\t\t\tcase 'continuous':\r\n\t\t\tcase 'revolute':\r\n\t\t\tcase 'prismatic': {\r\n\r\n\t\t\t\tconst link = new Link();\r\n\t\t\t\trootNode.addChild( link );\r\n\r\n\t\t\t\tconst joint = new Joint();\r\n\t\t\t\tjoint.name = urdfNode.name;\r\n\t\t\t\tlink.addChild( joint );\r\n\r\n\t\t\t\tconst fixedLink = new Link();\r\n\t\t\t\tjoint.addChild( fixedLink );\r\n\r\n\t\t\t\tconst fixedJoint = new Joint();\r\n\t\t\t\tfixedLink.addChild( fixedJoint );\r\n\r\n\t\t\t\ttempVec[ 0 ] = 0;\r\n\t\t\t\ttempVec[ 1 ] = 0;\r\n\t\t\t\ttempVec[ 2 ] = 1;\r\n\r\n\t\t\t\ttempVec2[ 0 ] = urdfNode.axis.x;\r\n\t\t\t\ttempVec2[ 1 ] = urdfNode.axis.y;\r\n\t\t\t\ttempVec2[ 2 ] = urdfNode.axis.z;\r\n\r\n\t\t\t\t// orient the joint such that +Z is pointing down the URDF rotation axis\r\n\t\t\t\tquat.rotationTo( joint.quaternion, tempVec, tempVec2 );\r\n\t\t\t\tquat.invert( fixedJoint.quaternion, joint.quaternion );\r\n\t\t\t\tjoint.setMatrixNeedsUpdate();\r\n\t\t\t\tfixedJoint.setMatrixNeedsUpdate();\r\n\r\n\t\t\t\tif ( jointType === 'revolute' || jointType === 'continuous' ) {\r\n\r\n\t\t\t\t\tjoint.setDoF( DOF.EZ );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tjoint.setDoF( DOF.Z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( jointType !== 'continuous' ) {\r\n\r\n\t\t\t\t\tjoint.setMinLimits( urdfNode.limit.lower );\r\n\t\t\t\t\tjoint.setMaxLimits( urdfNode.limit.upper );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnode = fixedJoint;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcase 'fixed': {\r\n\r\n\t\t\t\tnode = rootNode;\r\n\t\t\t\tdoReturn = ! trimUnused;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcase 'planar':\r\n\t\t\tcase 'floating':\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tconsole.error( `urdfRobotToIKRoot: Joint type ${jointType} not supported.` );\r\n\t\t\t\tdoReturn = ! trimUnused;\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\t// don't position the urdf root because we're treating the positions at\r\n\t// degrees of freedom\r\n\tif ( ! isRoot ) {\r\n\r\n\t\t( rootNode || node )\r\n\t\t\t.setPosition(\r\n\t\t\t\turdfNode.position.x,\r\n\t\t\t\turdfNode.position.y,\r\n\t\t\t\turdfNode.position.z,\r\n\t\t\t);\r\n\r\n\t\t( rootNode || node )\r\n\t\t\t.setQuaternion(\r\n\t\t\t\turdfNode.quaternion.x,\r\n\t\t\t\turdfNode.quaternion.y,\r\n\t\t\t\turdfNode.quaternion.z,\r\n\t\t\t\turdfNode.quaternion.w,\r\n\t\t\t);\r\n\r\n\t}\r\n\r\n\tconst children = urdfNode.children;\r\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\tconst res = urdfRobotToIKRoot( children[ i ], trimUnused, false );\r\n\r\n\t\tif ( res ) {\r\n\r\n\t\t\tnode.addChild( res );\r\n\t\t\tdoReturn = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\treturn ( ! trimUnused || doReturn ) ? rootNode || node : null;\r\n\r\n}\r\n\r\nexport function setIKFromUrdf( ikRoot, urdfRoot ) {\r\n\r\n\tikRoot.setDoFValue( DOF.X, urdfRoot.position.x );\r\n\tikRoot.setDoFValue( DOF.Y, urdfRoot.position.y );\r\n\tikRoot.setDoFValue( DOF.Z, urdfRoot.position.z );\r\n\r\n\ttempEuler.copy( urdfRoot.rotation );\r\n\ttempEuler.reorder( 'ZYX' );\r\n\tikRoot.setDoFValue( DOF.EX, tempEuler.x );\r\n\tikRoot.setDoFValue( DOF.EY, tempEuler.y );\r\n\tikRoot.setDoFValue( DOF.EZ, tempEuler.z );\r\n\r\n\tikRoot.traverse( c => {\r\n\r\n\t\tif ( c.isJoint ) {\r\n\r\n\t\t\tconst name = c.name;\r\n\t\t\tif ( name in urdfRoot.joints ) {\r\n\r\n\t\t\t\tc.setDoFValues( urdfRoot.joints[ name ].angle );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n}\r\n\r\nexport function setUrdfFromIK( urdfRoot, ikRoot ) {\r\n\r\n\tikRoot.updateMatrixWorld();\r\n\turdfRoot.matrix.set( ...ikRoot.matrixWorld ).transpose();\r\n\turdfRoot.matrix.decompose(\r\n\t\turdfRoot.position,\r\n\t\turdfRoot.quaternion,\r\n\t\turdfRoot.scale,\r\n\t);\r\n\r\n\t// urdfRoot.position.set(\r\n\t// \tikRoot.getDoFValue( DOF.X ),\r\n\t// \tikRoot.getDoFValue( DOF.Y ),\r\n\t// \tikRoot.getDoFValue( DOF.Z ),\r\n\t// );\r\n\t// urdfRoot.rotation.set(\r\n\t// \tikRoot.getDoFValue( DOF.EX ),\r\n\t// \tikRoot.getDoFValue( DOF.EY ),\r\n\t// \tikRoot.getDoFValue( DOF.EZ ),\r\n\t// );\r\n\r\n\tikRoot.traverse( c => {\r\n\r\n\t\tif ( c.isJoint ) {\r\n\r\n\t\t\tconst ikJoint = c;\r\n\t\t\tconst urdfJoint = urdfRoot.joints[ c.name ];\r\n\t\t\tif ( urdfJoint ) {\r\n\r\n\t\t\t\tif ( urdfJoint.jointType === 'prismatic' ) {\r\n\r\n\t\t\t\t\turdfJoint.setJointValue( ikJoint.getDoFValue( DOF.Z ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\turdfJoint.setJointValue( ikJoint.getDoFValue( DOF.EZ ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}