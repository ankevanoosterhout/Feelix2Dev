{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Transform, util } from '@tensorflow/tfjs-core';\nexport function transform(args) {\n  const {\n    inputs,\n    attrs,\n    backend\n  } = args;\n  const {\n    image,\n    transforms\n  } = inputs;\n  const {\n    interpolation,\n    fillMode,\n    fillValue,\n    outputShape\n  } = attrs;\n  const [batch, imageHeight, imageWidth, numChannels] = image.shape;\n  const [outHeight, outWidth] = outputShape != null ? outputShape : [imageHeight, imageWidth];\n  const outShape = [batch, outHeight, outWidth, numChannels];\n  const inStrides = util.computeStrides(image.shape);\n  const batchInStride = inStrides[0];\n  const rowInStride = inStrides[1];\n  const colInStride = inStrides[2];\n  const outStrides = util.computeStrides(outShape);\n  const batchOutStride = outStrides[0];\n  const rowOutStride = outStrides[1];\n  const colOutStride = outStrides[2];\n  const outVals = util.getTypedArrayFromDType(image.dtype, util.sizeFromShape(outShape));\n  outVals.fill(fillValue);\n  const imageVals = backend.data.get(image.dataId).values;\n  const transformVals = backend.data.get(transforms.dataId).values; // Ref TF implementation:\n  // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/image/image_ops.h\n\n  for (let b = 0; b < batch; ++b) {\n    const transform = transforms.shape[0] === 1 ? transformVals : transformVals.subarray(b * 8, b * 8 + 8);\n\n    for (let outY = 0; outY < outHeight; ++outY) {\n      for (let outX = 0; outX < outWidth; ++outX) {\n        for (let channel = 0; channel < numChannels; ++channel) {\n          let val;\n          const projection = transform[6] * outX + transform[7] * outY + 1;\n\n          if (projection === 0) {\n            // Return the fill value for infinite coordinates,\n            // which are outside the input image\n            continue;\n          }\n\n          const inX = (transform[0] * outX + transform[1] * outY + transform[2]) / projection;\n          const inY = (transform[3] * outX + transform[4] * outY + transform[5]) / projection;\n          const x = mapCoord(inX, imageWidth, fillMode);\n          const y = mapCoord(inY, imageHeight, fillMode);\n\n          switch (interpolation) {\n            case 'nearest':\n              val = nearestInterpolation(imageVals, imageHeight, imageWidth, batchInStride, rowInStride, colInStride, b, y, x, channel, fillValue);\n              break;\n\n            case 'bilinear':\n              val = bilinearInterpolation(imageVals, imageHeight, imageWidth, batchInStride, rowInStride, colInStride, b, y, x, channel, fillValue);\n              break;\n\n            default:\n              throw new Error(`Error in Transform: Expect 'nearest' or ` + `'bilinear', but got ${interpolation}`);\n          }\n\n          const ind = b * batchOutStride + outY * rowOutStride + outX * colOutStride + channel;\n          outVals[ind] = val;\n        }\n      }\n    }\n\n    return backend.makeTensorInfo(outShape, image.dtype, outVals);\n  }\n\n  const dataId = backend.write(outVals, outShape, image.dtype);\n  return {\n    dataId,\n    shape: image.shape,\n    dtype: image.dtype\n  };\n}\nexport const transformConfig = {\n  kernelName: Transform,\n  backendName: 'cpu',\n  kernelFunc: transform\n};\n\nfunction mapCoord(outCoord, len, mode) {\n  switch (mode) {\n    case 'reflect':\n      return mapCoordReflect(outCoord, len);\n\n    case 'wrap':\n      return mapCoordWrap(outCoord, len);\n\n    case 'nearest':\n      return mapCoordNearest(outCoord, len);\n\n    case 'constant':\n    default:\n      return mapCoordConstant(outCoord, len);\n  }\n}\n\nfunction mapCoordReflect(outCoord, len) {\n  // Reflect [abcd] to [dcba|abcd|dcba].\n  let inCoord = outCoord;\n\n  if (inCoord < 0) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz2 = 2 * len;\n\n      if (inCoord < sz2) {\n        inCoord = sz2 * Math.trunc(-inCoord / sz2) + inCoord;\n      }\n\n      inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1;\n    }\n  } else if (inCoord > len - 1) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz2 = 2 * len;\n      inCoord -= sz2 * Math.trunc(inCoord / sz2);\n\n      if (inCoord >= len) {\n        inCoord = sz2 - inCoord - 1;\n      }\n    }\n  } // clamp is necessary because when outCoord = 3.5 and len = 4,\n  // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n\n\n  return util.clamp(0, inCoord, len - 1);\n}\n\nfunction mapCoordWrap(outCoord, len) {\n  // Wrap [abcd] to [abcd|abcd|abcd].\n  let inCoord = outCoord;\n\n  if (inCoord < 0) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz = len - 1;\n      inCoord += len * (Math.trunc(-inCoord / sz) + 1);\n    }\n  } else if (inCoord > len - 1) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz = len - 1;\n      inCoord -= len * Math.trunc(inCoord / sz);\n    }\n  } // clamp is necessary because when outCoord = -0.5 and len = 4,\n  // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n\n\n  return util.clamp(0, inCoord, len - 1);\n}\n\nfunction mapCoordConstant(outCoord, len) {\n  return outCoord;\n}\n\nfunction mapCoordNearest(outCoord, len) {\n  return util.clamp(0, outCoord, len - 1);\n}\n\nfunction readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n  const ind = batch * batchStride + y * rowStride + x * colStride + channel;\n\n  if (0 <= y && y < imageHeight && 0 <= x && x < imageWidth) {\n    return imageVals[ind];\n  } else {\n    return fillValue;\n  }\n}\n\nfunction nearestInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n  const $y = Math.round(y);\n  const $x = Math.round(x);\n  return readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, $y, $x, channel, fillValue);\n}\n\nfunction bilinearInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n  const yFloor = Math.floor(y);\n  const xFloor = Math.floor(x);\n  const yCeil = yFloor + 1;\n  const xCeil = xFloor + 1; // f(x, yFloor) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yFloor)\n  //               + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yFloor)\n\n  const valueYFloor = (xCeil - x) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xFloor, channel, fillValue) + (x - xFloor) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xCeil, channel, fillValue); // f(x, yCeil) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yCeil)\n  //             + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yCeil)\n\n  const valueYCeil = (xCeil - x) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xFloor, channel, fillValue) + (x - xFloor) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xCeil, channel, fillValue); // f(x, y) = (yCeil - y) / (yCeil - yFloor) * f(x, yFloor)\n  //         + (y - yFloor) / (yCeil - yFloor) * f(x, yCeil)\n\n  return (yCeil - y) * valueYFloor + (y - yFloor) * valueYCeil;\n}","map":{"version":3,"names":["Transform","util","transform","args","inputs","attrs","backend","image","transforms","interpolation","fillMode","fillValue","outputShape","batch","imageHeight","imageWidth","numChannels","shape","outHeight","outWidth","outShape","inStrides","computeStrides","batchInStride","rowInStride","colInStride","outStrides","batchOutStride","rowOutStride","colOutStride","outVals","getTypedArrayFromDType","dtype","sizeFromShape","fill","imageVals","data","get","dataId","values","transformVals","b","subarray","outY","outX","channel","val","projection","inX","inY","x","mapCoord","y","nearestInterpolation","bilinearInterpolation","Error","ind","makeTensorInfo","write","transformConfig","kernelName","backendName","kernelFunc","outCoord","len","mode","mapCoordReflect","mapCoordWrap","mapCoordNearest","mapCoordConstant","inCoord","sz2","Math","trunc","clamp","sz","readWithFillValue","batchStride","rowStride","colStride","$y","round","$x","yFloor","floor","xFloor","yCeil","xCeil","valueYFloor","valueYCeil"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Transform.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Transform, util } from '@tensorflow/tfjs-core';\nexport function transform(args) {\n    const { inputs, attrs, backend } = args;\n    const { image, transforms } = inputs;\n    const { interpolation, fillMode, fillValue, outputShape } = attrs;\n    const [batch, imageHeight, imageWidth, numChannels] = image.shape;\n    const [outHeight, outWidth] = outputShape != null ? outputShape : [imageHeight, imageWidth];\n    const outShape = [batch, outHeight, outWidth, numChannels];\n    const inStrides = util.computeStrides(image.shape);\n    const batchInStride = inStrides[0];\n    const rowInStride = inStrides[1];\n    const colInStride = inStrides[2];\n    const outStrides = util.computeStrides(outShape);\n    const batchOutStride = outStrides[0];\n    const rowOutStride = outStrides[1];\n    const colOutStride = outStrides[2];\n    const outVals = util.getTypedArrayFromDType(image.dtype, util.sizeFromShape(outShape));\n    outVals.fill(fillValue);\n    const imageVals = backend.data.get(image.dataId).values;\n    const transformVals = backend.data.get(transforms.dataId).values;\n    // Ref TF implementation:\n    // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/image/image_ops.h\n    for (let b = 0; b < batch; ++b) {\n        const transform = transforms.shape[0] === 1 ?\n            transformVals :\n            transformVals.subarray(b * 8, b * 8 + 8);\n        for (let outY = 0; outY < outHeight; ++outY) {\n            for (let outX = 0; outX < outWidth; ++outX) {\n                for (let channel = 0; channel < numChannels; ++channel) {\n                    let val;\n                    const projection = transform[6] * outX + transform[7] * outY + 1;\n                    if (projection === 0) {\n                        // Return the fill value for infinite coordinates,\n                        // which are outside the input image\n                        continue;\n                    }\n                    const inX = (transform[0] * outX + transform[1] * outY + transform[2]) /\n                        projection;\n                    const inY = (transform[3] * outX + transform[4] * outY + transform[5]) /\n                        projection;\n                    const x = mapCoord(inX, imageWidth, fillMode);\n                    const y = mapCoord(inY, imageHeight, fillMode);\n                    switch (interpolation) {\n                        case 'nearest':\n                            val = nearestInterpolation(imageVals, imageHeight, imageWidth, batchInStride, rowInStride, colInStride, b, y, x, channel, fillValue);\n                            break;\n                        case 'bilinear':\n                            val = bilinearInterpolation(imageVals, imageHeight, imageWidth, batchInStride, rowInStride, colInStride, b, y, x, channel, fillValue);\n                            break;\n                        default:\n                            throw new Error(`Error in Transform: Expect 'nearest' or ` +\n                                `'bilinear', but got ${interpolation}`);\n                    }\n                    const ind = b * batchOutStride + outY * rowOutStride +\n                        outX * colOutStride + channel;\n                    outVals[ind] = val;\n                }\n            }\n        }\n        return backend.makeTensorInfo(outShape, image.dtype, outVals);\n    }\n    const dataId = backend.write(outVals, outShape, image.dtype);\n    return { dataId, shape: image.shape, dtype: image.dtype };\n}\nexport const transformConfig = {\n    kernelName: Transform,\n    backendName: 'cpu',\n    kernelFunc: transform\n};\nfunction mapCoord(outCoord, len, mode) {\n    switch (mode) {\n        case 'reflect':\n            return mapCoordReflect(outCoord, len);\n        case 'wrap':\n            return mapCoordWrap(outCoord, len);\n        case 'nearest':\n            return mapCoordNearest(outCoord, len);\n        case 'constant':\n        default:\n            return mapCoordConstant(outCoord, len);\n    }\n}\nfunction mapCoordReflect(outCoord, len) {\n    // Reflect [abcd] to [dcba|abcd|dcba].\n    let inCoord = outCoord;\n    if (inCoord < 0) {\n        if (len <= 1) {\n            inCoord = 0;\n        }\n        else {\n            const sz2 = 2 * len;\n            if (inCoord < sz2) {\n                inCoord = sz2 * Math.trunc(-inCoord / sz2) + inCoord;\n            }\n            inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1;\n        }\n    }\n    else if (inCoord > len - 1) {\n        if (len <= 1) {\n            inCoord = 0;\n        }\n        else {\n            const sz2 = 2 * len;\n            inCoord -= sz2 * Math.trunc(inCoord / sz2);\n            if (inCoord >= len) {\n                inCoord = sz2 - inCoord - 1;\n            }\n        }\n    }\n    // clamp is necessary because when outCoord = 3.5 and len = 4,\n    // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n    return util.clamp(0, inCoord, len - 1);\n}\nfunction mapCoordWrap(outCoord, len) {\n    // Wrap [abcd] to [abcd|abcd|abcd].\n    let inCoord = outCoord;\n    if (inCoord < 0) {\n        if (len <= 1) {\n            inCoord = 0;\n        }\n        else {\n            const sz = len - 1;\n            inCoord += len * (Math.trunc(-inCoord / sz) + 1);\n        }\n    }\n    else if (inCoord > len - 1) {\n        if (len <= 1) {\n            inCoord = 0;\n        }\n        else {\n            const sz = len - 1;\n            inCoord -= len * Math.trunc(inCoord / sz);\n        }\n    }\n    // clamp is necessary because when outCoord = -0.5 and len = 4,\n    // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n    return util.clamp(0, inCoord, len - 1);\n}\nfunction mapCoordConstant(outCoord, len) {\n    return outCoord;\n}\nfunction mapCoordNearest(outCoord, len) {\n    return util.clamp(0, outCoord, len - 1);\n}\nfunction readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n    const ind = batch * batchStride + y * rowStride + x * colStride + channel;\n    if (0 <= y && y < imageHeight && 0 <= x && x < imageWidth) {\n        return imageVals[ind];\n    }\n    else {\n        return fillValue;\n    }\n}\nfunction nearestInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n    const $y = Math.round(y);\n    const $x = Math.round(x);\n    return readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, $y, $x, channel, fillValue);\n}\nfunction bilinearInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n    const yFloor = Math.floor(y);\n    const xFloor = Math.floor(x);\n    const yCeil = yFloor + 1;\n    const xCeil = xFloor + 1;\n    // f(x, yFloor) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yFloor)\n    //               + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yFloor)\n    const valueYFloor = (xCeil - x) *\n        readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xFloor, channel, fillValue) +\n        (x - xFloor) *\n            readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xCeil, channel, fillValue);\n    // f(x, yCeil) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yCeil)\n    //             + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yCeil)\n    const valueYCeil = (xCeil - x) *\n        readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xFloor, channel, fillValue) +\n        (x - xFloor) *\n            readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xCeil, channel, fillValue);\n    // f(x, y) = (yCeil - y) / (yCeil - yFloor) * f(x, yFloor)\n    //         + (y - yFloor) / (yCeil - yFloor) * f(x, yCeil)\n    return (yCeil - y) * valueYFloor + (y - yFloor) * valueYCeil;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}