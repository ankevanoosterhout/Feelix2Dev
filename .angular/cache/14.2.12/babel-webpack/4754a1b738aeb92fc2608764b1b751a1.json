{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * LruCache: A mapping from the String to T. If the number of the entries is\n * exceeding the `maxEntries`, the LruCache will delete the least recently\n * used entry.\n */\nexport class LruCache {\n  constructor(maxEntries) {\n    this.maxEntries = maxEntries || 100;\n    this.cache = new Map();\n  }\n  /**\n   * Get the entry for the key and mark it as used recently.\n   */\n\n\n  get(key) {\n    let entry;\n\n    if (this.cache.has(key)) {\n      entry = this.cache.get(key);\n      this.cache.delete(key);\n      this.cache.set(key, entry);\n    }\n\n    return entry;\n  }\n  /**\n   * Put the entry into the cache. If the key already existed, mark the key as\n   * used recently.\n   */\n\n\n  put(key, value) {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size >= this.maxEntries) {\n      const keyToDelete = this.cache.keys().next().value;\n      this.cache.delete(keyToDelete);\n    }\n\n    this.cache.set(key, value);\n  }\n  /**\n   * Get the MaxEntries of the cache.\n   */\n\n\n  getMaxEntries() {\n    return this.maxEntries;\n  }\n  /**\n   * Set the MaxEntries of the cache. If the maxEntries is decreased, reduce\n   * entries in the cache.\n   */\n\n\n  setMaxEntries(maxEntries) {\n    if (maxEntries < 0) {\n      throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${maxEntries}.`);\n    }\n\n    if (this.maxEntries > maxEntries) {\n      for (let i = 0; i < this.maxEntries - maxEntries; i++) {\n        const keyToDelete = this.cache.keys().next().value;\n        this.cache.delete(keyToDelete);\n      }\n    }\n\n    this.maxEntries = maxEntries;\n  }\n\n}","map":{"version":3,"names":["LruCache","constructor","maxEntries","cache","Map","get","key","entry","has","delete","set","put","value","size","keyToDelete","keys","next","getMaxEntries","setMaxEntries","Error","i"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-layers/dist/utils/executor_utils.js"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * LruCache: A mapping from the String to T. If the number of the entries is\n * exceeding the `maxEntries`, the LruCache will delete the least recently\n * used entry.\n */\nexport class LruCache {\n    constructor(maxEntries) {\n        this.maxEntries = maxEntries || 100;\n        this.cache = new Map();\n    }\n    /**\n     * Get the entry for the key and mark it as used recently.\n     */\n    get(key) {\n        let entry;\n        if (this.cache.has(key)) {\n            entry = this.cache.get(key);\n            this.cache.delete(key);\n            this.cache.set(key, entry);\n        }\n        return entry;\n    }\n    /**\n     * Put the entry into the cache. If the key already existed, mark the key as\n     * used recently.\n     */\n    put(key, value) {\n        if (this.cache.has(key)) {\n            this.cache.delete(key);\n        }\n        else if (this.cache.size >= this.maxEntries) {\n            const keyToDelete = this.cache.keys().next().value;\n            this.cache.delete(keyToDelete);\n        }\n        this.cache.set(key, value);\n    }\n    /**\n     * Get the MaxEntries of the cache.\n     */\n    getMaxEntries() {\n        return this.maxEntries;\n    }\n    /**\n     * Set the MaxEntries of the cache. If the maxEntries is decreased, reduce\n     * entries in the cache.\n     */\n    setMaxEntries(maxEntries) {\n        if (maxEntries < 0) {\n            throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${maxEntries}.`);\n        }\n        if (this.maxEntries > maxEntries) {\n            for (let i = 0; i < this.maxEntries - maxEntries; i++) {\n                const keyToDelete = this.cache.keys().next().value;\n                this.cache.delete(keyToDelete);\n            }\n        }\n        this.maxEntries = maxEntries;\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,QAAN,CAAe;EAClBC,WAAW,CAACC,UAAD,EAAa;IACpB,KAAKA,UAAL,GAAkBA,UAAU,IAAI,GAAhC;IACA,KAAKC,KAAL,GAAa,IAAIC,GAAJ,EAAb;EACH;EACD;AACJ;AACA;;;EACIC,GAAG,CAACC,GAAD,EAAM;IACL,IAAIC,KAAJ;;IACA,IAAI,KAAKJ,KAAL,CAAWK,GAAX,CAAeF,GAAf,CAAJ,EAAyB;MACrBC,KAAK,GAAG,KAAKJ,KAAL,CAAWE,GAAX,CAAeC,GAAf,CAAR;MACA,KAAKH,KAAL,CAAWM,MAAX,CAAkBH,GAAlB;MACA,KAAKH,KAAL,CAAWO,GAAX,CAAeJ,GAAf,EAAoBC,KAApB;IACH;;IACD,OAAOA,KAAP;EACH;EACD;AACJ;AACA;AACA;;;EACII,GAAG,CAACL,GAAD,EAAMM,KAAN,EAAa;IACZ,IAAI,KAAKT,KAAL,CAAWK,GAAX,CAAeF,GAAf,CAAJ,EAAyB;MACrB,KAAKH,KAAL,CAAWM,MAAX,CAAkBH,GAAlB;IACH,CAFD,MAGK,IAAI,KAAKH,KAAL,CAAWU,IAAX,IAAmB,KAAKX,UAA5B,EAAwC;MACzC,MAAMY,WAAW,GAAG,KAAKX,KAAL,CAAWY,IAAX,GAAkBC,IAAlB,GAAyBJ,KAA7C;MACA,KAAKT,KAAL,CAAWM,MAAX,CAAkBK,WAAlB;IACH;;IACD,KAAKX,KAAL,CAAWO,GAAX,CAAeJ,GAAf,EAAoBM,KAApB;EACH;EACD;AACJ;AACA;;;EACIK,aAAa,GAAG;IACZ,OAAO,KAAKf,UAAZ;EACH;EACD;AACJ;AACA;AACA;;;EACIgB,aAAa,CAAChB,UAAD,EAAa;IACtB,IAAIA,UAAU,GAAG,CAAjB,EAAoB;MAChB,MAAM,IAAIiB,KAAJ,CAAW,4DAA2DjB,UAAW,GAAjF,CAAN;IACH;;IACD,IAAI,KAAKA,UAAL,GAAkBA,UAAtB,EAAkC;MAC9B,KAAK,IAAIkB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKlB,UAAL,GAAkBA,UAAtC,EAAkDkB,CAAC,EAAnD,EAAuD;QACnD,MAAMN,WAAW,GAAG,KAAKX,KAAL,CAAWY,IAAX,GAAkBC,IAAlB,GAAyBJ,KAA7C;QACA,KAAKT,KAAL,CAAWM,MAAX,CAAkBK,WAAlB;MACH;IACJ;;IACD,KAAKZ,UAAL,GAAkBA,UAAlB;EACH;;AApDiB"},"metadata":{},"sourceType":"module"}