{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * Math utility functions.\n *\n * This file contains some frequently used math function that operates on\n * number[] or Float32Array and return a number. Many of these functions are\n * not-so-thick wrappers around TF.js Core functions. But they offer the\n * convenience of\n * 1) not having to convert the inputs into Tensors,\n * 2) not having to convert the returned Tensors to numbers.\n */\nimport { ValueError } from '../errors';\n/**\n * Determine if a number is an integer.\n */\n\nexport function isInteger(x) {\n  return x === parseInt(x.toString(), 10);\n}\n/**\n * Calculate the product of an array of numbers.\n * @param array The array to calculate the product over.\n * @param begin Beginning index, inclusive.\n * @param end Ending index, exclusive.\n * @return The product.\n */\n\nexport function arrayProd(array, begin, end) {\n  if (begin == null) {\n    begin = 0;\n  }\n\n  if (end == null) {\n    end = array.length;\n  }\n\n  let prod = 1;\n\n  for (let i = begin; i < end; ++i) {\n    prod *= array[i];\n  }\n\n  return prod;\n}\n/**\n * Compute minimum value.\n * @param array\n * @return minimum value.\n */\n\nexport function min(array) {\n  // same behavior as tf.min()\n  if (array.length === 0) {\n    return Number.NaN;\n  }\n\n  let min = Number.POSITIVE_INFINITY;\n\n  for (let i = 0; i < array.length; i++) {\n    const value = array[i];\n\n    if (value < min) {\n      min = value;\n    }\n  }\n\n  return min;\n}\n/**\n * Compute maximum value.\n * @param array\n * @return maximum value\n */\n\nexport function max(array) {\n  // same behavior as tf.max()\n  if (array.length === 0) {\n    return Number.NaN;\n  }\n\n  let max = Number.NEGATIVE_INFINITY;\n\n  for (let i = 0; i < array.length; i++) {\n    const value = array[i];\n\n    if (value > max) {\n      max = value;\n    }\n  }\n\n  return max;\n}\n/**\n * Compute sum of array.\n * @param array\n * @return The sum.\n */\n\nexport function sum(array) {\n  let sum = 0;\n\n  for (let i = 0; i < array.length; i++) {\n    const value = array[i];\n    sum += value;\n  }\n\n  return sum;\n}\n/**\n * Compute mean of array.\n * @param array\n * @return The mean.\n */\n\nexport function mean(array) {\n  return sum(array) / array.length;\n}\n/**\n * Compute variance of array.\n * @param array\n * @return The variance.\n */\n\nexport function variance(array) {\n  const meanValue = mean(array);\n  const demeaned = array.map(value => value - meanValue);\n  let sumSquare = 0;\n\n  for (let i = 0; i < demeaned.length; i++) {\n    const value = demeaned[i];\n    sumSquare += value * value;\n  }\n\n  return sumSquare / array.length;\n}\n/**\n * Compute median of array.\n * @param array\n * @return The median value.\n */\n\nexport function median(array) {\n  const arraySorted = array.slice().sort((a, b) => a - b);\n  const lowIdx = Math.floor((arraySorted.length - 1) / 2);\n  const highIdx = Math.ceil((arraySorted.length - 1) / 2);\n\n  if (lowIdx === highIdx) {\n    return arraySorted[lowIdx];\n  }\n\n  return (arraySorted[lowIdx] + arraySorted[highIdx]) / 2;\n}\n/**\n * Generate an array of integers in [begin, end).\n * @param begin Beginning integer, inclusive.\n * @param end Ending integer, exclusive.\n * @returns Range array.\n * @throws ValueError, iff `end` < `begin`.\n */\n\nexport function range(begin, end) {\n  if (end < begin) {\n    throw new ValueError(`end (${end}) < begin (${begin}) is forbidden.`);\n  }\n\n  const out = [];\n\n  for (let i = begin; i < end; ++i) {\n    out.push(i);\n  }\n\n  return out;\n}","map":{"version":3,"names":["ValueError","isInteger","x","parseInt","toString","arrayProd","array","begin","end","length","prod","i","min","Number","NaN","POSITIVE_INFINITY","value","max","NEGATIVE_INFINITY","sum","mean","variance","meanValue","demeaned","map","sumSquare","median","arraySorted","slice","sort","a","b","lowIdx","Math","floor","highIdx","ceil","range","out","push"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-layers/dist/utils/math_utils.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Math utility functions.\n *\n * This file contains some frequently used math function that operates on\n * number[] or Float32Array and return a number. Many of these functions are\n * not-so-thick wrappers around TF.js Core functions. But they offer the\n * convenience of\n * 1) not having to convert the inputs into Tensors,\n * 2) not having to convert the returned Tensors to numbers.\n */\nimport { ValueError } from '../errors';\n/**\n * Determine if a number is an integer.\n */\nexport function isInteger(x) {\n    return x === parseInt(x.toString(), 10);\n}\n/**\n * Calculate the product of an array of numbers.\n * @param array The array to calculate the product over.\n * @param begin Beginning index, inclusive.\n * @param end Ending index, exclusive.\n * @return The product.\n */\nexport function arrayProd(array, begin, end) {\n    if (begin == null) {\n        begin = 0;\n    }\n    if (end == null) {\n        end = array.length;\n    }\n    let prod = 1;\n    for (let i = begin; i < end; ++i) {\n        prod *= array[i];\n    }\n    return prod;\n}\n/**\n * Compute minimum value.\n * @param array\n * @return minimum value.\n */\nexport function min(array) {\n    // same behavior as tf.min()\n    if (array.length === 0) {\n        return Number.NaN;\n    }\n    let min = Number.POSITIVE_INFINITY;\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i];\n        if (value < min) {\n            min = value;\n        }\n    }\n    return min;\n}\n/**\n * Compute maximum value.\n * @param array\n * @return maximum value\n */\nexport function max(array) {\n    // same behavior as tf.max()\n    if (array.length === 0) {\n        return Number.NaN;\n    }\n    let max = Number.NEGATIVE_INFINITY;\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i];\n        if (value > max) {\n            max = value;\n        }\n    }\n    return max;\n}\n/**\n * Compute sum of array.\n * @param array\n * @return The sum.\n */\nexport function sum(array) {\n    let sum = 0;\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i];\n        sum += value;\n    }\n    return sum;\n}\n/**\n * Compute mean of array.\n * @param array\n * @return The mean.\n */\nexport function mean(array) {\n    return sum(array) / array.length;\n}\n/**\n * Compute variance of array.\n * @param array\n * @return The variance.\n */\nexport function variance(array) {\n    const meanValue = mean(array);\n    const demeaned = array.map((value) => value - meanValue);\n    let sumSquare = 0;\n    for (let i = 0; i < demeaned.length; i++) {\n        const value = demeaned[i];\n        sumSquare += value * value;\n    }\n    return sumSquare / array.length;\n}\n/**\n * Compute median of array.\n * @param array\n * @return The median value.\n */\nexport function median(array) {\n    const arraySorted = array.slice().sort((a, b) => a - b);\n    const lowIdx = Math.floor((arraySorted.length - 1) / 2);\n    const highIdx = Math.ceil((arraySorted.length - 1) / 2);\n    if (lowIdx === highIdx) {\n        return arraySorted[lowIdx];\n    }\n    return (arraySorted[lowIdx] + arraySorted[highIdx]) / 2;\n}\n/**\n * Generate an array of integers in [begin, end).\n * @param begin Beginning integer, inclusive.\n * @param end Ending integer, exclusive.\n * @returns Range array.\n * @throws ValueError, iff `end` < `begin`.\n */\nexport function range(begin, end) {\n    if (end < begin) {\n        throw new ValueError(`end (${end}) < begin (${begin}) is forbidden.`);\n    }\n    const out = [];\n    for (let i = begin; i < end; ++i) {\n        out.push(i);\n    }\n    return out;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}