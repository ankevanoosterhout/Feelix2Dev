{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeBilinear, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function resizeBilinear(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    images\n  } = inputs;\n  const {\n    alignCorners,\n    halfPixelCenters,\n    size\n  } = attrs;\n  assertNotComplex(images, 'resizeBilinear');\n  const imagesStrides = util.computeStrides(images.shape);\n  const [newHeight, newWidth] = size;\n  const [batch, oldHeight, oldWidth, numChannels] = images.shape;\n  const xValues = backend.data.get(images.dataId).values;\n  const result = new Float32Array(util.sizeFromShape([batch, newHeight, newWidth, numChannels]));\n  const effectiveInputSize = [alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight, alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth];\n  const effectiveOutputSize = [alignCorners && newHeight > 1 ? newHeight - 1 : newHeight, alignCorners && newWidth > 1 ? newWidth - 1 : newWidth];\n  let outputIdx = 0;\n  const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n  const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n\n  for (let b = 0; b < batch; b++) {\n    for (let r = 0; r < newHeight; r++) {\n      let sourceFracRow;\n\n      if (halfPixelCenters) {\n        sourceFracRow = effectiveRowSizeRatio * (r + 0.5) - 0.5;\n      } else {\n        sourceFracRow = effectiveRowSizeRatio * r;\n      }\n\n      const sourceRowFloor = Math.max(0, Math.floor(sourceFracRow));\n      const rowFrac = sourceFracRow - sourceRowFloor;\n      const sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));\n      const topRowOffset = b * imagesStrides[0] + sourceRowFloor * imagesStrides[1];\n      const botRowOffset = b * imagesStrides[0] + sourceRowCeil * imagesStrides[1];\n\n      for (let c = 0; c < newWidth; c++) {\n        let sourceFracCol;\n\n        if (halfPixelCenters) {\n          sourceFracCol = effectiveColSizeRatio * (c + 0.5) - 0.5;\n        } else {\n          sourceFracCol = effectiveColSizeRatio * c;\n        }\n\n        const sourceColFloor = Math.max(0, Math.floor(sourceFracCol));\n        const colFrac = sourceFracCol - sourceColFloor;\n        const sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));\n        const topLeftOffest = topRowOffset + sourceColFloor * imagesStrides[2];\n        const botLeftOffset = botRowOffset + sourceColFloor * imagesStrides[2];\n        const topRightOffset = topRowOffset + sourceColCeil * imagesStrides[2];\n        const botRightOffest = botRowOffset + sourceColCeil * imagesStrides[2];\n\n        for (let d = 0; d < numChannels; d++) {\n          // Begin shader.\n          // Compute the fractional index of the source.\n          const topLeft = xValues[topLeftOffest + d];\n          const bottomLeft = xValues[botLeftOffset + d];\n          const topRight = xValues[topRightOffset + d];\n          const bottomRight = xValues[botRightOffest + d];\n          const top = topLeft + (topRight - topLeft) * colFrac;\n          const bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;\n          const newValue = top + (bottom - top) * rowFrac;\n          result[outputIdx++] = newValue;\n        }\n      }\n    }\n  }\n\n  return backend.makeTensorInfo([batch, newHeight, newWidth, numChannels], 'float32', result);\n}\nexport const resizeBilinearConfig = {\n  kernelName: ResizeBilinear,\n  backendName: 'cpu',\n  kernelFunc: resizeBilinear\n};","map":{"version":3,"names":["ResizeBilinear","util","assertNotComplex","resizeBilinear","args","inputs","backend","attrs","images","alignCorners","halfPixelCenters","size","imagesStrides","computeStrides","shape","newHeight","newWidth","batch","oldHeight","oldWidth","numChannels","xValues","data","get","dataId","values","result","Float32Array","sizeFromShape","effectiveInputSize","effectiveOutputSize","outputIdx","effectiveRowSizeRatio","effectiveColSizeRatio","b","r","sourceFracRow","sourceRowFloor","Math","max","floor","rowFrac","sourceRowCeil","min","ceil","topRowOffset","botRowOffset","c","sourceFracCol","sourceColFloor","colFrac","sourceColCeil","topLeftOffest","botLeftOffset","topRightOffset","botRightOffest","d","topLeft","bottomLeft","topRight","bottomRight","top","bottom","newValue","makeTensorInfo","resizeBilinearConfig","kernelName","backendName","kernelFunc"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ResizeBilinear.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeBilinear, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function resizeBilinear(args) {\n    const { inputs, backend, attrs } = args;\n    const { images } = inputs;\n    const { alignCorners, halfPixelCenters, size } = attrs;\n    assertNotComplex(images, 'resizeBilinear');\n    const imagesStrides = util.computeStrides(images.shape);\n    const [newHeight, newWidth] = size;\n    const [batch, oldHeight, oldWidth, numChannels] = images.shape;\n    const xValues = backend.data.get(images.dataId).values;\n    const result = new Float32Array(util.sizeFromShape([batch, newHeight, newWidth, numChannels]));\n    const effectiveInputSize = [\n        (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n        (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n    ];\n    const effectiveOutputSize = [\n        (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n        (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n    ];\n    let outputIdx = 0;\n    const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n    const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n    for (let b = 0; b < batch; b++) {\n        for (let r = 0; r < newHeight; r++) {\n            let sourceFracRow;\n            if (halfPixelCenters) {\n                sourceFracRow = effectiveRowSizeRatio * (r + 0.5) - 0.5;\n            }\n            else {\n                sourceFracRow = effectiveRowSizeRatio * r;\n            }\n            const sourceRowFloor = Math.max(0, Math.floor(sourceFracRow));\n            const rowFrac = sourceFracRow - sourceRowFloor;\n            const sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));\n            const topRowOffset = b * imagesStrides[0] + sourceRowFloor * imagesStrides[1];\n            const botRowOffset = b * imagesStrides[0] + sourceRowCeil * imagesStrides[1];\n            for (let c = 0; c < newWidth; c++) {\n                let sourceFracCol;\n                if (halfPixelCenters) {\n                    sourceFracCol = effectiveColSizeRatio * (c + 0.5) - 0.5;\n                }\n                else {\n                    sourceFracCol = effectiveColSizeRatio * c;\n                }\n                const sourceColFloor = Math.max(0, Math.floor(sourceFracCol));\n                const colFrac = sourceFracCol - sourceColFloor;\n                const sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));\n                const topLeftOffest = topRowOffset + sourceColFloor * imagesStrides[2];\n                const botLeftOffset = botRowOffset + sourceColFloor * imagesStrides[2];\n                const topRightOffset = topRowOffset + sourceColCeil * imagesStrides[2];\n                const botRightOffest = botRowOffset + sourceColCeil * imagesStrides[2];\n                for (let d = 0; d < numChannels; d++) {\n                    // Begin shader.\n                    // Compute the fractional index of the source.\n                    const topLeft = xValues[topLeftOffest + d];\n                    const bottomLeft = xValues[botLeftOffset + d];\n                    const topRight = xValues[topRightOffset + d];\n                    const bottomRight = xValues[botRightOffest + d];\n                    const top = topLeft + (topRight - topLeft) * colFrac;\n                    const bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;\n                    const newValue = top + (bottom - top) * rowFrac;\n                    result[outputIdx++] = newValue;\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo([batch, newHeight, newWidth, numChannels], 'float32', result);\n}\nexport const resizeBilinearConfig = {\n    kernelName: ResizeBilinear,\n    backendName: 'cpu',\n    kernelFunc: resizeBilinear\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}