{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/* Original source: keras/callbacks.py */\nimport { add, div, keep, mul, nextFrame, tidy, util } from '@tensorflow/tfjs-core';\nimport { ValueError } from './errors';\nimport { resolveScalarsInLogs } from './logs';\nimport * as generic_utils from './utils/generic_utils';\n/** Verbosity logging level when fitting a model. */\n\nexport var ModelLoggingVerbosity;\n\n(function (ModelLoggingVerbosity) {\n  ModelLoggingVerbosity[ModelLoggingVerbosity[\"SILENT\"] = 0] = \"SILENT\";\n  ModelLoggingVerbosity[ModelLoggingVerbosity[\"VERBOSE\"] = 1] = \"VERBOSE\";\n})(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));\n/** How often to yield to the main thread when training (in ms). */\n\n\nexport const DEFAULT_YIELD_EVERY_MS = 125;\n/**\n * Abstract base class used to build new callbacks.\n *\n * The `logs` dictionary that callback methods take as argument will contain\n * keys for quantities relevant to the current batch or epoch.\n *\n * Currently, the `.fit()` method of the `Sequential` model class\n * will include the following quantities in the `logs` that\n * it passes to its callbacks:\n *\n * onEpochEnd: Logs include `acc` and `loss`, and optionally include `valLoss`\n *   (if validation is enabled in `fit`), and `valAcc` (if validation and\n *   accuracy monitoring are enabled).\n * onBatchBegin: Logs include `size`, the number of samples in the current\n *   batch.\n * onBatchEnd: Logs include `loss`, and optionally `acc` (if accuracy monitoring\n *   is enabled).\n */\n\nexport class BaseCallback {\n  constructor() {\n    // TODO(michaelterry): This type is a best guess.\n    this.validationData = null;\n  }\n\n  setParams(params) {\n    this.params = params;\n  }\n\n  onEpochBegin(epoch, logs) {\n    return _asyncToGenerator(function* () {})();\n  }\n\n  onEpochEnd(epoch, logs) {\n    return _asyncToGenerator(function* () {})();\n  }\n\n  onBatchBegin(batch, logs) {\n    return _asyncToGenerator(function* () {})();\n  }\n\n  onBatchEnd(batch, logs) {\n    return _asyncToGenerator(function* () {})();\n  }\n\n  onTrainBegin(logs) {\n    return _asyncToGenerator(function* () {})();\n  }\n\n  onTrainEnd(logs) {\n    return _asyncToGenerator(function* () {})();\n  } // LayersModel needs to call Callback.setModel(), but cannot actually depend\n  // on Callback because that creates a cyclic dependency.  Providing this no-op\n  // method on BaseCallback breaks the cycle: this way LayersModel can depend on\n  // BaseCallback but not on Callback.  The argument is typed as `Container`\n  // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback\n  // overrides this method and enforces that the argument is really a\n  // LayersModel.\n\n\n  setModel(model) {// Do nothing. Use Callback instead of BaseCallback to track the model.\n  }\n\n}\n/**\n * Container abstracting a list of callbacks.\n */\n\nexport class CallbackList {\n  // TODO(cais): When the need arises, uncomment the following lines and\n  // implement the queue for time values.\n  // private deltaTBatch: number;\n  // private deltaTsBatchBegin: Array<number>;\n  // private deltaTsBatchEnd: Array<number>;\n\n  /**\n   * Constructor of CallbackList.\n   * @param callbacks Array of `Callback` instances.\n   * @param queueLength Queue length for keeping running statistics over\n   *   callback execution time.\n   */\n  constructor(callbacks, queueLength = 10) {\n    // TODO(cais): Make use of queueLength when implementing the queue for time\n    // values.\n    if (callbacks == null) {\n      callbacks = [];\n    }\n\n    this.callbacks = callbacks;\n    this.queueLength = queueLength;\n  }\n\n  append(callback) {\n    this.callbacks.push(callback);\n  }\n\n  setParams(params) {\n    for (const callback of this.callbacks) {\n      callback.setParams(params);\n    }\n  }\n\n  setModel(model) {\n    for (const callback of this.callbacks) {\n      callback.setModel(model);\n    }\n  }\n  /**\n   * Called at the start of an epoch.\n   * @param epoch Index of epoch.\n   * @param logs Dictionary of logs.\n   */\n\n\n  onEpochBegin(epoch, logs) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (logs == null) {\n        logs = {};\n      }\n\n      for (const callback of _this.callbacks) {\n        yield callback.onEpochBegin(epoch, logs);\n      }\n    })();\n  }\n  /**\n   * Called at the end of an epoch.\n   * @param epoch Index of epoch.\n   * @param logs Dictionary of logs.\n   */\n\n\n  onEpochEnd(epoch, logs) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (logs == null) {\n        logs = {};\n      }\n\n      for (const callback of _this2.callbacks) {\n        yield callback.onEpochEnd(epoch, logs);\n      }\n    })();\n  }\n  /**\n   * Called  right before processing a batch.\n   * @param batch Index of batch within the current epoch.\n   * @param logs Dictionary of logs.\n   */\n\n\n  onBatchBegin(batch, logs) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (logs == null) {\n        logs = {};\n      }\n\n      for (const callback of _this3.callbacks) {\n        yield callback.onBatchBegin(batch, logs);\n      }\n    })();\n  }\n  /**\n   * Called at the end of a batch.\n   * @param batch Index of batch within the current epoch.\n   * @param logs Dictionary of logs.\n   */\n\n\n  onBatchEnd(batch, logs) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (logs == null) {\n        logs = {};\n      }\n\n      for (const callback of _this4.callbacks) {\n        yield callback.onBatchEnd(batch, logs);\n      }\n    })();\n  }\n  /**\n   * Called at the beginning of training.\n   * @param logs Dictionary of logs.\n   */\n\n\n  onTrainBegin(logs) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      if (logs == null) {\n        logs = {};\n      }\n\n      for (const callback of _this5.callbacks) {\n        yield callback.onTrainBegin(logs);\n      }\n    })();\n  }\n  /**\n   * Called at the end of training.\n   * @param logs Dictionary of logs.\n   */\n\n\n  onTrainEnd(logs) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      if (logs == null) {\n        logs = {};\n      }\n\n      for (const callback of _this6.callbacks) {\n        yield callback.onTrainEnd(logs);\n      }\n    })();\n  }\n\n}\n/**\n * Callback that accumulates epoch averages of metrics.\n *\n * This callback is automatically applied to every LayersModel.\n */\n\nexport class BaseLogger extends BaseCallback {\n  constructor() {\n    super();\n  }\n\n  onEpochBegin(epoch) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      _this7.seen = 0;\n      _this7.totals = {};\n    })();\n  }\n\n  onBatchEnd(batch, logs) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      if (logs == null) {\n        logs = {};\n      }\n\n      const batchSize = logs['size'] == null ? 0 : logs['size'];\n      _this8.seen += batchSize;\n\n      for (const key in logs) {\n        const value = logs[key];\n\n        if (typeof value === 'number') {\n          if (!_this8.totals.hasOwnProperty(key)) {\n            _this8.totals[key] = 0;\n          }\n\n          _this8.totals[key] = _this8.totals[key] + value * batchSize;\n        } else {\n          let oldTotalsToDispose;\n\n          if (key in _this8.totals) {\n            oldTotalsToDispose = _this8.totals[key];\n          } else {\n            _this8.totals[key] = 0;\n          }\n\n          const total = tidy(() => add(_this8.totals[key], mul(value, batchSize)));\n          _this8.totals[key] = total;\n\n          if (oldTotalsToDispose != null) {\n            oldTotalsToDispose.dispose();\n          }\n        }\n      }\n    })();\n  }\n\n  onEpochEnd(epoch, logs) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      if (logs != null) {\n        for (const key of _this9.params['metrics']) {\n          if (_this9.totals[key] == null) {\n            continue;\n          }\n\n          if (typeof _this9.totals[key] === 'number') {\n            logs[key] = _this9.totals[key] / _this9.seen;\n          } else {\n            tidy(() => {\n              const log = mul(div(1, _this9.seen), _this9.totals[key]);\n              logs[key] = log;\n\n              _this9.totals[key].dispose();\n\n              keep(logs[key]);\n            });\n          }\n        }\n      }\n    })();\n  }\n\n}\n/**\n * Callback that records events into a `History` object. This callback is\n * automatically applied to every TF.js Layers model. The `History` object\n * gets returned by the `fit` method of models.\n */\n\nexport class History extends BaseCallback {\n  onTrainBegin(logs) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      _this10.epoch = [];\n      _this10.history = {};\n    })();\n  }\n\n  onEpochEnd(epoch, logs) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      if (logs == null) {\n        logs = {};\n      }\n\n      _this11.epoch.push(epoch);\n\n      for (const key in logs) {\n        if (_this11.history[key] == null) {\n          _this11.history[key] = [];\n        }\n\n        _this11.history[key].push(logs[key]);\n      }\n    })();\n  }\n  /**\n   * Await the values of all losses and metrics.\n   */\n\n\n  syncData() {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      const promises = [];\n      const keys = [];\n      const indices = [];\n\n      for (const key in _this12.history) {\n        const valueArray = _this12.history[key];\n\n        for (let i = 0; i < valueArray.length; ++i) {\n          if (typeof valueArray[i] !== 'number') {\n            const valueScalar = valueArray[i];\n            promises.push(valueScalar.data());\n            keys.push(key);\n            indices.push(i);\n          }\n        }\n      }\n\n      const values = yield Promise.all(promises);\n\n      for (let n = 0; n < values.length; ++n) {\n        const tensorToDispose = _this12.history[keys[n]][indices[n]];\n        tensorToDispose.dispose();\n        _this12.history[keys[n]][indices[n]] = values[n][0];\n      }\n    })();\n  }\n\n}\n/**\n * Custom callback for training.\n */\n\nexport class CustomCallback extends BaseCallback {\n  constructor(args, yieldEvery) {\n    super();\n    this.currentEpoch = 0;\n    this.nowFunc = args.nowFunc;\n    this.nextFrameFunc = args.nextFrameFunc || nextFrame;\n    this.yieldEvery = yieldEvery || 'auto';\n\n    if (this.yieldEvery === 'auto') {\n      this.yieldEvery = DEFAULT_YIELD_EVERY_MS;\n    }\n\n    if (this.yieldEvery === 'never' && args.onYield != null) {\n      throw new Error('yieldEvery is `never` but you provided an `onYield` callback. ' + 'Either change `yieldEvery` or remove the callback');\n    }\n\n    if (util.isNumber(this.yieldEvery)) {\n      // Decorate `maybeWait` so it will be called at most once every\n      // `yieldEvery` ms.\n      this.maybeWait = generic_utils.debounce(this.maybeWait.bind(this), this.yieldEvery, this.nowFunc);\n    }\n\n    this.trainBegin = args.onTrainBegin;\n    this.trainEnd = args.onTrainEnd;\n    this.epochBegin = args.onEpochBegin;\n    this.epochEnd = args.onEpochEnd;\n    this.batchBegin = args.onBatchBegin;\n    this.batchEnd = args.onBatchEnd;\n    this.yield = args.onYield;\n  }\n\n  maybeWait(epoch, batch, logs) {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      const ps = [];\n\n      if (_this13.yield != null) {\n        yield resolveScalarsInLogs(logs);\n        ps.push(_this13.yield(epoch, batch, logs));\n      }\n\n      ps.push(_this13.nextFrameFunc());\n      yield Promise.all(ps);\n    })();\n  }\n\n  onEpochBegin(epoch, logs) {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      _this14.currentEpoch = epoch;\n\n      if (_this14.epochBegin != null) {\n        yield resolveScalarsInLogs(logs);\n        yield _this14.epochBegin(epoch, logs);\n      }\n    })();\n  }\n\n  onEpochEnd(epoch, logs) {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      const ps = [];\n\n      if (_this15.epochEnd != null) {\n        yield resolveScalarsInLogs(logs);\n        ps.push(_this15.epochEnd(epoch, logs));\n      }\n\n      if (_this15.yieldEvery === 'epoch') {\n        ps.push(_this15.nextFrameFunc());\n      }\n\n      yield Promise.all(ps);\n    })();\n  }\n\n  onBatchBegin(batch, logs) {\n    var _this16 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this16.batchBegin != null) {\n        yield resolveScalarsInLogs(logs);\n        yield _this16.batchBegin(batch, logs);\n      }\n    })();\n  }\n\n  onBatchEnd(batch, logs) {\n    var _this17 = this;\n\n    return _asyncToGenerator(function* () {\n      const ps = [];\n\n      if (_this17.batchEnd != null) {\n        yield resolveScalarsInLogs(logs);\n        ps.push(_this17.batchEnd(batch, logs));\n      }\n\n      if (_this17.yieldEvery === 'batch') {\n        ps.push(_this17.nextFrameFunc());\n      } else if (util.isNumber(_this17.yieldEvery)) {\n        ps.push(_this17.maybeWait(_this17.currentEpoch, batch, logs));\n      }\n\n      yield Promise.all(ps);\n    })();\n  }\n\n  onTrainBegin(logs) {\n    var _this18 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this18.trainBegin != null) {\n        yield resolveScalarsInLogs(logs);\n        yield _this18.trainBegin(logs);\n      }\n    })();\n  }\n\n  onTrainEnd(logs) {\n    var _this19 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this19.trainEnd != null) {\n        yield resolveScalarsInLogs(logs);\n        yield _this19.trainEnd(logs);\n      }\n    })();\n  }\n\n}\n/**\n * Standardize callbacks or configurations of them to an Array of callbacks.\n */\n\nexport function standardizeCallbacks(callbacks, yieldEvery) {\n  if (callbacks == null) {\n    callbacks = {};\n  }\n\n  if (callbacks instanceof BaseCallback) {\n    return [callbacks];\n  }\n\n  if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n    return callbacks;\n  } // Convert custom callback configs to custom callback objects.\n\n\n  const callbackConfigs = generic_utils.toList(callbacks);\n  return callbackConfigs.map(callbackConfig => new CustomCallback(callbackConfig, yieldEvery));\n}\n/**\n * A global registry for callback constructors to be used during\n * LayersModel.fit().\n */\n\nexport class CallbackConstructorRegistry {\n  /**\n   * Blocks public access to constructor.\n   */\n  constructor() {}\n  /**\n   * Register a tf.LayersModel.fit() callback constructor.\n   *\n   * The registered callback constructor will be used to instantiate\n   * callbacks for every tf.LayersModel.fit() call afterwards.\n   *\n   * @param verbosityLevel Level of verbosity at which the `callbackConstructor`\n   *   is to be reigstered.\n   * @param callbackConstructor A no-arg constructor for `tf.Callback`.\n   * @throws Error, if the same callbackConstructor has been registered before,\n   *   either at the same or a different `verbosityLevel`.\n   */\n\n\n  static registerCallbackConstructor(verbosityLevel, callbackConstructor) {\n    util.assert(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), () => `Verbosity level is expected to be an integer >= 0, ` + `but got ${verbosityLevel}`);\n    CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n\n    if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n      CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n    }\n\n    CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);\n  }\n\n  static checkForDuplicate(callbackConstructor) {\n    for (const levelName in CallbackConstructorRegistry.constructors) {\n      const constructors = CallbackConstructorRegistry.constructors[+levelName];\n      constructors.forEach(ctor => {\n        if (ctor === callbackConstructor) {\n          throw new ValueError('Duplicate callback constructor.');\n        }\n      });\n    }\n  }\n  /**\n   * Clear all registered callback constructors.\n   */\n\n\n  static clear() {\n    CallbackConstructorRegistry.constructors = {};\n  }\n  /**\n   * Create callbacks using the registered callback constructors.\n   *\n   * Given `verbosityLevel`, all constructors registered at that level or above\n   * will be called and the instantiated callbacks will be used.\n   *\n   * @param verbosityLevel: Level of verbosity.\n   */\n\n\n  static createCallbacks(verbosityLevel) {\n    const constructors = [];\n\n    for (const levelName in CallbackConstructorRegistry.constructors) {\n      const level = +levelName;\n\n      if (verbosityLevel >= level) {\n        constructors.push(...CallbackConstructorRegistry.constructors[level]);\n      }\n    }\n\n    return constructors.map(ctor => new ctor());\n  }\n\n}\nCallbackConstructorRegistry.constructors = {};\nexport function configureCallbacks(callbacks, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {\n  const history = new History();\n  const actualCallbacks = [new BaseLogger(), ...CallbackConstructorRegistry.createCallbacks(verbose)];\n\n  if (callbacks != null) {\n    actualCallbacks.push(...callbacks);\n  }\n\n  actualCallbacks.push(history);\n  const callbackList = new CallbackList(actualCallbacks); // TODO(cais): Figure out when this LayersModel instance can have a\n  // dynamically\n  //   set property called 'callback_model' as in PyKeras.\n\n  callbackList.setParams({\n    epochs,\n    initialEpoch,\n    samples: numTrainSamples,\n    steps: stepsPerEpoch,\n    batchSize,\n    verbose,\n    doValidation,\n    metrics: callbackMetrics\n  });\n  return {\n    callbackList,\n    history\n  };\n}","map":{"version":3,"names":["add","div","keep","mul","nextFrame","tidy","util","ValueError","resolveScalarsInLogs","generic_utils","ModelLoggingVerbosity","DEFAULT_YIELD_EVERY_MS","BaseCallback","constructor","validationData","setParams","params","onEpochBegin","epoch","logs","onEpochEnd","onBatchBegin","batch","onBatchEnd","onTrainBegin","onTrainEnd","setModel","model","CallbackList","callbacks","queueLength","append","callback","push","BaseLogger","seen","totals","batchSize","key","value","hasOwnProperty","oldTotalsToDispose","total","dispose","log","History","history","syncData","promises","keys","indices","valueArray","i","length","valueScalar","data","values","Promise","all","n","tensorToDispose","CustomCallback","args","yieldEvery","currentEpoch","nowFunc","nextFrameFunc","onYield","Error","isNumber","maybeWait","debounce","bind","trainBegin","trainEnd","epochBegin","epochEnd","batchBegin","batchEnd","yield","ps","standardizeCallbacks","Array","isArray","callbackConfigs","toList","map","callbackConfig","CallbackConstructorRegistry","registerCallbackConstructor","verbosityLevel","callbackConstructor","assert","Number","isInteger","checkForDuplicate","constructors","levelName","forEach","ctor","clear","createCallbacks","level","configureCallbacks","verbose","epochs","initialEpoch","numTrainSamples","stepsPerEpoch","doValidation","callbackMetrics","actualCallbacks","callbackList","samples","steps","metrics"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-layers/dist/base_callbacks.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source: keras/callbacks.py */\nimport { add, div, keep, mul, nextFrame, tidy, util } from '@tensorflow/tfjs-core';\nimport { ValueError } from './errors';\nimport { resolveScalarsInLogs } from './logs';\nimport * as generic_utils from './utils/generic_utils';\n/** Verbosity logging level when fitting a model. */\nexport var ModelLoggingVerbosity;\n(function (ModelLoggingVerbosity) {\n    ModelLoggingVerbosity[ModelLoggingVerbosity[\"SILENT\"] = 0] = \"SILENT\";\n    ModelLoggingVerbosity[ModelLoggingVerbosity[\"VERBOSE\"] = 1] = \"VERBOSE\";\n})(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));\n/** How often to yield to the main thread when training (in ms). */\nexport const DEFAULT_YIELD_EVERY_MS = 125;\n/**\n * Abstract base class used to build new callbacks.\n *\n * The `logs` dictionary that callback methods take as argument will contain\n * keys for quantities relevant to the current batch or epoch.\n *\n * Currently, the `.fit()` method of the `Sequential` model class\n * will include the following quantities in the `logs` that\n * it passes to its callbacks:\n *\n * onEpochEnd: Logs include `acc` and `loss`, and optionally include `valLoss`\n *   (if validation is enabled in `fit`), and `valAcc` (if validation and\n *   accuracy monitoring are enabled).\n * onBatchBegin: Logs include `size`, the number of samples in the current\n *   batch.\n * onBatchEnd: Logs include `loss`, and optionally `acc` (if accuracy monitoring\n *   is enabled).\n */\nexport class BaseCallback {\n    constructor() {\n        // TODO(michaelterry): This type is a best guess.\n        this.validationData = null;\n    }\n    setParams(params) {\n        this.params = params;\n    }\n    async onEpochBegin(epoch, logs) { }\n    async onEpochEnd(epoch, logs) { }\n    async onBatchBegin(batch, logs) { }\n    async onBatchEnd(batch, logs) { }\n    async onTrainBegin(logs) { }\n    async onTrainEnd(logs) { }\n    // LayersModel needs to call Callback.setModel(), but cannot actually depend\n    // on Callback because that creates a cyclic dependency.  Providing this no-op\n    // method on BaseCallback breaks the cycle: this way LayersModel can depend on\n    // BaseCallback but not on Callback.  The argument is typed as `Container`\n    // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback\n    // overrides this method and enforces that the argument is really a\n    // LayersModel.\n    setModel(model) {\n        // Do nothing. Use Callback instead of BaseCallback to track the model.\n    }\n}\n/**\n * Container abstracting a list of callbacks.\n */\nexport class CallbackList {\n    // TODO(cais): When the need arises, uncomment the following lines and\n    // implement the queue for time values.\n    // private deltaTBatch: number;\n    // private deltaTsBatchBegin: Array<number>;\n    // private deltaTsBatchEnd: Array<number>;\n    /**\n     * Constructor of CallbackList.\n     * @param callbacks Array of `Callback` instances.\n     * @param queueLength Queue length for keeping running statistics over\n     *   callback execution time.\n     */\n    constructor(callbacks, queueLength = 10) {\n        // TODO(cais): Make use of queueLength when implementing the queue for time\n        // values.\n        if (callbacks == null) {\n            callbacks = [];\n        }\n        this.callbacks = callbacks;\n        this.queueLength = queueLength;\n    }\n    append(callback) {\n        this.callbacks.push(callback);\n    }\n    setParams(params) {\n        for (const callback of this.callbacks) {\n            callback.setParams(params);\n        }\n    }\n    setModel(model) {\n        for (const callback of this.callbacks) {\n            callback.setModel(model);\n        }\n    }\n    /**\n     * Called at the start of an epoch.\n     * @param epoch Index of epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onEpochBegin(epoch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onEpochBegin(epoch, logs);\n        }\n    }\n    /**\n     * Called at the end of an epoch.\n     * @param epoch Index of epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onEpochEnd(epoch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onEpochEnd(epoch, logs);\n        }\n    }\n    /**\n     * Called  right before processing a batch.\n     * @param batch Index of batch within the current epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onBatchBegin(batch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onBatchBegin(batch, logs);\n        }\n    }\n    /**\n     * Called at the end of a batch.\n     * @param batch Index of batch within the current epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onBatchEnd(batch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onBatchEnd(batch, logs);\n        }\n    }\n    /**\n     * Called at the beginning of training.\n     * @param logs Dictionary of logs.\n     */\n    async onTrainBegin(logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onTrainBegin(logs);\n        }\n    }\n    /**\n     * Called at the end of training.\n     * @param logs Dictionary of logs.\n     */\n    async onTrainEnd(logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onTrainEnd(logs);\n        }\n    }\n}\n/**\n * Callback that accumulates epoch averages of metrics.\n *\n * This callback is automatically applied to every LayersModel.\n */\nexport class BaseLogger extends BaseCallback {\n    constructor() {\n        super();\n    }\n    async onEpochBegin(epoch) {\n        this.seen = 0;\n        this.totals = {};\n    }\n    async onBatchEnd(batch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        const batchSize = logs['size'] == null ? 0 : logs['size'];\n        this.seen += batchSize;\n        for (const key in logs) {\n            const value = logs[key];\n            if (typeof value === 'number') {\n                if (!this.totals.hasOwnProperty(key)) {\n                    this.totals[key] = 0;\n                }\n                this.totals[key] = this.totals[key] + value * batchSize;\n            }\n            else {\n                let oldTotalsToDispose;\n                if (key in this.totals) {\n                    oldTotalsToDispose = this.totals[key];\n                }\n                else {\n                    this.totals[key] = 0;\n                }\n                const total = tidy(() => add((this.totals[key]), mul(value, batchSize)));\n                this.totals[key] = total;\n                if (oldTotalsToDispose != null) {\n                    oldTotalsToDispose.dispose();\n                }\n            }\n        }\n    }\n    async onEpochEnd(epoch, logs) {\n        if (logs != null) {\n            for (const key of this.params['metrics']) {\n                if (this.totals[key] == null) {\n                    continue;\n                }\n                if (typeof this.totals[key] === 'number') {\n                    logs[key] = this.totals[key] / this.seen;\n                }\n                else {\n                    tidy(() => {\n                        const log = mul(div(1, this.seen), this.totals[key]);\n                        logs[key] = log;\n                        this.totals[key].dispose();\n                        keep(logs[key]);\n                    });\n                }\n            }\n        }\n    }\n}\n/**\n * Callback that records events into a `History` object. This callback is\n * automatically applied to every TF.js Layers model. The `History` object\n * gets returned by the `fit` method of models.\n */\nexport class History extends BaseCallback {\n    async onTrainBegin(logs) {\n        this.epoch = [];\n        this.history = {};\n    }\n    async onEpochEnd(epoch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        this.epoch.push(epoch);\n        for (const key in logs) {\n            if (this.history[key] == null) {\n                this.history[key] = [];\n            }\n            this.history[key].push(logs[key]);\n        }\n    }\n    /**\n     * Await the values of all losses and metrics.\n     */\n    async syncData() {\n        const promises = [];\n        const keys = [];\n        const indices = [];\n        for (const key in this.history) {\n            const valueArray = this.history[key];\n            for (let i = 0; i < valueArray.length; ++i) {\n                if (typeof valueArray[i] !== 'number') {\n                    const valueScalar = valueArray[i];\n                    promises.push(valueScalar.data());\n                    keys.push(key);\n                    indices.push(i);\n                }\n            }\n        }\n        const values = await Promise.all(promises);\n        for (let n = 0; n < values.length; ++n) {\n            const tensorToDispose = this.history[keys[n]][indices[n]];\n            tensorToDispose.dispose();\n            this.history[keys[n]][indices[n]] = values[n][0];\n        }\n    }\n}\n/**\n * Custom callback for training.\n */\nexport class CustomCallback extends BaseCallback {\n    constructor(args, yieldEvery) {\n        super();\n        this.currentEpoch = 0;\n        this.nowFunc = args.nowFunc;\n        this.nextFrameFunc = args.nextFrameFunc || nextFrame;\n        this.yieldEvery = yieldEvery || 'auto';\n        if (this.yieldEvery === 'auto') {\n            this.yieldEvery = DEFAULT_YIELD_EVERY_MS;\n        }\n        if (this.yieldEvery === 'never' && args.onYield != null) {\n            throw new Error('yieldEvery is `never` but you provided an `onYield` callback. ' +\n                'Either change `yieldEvery` or remove the callback');\n        }\n        if (util.isNumber(this.yieldEvery)) {\n            // Decorate `maybeWait` so it will be called at most once every\n            // `yieldEvery` ms.\n            this.maybeWait = generic_utils.debounce(this.maybeWait.bind(this), this.yieldEvery, this.nowFunc);\n        }\n        this.trainBegin = args.onTrainBegin;\n        this.trainEnd = args.onTrainEnd;\n        this.epochBegin = args.onEpochBegin;\n        this.epochEnd = args.onEpochEnd;\n        this.batchBegin = args.onBatchBegin;\n        this.batchEnd = args.onBatchEnd;\n        this.yield = args.onYield;\n    }\n    async maybeWait(epoch, batch, logs) {\n        const ps = [];\n        if (this.yield != null) {\n            await resolveScalarsInLogs(logs);\n            ps.push(this.yield(epoch, batch, logs));\n        }\n        ps.push(this.nextFrameFunc());\n        await Promise.all(ps);\n    }\n    async onEpochBegin(epoch, logs) {\n        this.currentEpoch = epoch;\n        if (this.epochBegin != null) {\n            await resolveScalarsInLogs(logs);\n            await this.epochBegin(epoch, logs);\n        }\n    }\n    async onEpochEnd(epoch, logs) {\n        const ps = [];\n        if (this.epochEnd != null) {\n            await resolveScalarsInLogs(logs);\n            ps.push(this.epochEnd(epoch, logs));\n        }\n        if (this.yieldEvery === 'epoch') {\n            ps.push(this.nextFrameFunc());\n        }\n        await Promise.all(ps);\n    }\n    async onBatchBegin(batch, logs) {\n        if (this.batchBegin != null) {\n            await resolveScalarsInLogs(logs);\n            await this.batchBegin(batch, logs);\n        }\n    }\n    async onBatchEnd(batch, logs) {\n        const ps = [];\n        if (this.batchEnd != null) {\n            await resolveScalarsInLogs(logs);\n            ps.push(this.batchEnd(batch, logs));\n        }\n        if (this.yieldEvery === 'batch') {\n            ps.push(this.nextFrameFunc());\n        }\n        else if (util.isNumber(this.yieldEvery)) {\n            ps.push(this.maybeWait(this.currentEpoch, batch, logs));\n        }\n        await Promise.all(ps);\n    }\n    async onTrainBegin(logs) {\n        if (this.trainBegin != null) {\n            await resolveScalarsInLogs(logs);\n            await this.trainBegin(logs);\n        }\n    }\n    async onTrainEnd(logs) {\n        if (this.trainEnd != null) {\n            await resolveScalarsInLogs(logs);\n            await this.trainEnd(logs);\n        }\n    }\n}\n/**\n * Standardize callbacks or configurations of them to an Array of callbacks.\n */\nexport function standardizeCallbacks(callbacks, yieldEvery) {\n    if (callbacks == null) {\n        callbacks = {};\n    }\n    if (callbacks instanceof BaseCallback) {\n        return [callbacks];\n    }\n    if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n        return callbacks;\n    }\n    // Convert custom callback configs to custom callback objects.\n    const callbackConfigs = generic_utils.toList(callbacks);\n    return callbackConfigs.map(callbackConfig => new CustomCallback(callbackConfig, yieldEvery));\n}\n/**\n * A global registry for callback constructors to be used during\n * LayersModel.fit().\n */\nexport class CallbackConstructorRegistry {\n    /**\n     * Blocks public access to constructor.\n     */\n    constructor() { }\n    /**\n     * Register a tf.LayersModel.fit() callback constructor.\n     *\n     * The registered callback constructor will be used to instantiate\n     * callbacks for every tf.LayersModel.fit() call afterwards.\n     *\n     * @param verbosityLevel Level of verbosity at which the `callbackConstructor`\n     *   is to be reigstered.\n     * @param callbackConstructor A no-arg constructor for `tf.Callback`.\n     * @throws Error, if the same callbackConstructor has been registered before,\n     *   either at the same or a different `verbosityLevel`.\n     */\n    static registerCallbackConstructor(verbosityLevel, callbackConstructor) {\n        util.assert(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), () => `Verbosity level is expected to be an integer >= 0, ` +\n            `but got ${verbosityLevel}`);\n        CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n        if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n            CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n        }\n        CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);\n    }\n    static checkForDuplicate(callbackConstructor) {\n        for (const levelName in CallbackConstructorRegistry.constructors) {\n            const constructors = CallbackConstructorRegistry.constructors[+levelName];\n            constructors.forEach(ctor => {\n                if (ctor === callbackConstructor) {\n                    throw new ValueError('Duplicate callback constructor.');\n                }\n            });\n        }\n    }\n    /**\n     * Clear all registered callback constructors.\n     */\n    static clear() {\n        CallbackConstructorRegistry.constructors = {};\n    }\n    /**\n     * Create callbacks using the registered callback constructors.\n     *\n     * Given `verbosityLevel`, all constructors registered at that level or above\n     * will be called and the instantiated callbacks will be used.\n     *\n     * @param verbosityLevel: Level of verbosity.\n     */\n    static createCallbacks(verbosityLevel) {\n        const constructors = [];\n        for (const levelName in CallbackConstructorRegistry.constructors) {\n            const level = +levelName;\n            if (verbosityLevel >= level) {\n                constructors.push(...CallbackConstructorRegistry.constructors[level]);\n            }\n        }\n        return constructors.map(ctor => new ctor());\n    }\n}\nCallbackConstructorRegistry.constructors = {};\nexport function configureCallbacks(callbacks, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {\n    const history = new History();\n    const actualCallbacks = [\n        new BaseLogger(), ...CallbackConstructorRegistry.createCallbacks(verbose)\n    ];\n    if (callbacks != null) {\n        actualCallbacks.push(...callbacks);\n    }\n    actualCallbacks.push(history);\n    const callbackList = new CallbackList(actualCallbacks);\n    // TODO(cais): Figure out when this LayersModel instance can have a\n    // dynamically\n    //   set property called 'callback_model' as in PyKeras.\n    callbackList.setParams({\n        epochs,\n        initialEpoch,\n        samples: numTrainSamples,\n        steps: stepsPerEpoch,\n        batchSize,\n        verbose,\n        doValidation,\n        metrics: callbackMetrics,\n    });\n    return { callbackList, history };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}