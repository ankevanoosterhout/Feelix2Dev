{"ast":null,"code":"/**\n * Validate sparseToDense inputs.\n *\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\n * placed.\n * @param sparseValues A 0-D or 1-D Tensor. Values\n * corresponding to each row of sparseIndices, or a scalar value to be used for\n * all sparse indices.\n * @param outputShape number[]. Shape of the dense output tensor.\n * @param validateIndices boolean. indice validation is not supported, error\n * will be thrown if it is set.\n */\nexport function validateInput(sparseIndices, sparseValues, outputShape, defaultValues) {\n  if (sparseIndices.dtype !== 'int32') {\n    throw new Error('tf.sparseToDense() expects the indices to be int32 type,' + ` but the dtype was ${sparseIndices.dtype}.`);\n  }\n\n  if (sparseIndices.rank > 2) {\n    throw new Error('sparseIndices should be a scalar, vector, or matrix,' + ` but got shape ${sparseIndices.shape}.`);\n  }\n\n  const numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;\n  const numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;\n\n  if (outputShape.length !== numDims) {\n    throw new Error('outputShape has incorrect number of elements:,' + ` ${outputShape.length}, should be: ${numDims}.`);\n  }\n\n  const numValues = sparseValues.size;\n\n  if (!(sparseValues.rank === 0 || sparseValues.rank === 1 && numValues === numElems)) {\n    throw new Error('sparseValues has incorrect shape ' + `${sparseValues.shape}, should be [] or [${numElems}]`);\n  }\n\n  if (sparseValues.dtype !== defaultValues.dtype) {\n    throw new Error('sparseValues.dtype must match defaultValues.dtype');\n  }\n}","map":{"version":3,"names":["validateInput","sparseIndices","sparseValues","outputShape","defaultValues","dtype","Error","rank","shape","numElems","numDims","length","numValues","size"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-core/dist/ops/sparse_to_dense_util.js"],"sourcesContent":["/**\n * Validate sparseToDense inputs.\n *\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\n * placed.\n * @param sparseValues A 0-D or 1-D Tensor. Values\n * corresponding to each row of sparseIndices, or a scalar value to be used for\n * all sparse indices.\n * @param outputShape number[]. Shape of the dense output tensor.\n * @param validateIndices boolean. indice validation is not supported, error\n * will be thrown if it is set.\n */\nexport function validateInput(sparseIndices, sparseValues, outputShape, defaultValues) {\n    if (sparseIndices.dtype !== 'int32') {\n        throw new Error('tf.sparseToDense() expects the indices to be int32 type,' +\n            ` but the dtype was ${sparseIndices.dtype}.`);\n    }\n    if (sparseIndices.rank > 2) {\n        throw new Error('sparseIndices should be a scalar, vector, or matrix,' +\n            ` but got shape ${sparseIndices.shape}.`);\n    }\n    const numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;\n    const numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;\n    if (outputShape.length !== numDims) {\n        throw new Error('outputShape has incorrect number of elements:,' +\n            ` ${outputShape.length}, should be: ${numDims}.`);\n    }\n    const numValues = sparseValues.size;\n    if (!(sparseValues.rank === 0 ||\n        sparseValues.rank === 1 && numValues === numElems)) {\n        throw new Error('sparseValues has incorrect shape ' +\n            `${sparseValues.shape}, should be [] or [${numElems}]`);\n    }\n    if (sparseValues.dtype !== defaultValues.dtype) {\n        throw new Error('sparseValues.dtype must match defaultValues.dtype');\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,aAAT,CAAuBC,aAAvB,EAAsCC,YAAtC,EAAoDC,WAApD,EAAiEC,aAAjE,EAAgF;EACnF,IAAIH,aAAa,CAACI,KAAd,KAAwB,OAA5B,EAAqC;IACjC,MAAM,IAAIC,KAAJ,CAAU,6DACX,sBAAqBL,aAAa,CAACI,KAAM,GADxC,CAAN;EAEH;;EACD,IAAIJ,aAAa,CAACM,IAAd,GAAqB,CAAzB,EAA4B;IACxB,MAAM,IAAID,KAAJ,CAAU,yDACX,kBAAiBL,aAAa,CAACO,KAAM,GADpC,CAAN;EAEH;;EACD,MAAMC,QAAQ,GAAGR,aAAa,CAACM,IAAd,GAAqB,CAArB,GAAyBN,aAAa,CAACO,KAAd,CAAoB,CAApB,CAAzB,GAAkD,CAAnE;EACA,MAAME,OAAO,GAAGT,aAAa,CAACM,IAAd,GAAqB,CAArB,GAAyBN,aAAa,CAACO,KAAd,CAAoB,CAApB,CAAzB,GAAkD,CAAlE;;EACA,IAAIL,WAAW,CAACQ,MAAZ,KAAuBD,OAA3B,EAAoC;IAChC,MAAM,IAAIJ,KAAJ,CAAU,mDACX,IAAGH,WAAW,CAACQ,MAAO,gBAAeD,OAAQ,GAD5C,CAAN;EAEH;;EACD,MAAME,SAAS,GAAGV,YAAY,CAACW,IAA/B;;EACA,IAAI,EAAEX,YAAY,CAACK,IAAb,KAAsB,CAAtB,IACFL,YAAY,CAACK,IAAb,KAAsB,CAAtB,IAA2BK,SAAS,KAAKH,QADzC,CAAJ,EACwD;IACpD,MAAM,IAAIH,KAAJ,CAAU,sCACX,GAAEJ,YAAY,CAACM,KAAM,sBAAqBC,QAAS,GADlD,CAAN;EAEH;;EACD,IAAIP,YAAY,CAACG,KAAb,KAAuBD,aAAa,CAACC,KAAzC,EAAgD;IAC5C,MAAM,IAAIC,KAAJ,CAAU,mDAAV,CAAN;EACH;AACJ"},"metadata":{},"sourceType":"module"}