{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nclass PassthroughLoader {\n  constructor(modelArtifacts) {\n    this.modelArtifacts = modelArtifacts;\n  }\n\n  load() {\n    return this.modelArtifacts;\n  }\n\n}\n\nclass PassthroughSaver {\n  constructor(saveHandler) {\n    this.saveHandler = saveHandler;\n  }\n\n  save(modelArtifacts) {\n    return this.saveHandler(modelArtifacts);\n  }\n\n}\n\nclass PassthroughAsync {\n  constructor(handler) {\n    if (handler.load) {\n      this.load = () => Promise.resolve(handler.load());\n    }\n\n    if (handler.save) {\n      this.save = modelArtifacts => Promise.resolve(handler.save(modelArtifacts));\n    }\n  }\n\n}\n/**\n * Creates an IOHandler that loads model artifacts from memory.\n *\n * When used in conjunction with `tf.loadLayersModel`, an instance of\n * `tf.LayersModel` (Keras-style) can be constructed from the loaded artifacts.\n *\n * ```js\n * const model = await tf.loadLayersModel(tf.io.fromMemory(\n *     modelTopology, weightSpecs, weightData));\n * ```\n *\n * @param modelArtifacts a object containing model topology (i.e., parsed from\n *   the JSON format).\n * @param weightSpecs An array of `WeightsManifestEntry` objects describing the\n *   names, shapes, types, and quantization of the weight data. Optional.\n * @param weightData A single `ArrayBuffer` containing the weight data,\n *   concatenated in the order described by the weightSpecs. Optional.\n * @param trainingConfig Model training configuration. Optional.\n *\n * @returns A passthrough `IOHandler` that simply loads the provided data.\n */\n\n\nexport function fromMemory(modelArtifacts, weightSpecs, weightData, trainingConfig) {\n  const args = arguments;\n  return new PassthroughAsync(fromMemorySync(...args));\n}\n/**\n * Creates an IOHandler that loads model artifacts from memory.\n *\n * When used in conjunction with `tf.loadLayersModel`, an instance of\n * `tf.LayersModel` (Keras-style) can be constructed from the loaded artifacts.\n *\n * ```js\n * const model = await tf.loadLayersModel(tf.io.fromMemory(\n *     modelTopology, weightSpecs, weightData));\n * ```\n *\n * @param modelArtifacts a object containing model topology (i.e., parsed from\n *   the JSON format).\n * @param weightSpecs An array of `WeightsManifestEntry` objects describing the\n *   names, shapes, types, and quantization of the weight data. Optional.\n * @param weightData A single `ArrayBuffer` containing the weight data,\n *   concatenated in the order described by the weightSpecs. Optional.\n * @param trainingConfig Model training configuration. Optional.\n *\n * @returns A passthrough `IOHandlerSync` that simply loads the provided data.\n */\n\nexport function fromMemorySync(modelArtifacts, weightSpecs, weightData, trainingConfig) {\n  if (arguments.length === 1) {\n    const isModelArtifacts = modelArtifacts.modelTopology != null || modelArtifacts.weightSpecs != null;\n\n    if (isModelArtifacts) {\n      return new PassthroughLoader(modelArtifacts);\n    } else {\n      // Legacy support: with only modelTopology.\n      // TODO(cais): Remove this deprecated API.\n      console.warn('Please call tf.io.fromMemory() with only one argument. ' + 'The argument should be of type ModelArtifacts. ' + 'The multi-argument signature of tf.io.fromMemory() has been ' + 'deprecated and will be removed in a future release.');\n      return new PassthroughLoader({\n        modelTopology: modelArtifacts\n      });\n    }\n  } else {\n    // Legacy support.\n    // TODO(cais): Remove this deprecated API.\n    console.warn('Please call tf.io.fromMemory() with only one argument. ' + 'The argument should be of type ModelArtifacts. ' + 'The multi-argument signature of tf.io.fromMemory() has been ' + 'deprecated and will be removed in a future release.');\n    return new PassthroughLoader({\n      modelTopology: modelArtifacts,\n      weightSpecs,\n      weightData,\n      trainingConfig\n    });\n  }\n}\n/**\n * Creates an IOHandler that passes saved model artifacts to a callback.\n *\n * ```js\n * function handleSave(artifacts) {\n *   // ... do something with the artifacts ...\n *   return {modelArtifactsInfo: {...}, ...};\n * }\n *\n * const saveResult = model.save(tf.io.withSaveHandler(handleSave));\n * ```\n *\n * @param saveHandler A function that accepts a `ModelArtifacts` and returns a\n *     promise that resolves to a `SaveResult`.\n */\n\nexport function withSaveHandler(saveHandler) {\n  return new PassthroughSaver(saveHandler);\n}\n/**\n * Creates an IOHandlerSync that passes saved model artifacts to a callback.\n *\n * ```js\n * function handleSave(artifacts) {\n *   // ... do something with the artifacts ...\n *   return {modelArtifactsInfo: {...}, ...};\n * }\n *\n * const saveResult = model.save(tf.io.withSaveHandler(handleSave));\n * ```\n *\n * @param saveHandler A function that accepts a `ModelArtifacts` and returns a\n *     `SaveResult`.\n */\n\nexport function withSaveHandlerSync(saveHandler) {\n  return new PassthroughSaver(saveHandler);\n}","map":{"version":3,"names":["PassthroughLoader","constructor","modelArtifacts","load","PassthroughSaver","saveHandler","save","PassthroughAsync","handler","Promise","resolve","fromMemory","weightSpecs","weightData","trainingConfig","args","arguments","fromMemorySync","length","isModelArtifacts","modelTopology","console","warn","withSaveHandler","withSaveHandlerSync"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-core/dist/io/passthrough.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nclass PassthroughLoader {\n    constructor(modelArtifacts) {\n        this.modelArtifacts = modelArtifacts;\n    }\n    load() {\n        return this.modelArtifacts;\n    }\n}\nclass PassthroughSaver {\n    constructor(saveHandler) {\n        this.saveHandler = saveHandler;\n    }\n    save(modelArtifacts) {\n        return this.saveHandler(modelArtifacts);\n    }\n}\nclass PassthroughAsync {\n    constructor(handler) {\n        if (handler.load) {\n            this.load = () => Promise.resolve(handler.load());\n        }\n        if (handler.save) {\n            this.save = (modelArtifacts) => Promise.resolve(handler.save(modelArtifacts));\n        }\n    }\n}\n/**\n * Creates an IOHandler that loads model artifacts from memory.\n *\n * When used in conjunction with `tf.loadLayersModel`, an instance of\n * `tf.LayersModel` (Keras-style) can be constructed from the loaded artifacts.\n *\n * ```js\n * const model = await tf.loadLayersModel(tf.io.fromMemory(\n *     modelTopology, weightSpecs, weightData));\n * ```\n *\n * @param modelArtifacts a object containing model topology (i.e., parsed from\n *   the JSON format).\n * @param weightSpecs An array of `WeightsManifestEntry` objects describing the\n *   names, shapes, types, and quantization of the weight data. Optional.\n * @param weightData A single `ArrayBuffer` containing the weight data,\n *   concatenated in the order described by the weightSpecs. Optional.\n * @param trainingConfig Model training configuration. Optional.\n *\n * @returns A passthrough `IOHandler` that simply loads the provided data.\n */\nexport function fromMemory(modelArtifacts, weightSpecs, weightData, trainingConfig) {\n    const args = arguments;\n    return new PassthroughAsync(fromMemorySync(...args));\n}\n/**\n * Creates an IOHandler that loads model artifacts from memory.\n *\n * When used in conjunction with `tf.loadLayersModel`, an instance of\n * `tf.LayersModel` (Keras-style) can be constructed from the loaded artifacts.\n *\n * ```js\n * const model = await tf.loadLayersModel(tf.io.fromMemory(\n *     modelTopology, weightSpecs, weightData));\n * ```\n *\n * @param modelArtifacts a object containing model topology (i.e., parsed from\n *   the JSON format).\n * @param weightSpecs An array of `WeightsManifestEntry` objects describing the\n *   names, shapes, types, and quantization of the weight data. Optional.\n * @param weightData A single `ArrayBuffer` containing the weight data,\n *   concatenated in the order described by the weightSpecs. Optional.\n * @param trainingConfig Model training configuration. Optional.\n *\n * @returns A passthrough `IOHandlerSync` that simply loads the provided data.\n */\nexport function fromMemorySync(modelArtifacts, weightSpecs, weightData, trainingConfig) {\n    if (arguments.length === 1) {\n        const isModelArtifacts = modelArtifacts.modelTopology != null ||\n            modelArtifacts.weightSpecs != null;\n        if (isModelArtifacts) {\n            return new PassthroughLoader(modelArtifacts);\n        }\n        else {\n            // Legacy support: with only modelTopology.\n            // TODO(cais): Remove this deprecated API.\n            console.warn('Please call tf.io.fromMemory() with only one argument. ' +\n                'The argument should be of type ModelArtifacts. ' +\n                'The multi-argument signature of tf.io.fromMemory() has been ' +\n                'deprecated and will be removed in a future release.');\n            return new PassthroughLoader({ modelTopology: modelArtifacts });\n        }\n    }\n    else {\n        // Legacy support.\n        // TODO(cais): Remove this deprecated API.\n        console.warn('Please call tf.io.fromMemory() with only one argument. ' +\n            'The argument should be of type ModelArtifacts. ' +\n            'The multi-argument signature of tf.io.fromMemory() has been ' +\n            'deprecated and will be removed in a future release.');\n        return new PassthroughLoader({\n            modelTopology: modelArtifacts,\n            weightSpecs,\n            weightData,\n            trainingConfig\n        });\n    }\n}\n/**\n * Creates an IOHandler that passes saved model artifacts to a callback.\n *\n * ```js\n * function handleSave(artifacts) {\n *   // ... do something with the artifacts ...\n *   return {modelArtifactsInfo: {...}, ...};\n * }\n *\n * const saveResult = model.save(tf.io.withSaveHandler(handleSave));\n * ```\n *\n * @param saveHandler A function that accepts a `ModelArtifacts` and returns a\n *     promise that resolves to a `SaveResult`.\n */\nexport function withSaveHandler(saveHandler) {\n    return new PassthroughSaver(saveHandler);\n}\n/**\n * Creates an IOHandlerSync that passes saved model artifacts to a callback.\n *\n * ```js\n * function handleSave(artifacts) {\n *   // ... do something with the artifacts ...\n *   return {modelArtifactsInfo: {...}, ...};\n * }\n *\n * const saveResult = model.save(tf.io.withSaveHandler(handleSave));\n * ```\n *\n * @param saveHandler A function that accepts a `ModelArtifacts` and returns a\n *     `SaveResult`.\n */\nexport function withSaveHandlerSync(saveHandler) {\n    return new PassthroughSaver(saveHandler);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}