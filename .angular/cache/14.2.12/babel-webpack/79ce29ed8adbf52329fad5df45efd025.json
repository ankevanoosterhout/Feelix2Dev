{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { computeStrides, isString, rightPad, sizeFromShape } from './util'; // Maximum number of values before we decide to show ellipsis.\n\nconst FORMAT_LIMIT_NUM_VALS = 20; // Number of first and last values to show when displaying a, b,...,y, z.\n\nconst FORMAT_NUM_FIRST_LAST_VALS = 3; // Number of significant digits to show.\n\nconst FORMAT_NUM_SIG_DIGITS = 7;\nexport function tensorToString(vals, shape, dtype, verbose) {\n  const strides = computeStrides(shape);\n  const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);\n  const rank = shape.length;\n  const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);\n  const lines = ['Tensor'];\n\n  if (verbose) {\n    lines.push(`  dtype: ${dtype}`);\n    lines.push(`  rank: ${rank}`);\n    lines.push(`  shape: [${shape}]`);\n    lines.push(`  values:`);\n  }\n\n  lines.push(valsLines.map(l => '    ' + l).join('\\n'));\n  return lines.join('\\n');\n}\n\nfunction computeMaxSizePerColumn(vals, shape, dtype, strides) {\n  const n = sizeFromShape(shape);\n  const numCols = strides[strides.length - 1];\n  const padPerCol = new Array(numCols).fill(0);\n  const rank = shape.length;\n  const valuesOrTuples = dtype === 'complex64' ? createComplexTuples(vals) : vals;\n\n  if (rank > 1) {\n    for (let row = 0; row < n / numCols; row++) {\n      const offset = row * numCols;\n\n      for (let j = 0; j < numCols; j++) {\n        padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);\n      }\n    }\n  }\n\n  return padPerCol;\n}\n\nfunction valToString(val, pad, dtype) {\n  let valStr;\n\n  if (Array.isArray(val)) {\n    valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ` + `${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;\n  } else if (isString(val)) {\n    valStr = `'${val}'`;\n  } else if (dtype === 'bool') {\n    valStr = boolNumToString(val);\n  } else {\n    valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();\n  }\n\n  return rightPad(valStr, pad);\n}\n\nfunction boolNumToString(v) {\n  return v === 0 ? 'false' : 'true';\n}\n\nfunction subTensorToString(vals, shape, dtype, strides, padPerCol, isLast = true) {\n  const storagePerElement = dtype === 'complex64' ? 2 : 1;\n  const size = shape[0];\n  const rank = shape.length;\n\n  if (rank === 0) {\n    if (dtype === 'complex64') {\n      const complexTuple = createComplexTuples(vals);\n      return [valToString(complexTuple[0], 0, dtype)];\n    }\n\n    if (dtype === 'bool') {\n      return [boolNumToString(vals[0])];\n    }\n\n    return [vals[0].toString()];\n  }\n\n  if (rank === 1) {\n    if (size > FORMAT_LIMIT_NUM_VALS) {\n      const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;\n      let firstVals = Array.from(vals.slice(0, firstValsSize));\n      let lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));\n\n      if (dtype === 'complex64') {\n        firstVals = createComplexTuples(firstVals);\n        lastVals = createComplexTuples(lastVals);\n      }\n\n      return ['[' + firstVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(', ') + ', ..., ' + lastVals.map((x, i) => valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype)).join(', ') + ']'];\n    }\n\n    const displayVals = dtype === 'complex64' ? createComplexTuples(vals) : Array.from(vals);\n    return ['[' + displayVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(', ') + ']'];\n  } // The array is rank 2 or more.\n\n\n  const subshape = shape.slice(1);\n  const substrides = strides.slice(1);\n  const stride = strides[0] * storagePerElement;\n  const lines = [];\n\n  if (size > FORMAT_LIMIT_NUM_VALS) {\n    for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false\n      /* isLast */\n      ));\n    }\n\n    lines.push('...');\n\n    for (let i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1\n      /* isLast */\n      ));\n    }\n  } else {\n    for (let i = 0; i < size; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1\n      /* isLast */\n      ));\n    }\n  }\n\n  const sep = rank === 2 ? ',' : '';\n  lines[0] = '[' + lines[0] + sep;\n\n  for (let i = 1; i < lines.length - 1; i++) {\n    lines[i] = ' ' + lines[i] + sep;\n  }\n\n  let newLineSep = ',\\n';\n\n  for (let i = 2; i < rank; i++) {\n    newLineSep += '\\n';\n  }\n\n  lines[lines.length - 1] = ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);\n  return lines;\n}\n\nfunction createComplexTuples(vals) {\n  const complexTuples = [];\n\n  for (let i = 0; i < vals.length; i += 2) {\n    complexTuples.push([vals[i], vals[i + 1]]);\n  }\n\n  return complexTuples;\n}","map":{"version":3,"names":["computeStrides","isString","rightPad","sizeFromShape","FORMAT_LIMIT_NUM_VALS","FORMAT_NUM_FIRST_LAST_VALS","FORMAT_NUM_SIG_DIGITS","tensorToString","vals","shape","dtype","verbose","strides","padPerCol","computeMaxSizePerColumn","rank","length","valsLines","subTensorToString","lines","push","map","l","join","n","numCols","Array","fill","valuesOrTuples","createComplexTuples","row","offset","j","Math","max","valToString","val","pad","valStr","isArray","parseFloat","toFixed","boolNumToString","toString","v","isLast","storagePerElement","size","complexTuple","firstValsSize","firstVals","from","slice","lastVals","x","i","displayVals","subshape","substrides","stride","start","end","sep","newLineSep","complexTuples"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-core/dist/tensor_format.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { computeStrides, isString, rightPad, sizeFromShape } from './util';\n// Maximum number of values before we decide to show ellipsis.\nconst FORMAT_LIMIT_NUM_VALS = 20;\n// Number of first and last values to show when displaying a, b,...,y, z.\nconst FORMAT_NUM_FIRST_LAST_VALS = 3;\n// Number of significant digits to show.\nconst FORMAT_NUM_SIG_DIGITS = 7;\nexport function tensorToString(vals, shape, dtype, verbose) {\n    const strides = computeStrides(shape);\n    const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);\n    const rank = shape.length;\n    const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);\n    const lines = ['Tensor'];\n    if (verbose) {\n        lines.push(`  dtype: ${dtype}`);\n        lines.push(`  rank: ${rank}`);\n        lines.push(`  shape: [${shape}]`);\n        lines.push(`  values:`);\n    }\n    lines.push(valsLines.map(l => '    ' + l).join('\\n'));\n    return lines.join('\\n');\n}\nfunction computeMaxSizePerColumn(vals, shape, dtype, strides) {\n    const n = sizeFromShape(shape);\n    const numCols = strides[strides.length - 1];\n    const padPerCol = new Array(numCols).fill(0);\n    const rank = shape.length;\n    const valuesOrTuples = dtype === 'complex64' ? createComplexTuples(vals) : vals;\n    if (rank > 1) {\n        for (let row = 0; row < n / numCols; row++) {\n            const offset = row * numCols;\n            for (let j = 0; j < numCols; j++) {\n                padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);\n            }\n        }\n    }\n    return padPerCol;\n}\nfunction valToString(val, pad, dtype) {\n    let valStr;\n    if (Array.isArray(val)) {\n        valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ` +\n            `${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;\n    }\n    else if (isString(val)) {\n        valStr = `'${val}'`;\n    }\n    else if (dtype === 'bool') {\n        valStr = boolNumToString(val);\n    }\n    else {\n        valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();\n    }\n    return rightPad(valStr, pad);\n}\nfunction boolNumToString(v) {\n    return v === 0 ? 'false' : 'true';\n}\nfunction subTensorToString(vals, shape, dtype, strides, padPerCol, isLast = true) {\n    const storagePerElement = dtype === 'complex64' ? 2 : 1;\n    const size = shape[0];\n    const rank = shape.length;\n    if (rank === 0) {\n        if (dtype === 'complex64') {\n            const complexTuple = createComplexTuples(vals);\n            return [valToString(complexTuple[0], 0, dtype)];\n        }\n        if (dtype === 'bool') {\n            return [boolNumToString(vals[0])];\n        }\n        return [vals[0].toString()];\n    }\n    if (rank === 1) {\n        if (size > FORMAT_LIMIT_NUM_VALS) {\n            const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;\n            let firstVals = Array.from(vals.slice(0, firstValsSize));\n            let lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));\n            if (dtype === 'complex64') {\n                firstVals = createComplexTuples(firstVals);\n                lastVals = createComplexTuples(lastVals);\n            }\n            return [\n                '[' +\n                    firstVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n                        .join(', ') +\n                    ', ..., ' +\n                    lastVals\n                        .map((x, i) => valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype))\n                        .join(', ') +\n                    ']'\n            ];\n        }\n        const displayVals = dtype === 'complex64' ? createComplexTuples(vals) :\n            Array.from(vals);\n        return [\n            '[' +\n                displayVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n                    .join(', ') +\n                ']'\n        ];\n    }\n    // The array is rank 2 or more.\n    const subshape = shape.slice(1);\n    const substrides = strides.slice(1);\n    const stride = strides[0] * storagePerElement;\n    const lines = [];\n    if (size > FORMAT_LIMIT_NUM_VALS) {\n        for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {\n            const start = i * stride;\n            const end = start + stride;\n            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false /* isLast */));\n        }\n        lines.push('...');\n        for (let i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {\n            const start = i * stride;\n            const end = start + stride;\n            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1 /* isLast */));\n        }\n    }\n    else {\n        for (let i = 0; i < size; i++) {\n            const start = i * stride;\n            const end = start + stride;\n            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1 /* isLast */));\n        }\n    }\n    const sep = rank === 2 ? ',' : '';\n    lines[0] = '[' + lines[0] + sep;\n    for (let i = 1; i < lines.length - 1; i++) {\n        lines[i] = ' ' + lines[i] + sep;\n    }\n    let newLineSep = ',\\n';\n    for (let i = 2; i < rank; i++) {\n        newLineSep += '\\n';\n    }\n    lines[lines.length - 1] =\n        ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);\n    return lines;\n}\nfunction createComplexTuples(vals) {\n    const complexTuples = [];\n    for (let i = 0; i < vals.length; i += 2) {\n        complexTuples.push([vals[i], vals[i + 1]]);\n    }\n    return complexTuples;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}