{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport * as tensorflow from '../data/compiled_api';\nimport { getRegisteredOp } from './custom_op/register';\nimport { getNodeNameAndIndex } from './executors/utils';\nimport * as arithmetic from './op_list/arithmetic';\nimport * as basicMath from './op_list/basic_math';\nimport * as control from './op_list/control';\nimport * as convolution from './op_list/convolution';\nimport * as creation from './op_list/creation';\nimport * as dynamic from './op_list/dynamic';\nimport * as evaluation from './op_list/evaluation';\nimport * as graph from './op_list/graph';\nimport * as hashTable from './op_list/hash_table';\nimport * as image from './op_list/image';\nimport * as logical from './op_list/logical';\nimport * as matrices from './op_list/matrices';\nimport * as normalization from './op_list/normalization';\nimport * as reduction from './op_list/reduction';\nimport * as sliceJoin from './op_list/slice_join';\nimport * as sparse from './op_list/sparse';\nimport * as spectral from './op_list/spectral';\nimport * as string from './op_list/string';\nimport * as transformation from './op_list/transformation';\nexport class OperationMapper {\n  // Singleton instance for the mapper\n  static get Instance() {\n    return this._instance || (this._instance = new this());\n  } // Loads the op mapping from the JSON file.\n\n\n  constructor() {\n    const ops = [arithmetic, basicMath, control, convolution, creation, dynamic, evaluation, graph, hashTable, image, logical, matrices, normalization, reduction, sliceJoin, sparse, spectral, string, transformation];\n    const mappersJson = [].concat(...ops.map(op => op.json));\n    this.opMappers = mappersJson.reduce((map, mapper) => {\n      map[mapper.tfOpName] = mapper;\n      return map;\n    }, {});\n  } // Converts the model inference graph from Tensorflow GraphDef to local\n  // representation for TensorFlow.js API\n\n\n  transformGraph(graph, signature = {}) {\n    const tfNodes = graph.node;\n    const placeholders = [];\n    const weights = [];\n    const initNodes = [];\n    const nodes = tfNodes.reduce((map, node) => {\n      map[node.name] = this.mapNode(node);\n\n      if (node.op.startsWith('Placeholder')) {\n        placeholders.push(map[node.name]);\n      } else if (node.op === 'Const') {\n        weights.push(map[node.name]);\n      } else if (node.input == null || node.input.length === 0) {\n        initNodes.push(map[node.name]);\n      }\n\n      return map;\n    }, {});\n    let inputs = [];\n    const outputs = [];\n    let inputNodeNameToKey = {};\n    let outputNodeNameToKey = {};\n\n    if (signature != null) {\n      inputNodeNameToKey = this.mapSignatureEntries(signature.inputs);\n      outputNodeNameToKey = this.mapSignatureEntries(signature.outputs);\n    }\n\n    const allNodes = Object.keys(nodes);\n    allNodes.forEach(key => {\n      const node = nodes[key];\n      node.inputNames.forEach((name, index) => {\n        const [nodeName,, outputName] = getNodeNameAndIndex(name);\n        const inputNode = nodes[nodeName];\n\n        if (inputNode.outputs != null) {\n          const outputIndex = inputNode.outputs.indexOf(outputName);\n\n          if (outputIndex !== -1) {\n            const inputName = `${nodeName}:${outputIndex}`; // update the input name to use the mapped output index directly.\n\n            node.inputNames[index] = inputName;\n          }\n        }\n\n        node.inputs.push(inputNode);\n        inputNode.children.push(node);\n      });\n    }); // if signature has not outputs set, add any node that does not have\n    // outputs.\n\n    if (Object.keys(outputNodeNameToKey).length === 0) {\n      allNodes.forEach(key => {\n        const node = nodes[key];\n\n        if (node.children.length === 0) {\n          outputs.push(node);\n        }\n      });\n    } else {\n      Object.keys(outputNodeNameToKey).forEach(name => {\n        const [nodeName] = getNodeNameAndIndex(name);\n        const node = nodes[nodeName];\n\n        if (node != null) {\n          node.signatureKey = outputNodeNameToKey[name];\n          outputs.push(node);\n        }\n      });\n    }\n\n    if (Object.keys(inputNodeNameToKey).length > 0) {\n      Object.keys(inputNodeNameToKey).forEach(name => {\n        const [nodeName] = getNodeNameAndIndex(name);\n        const node = nodes[nodeName];\n\n        if (node) {\n          node.signatureKey = inputNodeNameToKey[name];\n          inputs.push(node);\n        }\n      });\n    } else {\n      inputs = placeholders;\n    }\n\n    let functions = {};\n\n    if (graph.library != null && graph.library.function != null) {\n      functions = graph.library.function.reduce((functions, func) => {\n        functions[func.signature.name] = this.mapFunction(func);\n        return functions;\n      }, {});\n    }\n\n    const result = {\n      nodes,\n      inputs,\n      outputs,\n      weights,\n      placeholders,\n      signature,\n      functions\n    };\n\n    if (initNodes.length > 0) {\n      result.initNodes = initNodes;\n    }\n\n    return result;\n  }\n\n  mapSignatureEntries(entries) {\n    return Object.keys(entries || {}).reduce((prev, curr) => {\n      prev[entries[curr].name] = curr;\n      return prev;\n    }, {});\n  }\n\n  mapNode(node) {\n    // Unsupported ops will cause an error at run-time (not parse time), since\n    // they may not be used by the actual execution subgraph.\n    const mapper = getRegisteredOp(node.op) || this.opMappers[node.op] || {};\n\n    if (node.attr == null) {\n      node.attr = {};\n    }\n\n    const newNode = {\n      name: node.name,\n      op: node.op,\n      category: mapper.category,\n      inputNames: (node.input || []).map(input => input.startsWith('^') ? input.slice(1) : input),\n      inputs: [],\n      children: [],\n      inputParams: {},\n      attrParams: {},\n      rawAttrs: node.attr,\n      outputs: mapper.outputs\n    };\n\n    if (mapper.inputs != null) {\n      newNode.inputParams = mapper.inputs.reduce((map, param) => {\n        map[param.name] = {\n          type: param.type,\n          inputIndexStart: param.start,\n          inputIndexEnd: param.end\n        };\n        return map;\n      }, {});\n    }\n\n    if (mapper.attrs != null) {\n      newNode.attrParams = mapper.attrs.reduce((map, param) => {\n        const type = param.type;\n        let value = undefined;\n\n        switch (param.type) {\n          case 'string':\n            value = getStringParam(node.attr, param.tfName, param.defaultValue);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getStringParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'string[]':\n            value = getStringArrayParam(node.attr, param.tfName, param.defaultValue);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getStringArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'number':\n            value = getNumberParam(node.attr, param.tfName, param.defaultValue || 0);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getNumberParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'number[]':\n            value = getNumericArrayParam(node.attr, param.tfName, param.defaultValue);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getNumericArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'bool':\n            value = getBoolParam(node.attr, param.tfName, param.defaultValue);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getBoolParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'bool[]':\n            value = getBoolArrayParam(node.attr, param.tfName, param.defaultValue);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getBoolArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'shape':\n            value = getTensorShapeParam(node.attr, param.tfName, param.defaultValue);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getTensorShapeParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'shape[]':\n            value = getTensorShapeArrayParam(node.attr, param.tfName, param.defaultValue);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getTensorShapeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'dtype':\n            value = getDtypeParam(node.attr, param.tfName, param.defaultValue);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getDtypeParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'dtype[]':\n            value = getDtypeArrayParam(node.attr, param.tfName, param.defaultValue);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getDtypeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'func':\n            value = getFuncParam(node.attr, param.tfName, param.defaultValue);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getFuncParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'tensor':\n          case 'tensors':\n            break;\n\n          default:\n            throw new Error(`Unsupported param type: ${param.type} for op: ${node.op}`);\n        }\n\n        map[param.name] = {\n          value,\n          type\n        };\n        return map;\n      }, {});\n    }\n\n    return newNode;\n  } // map the TFunctionDef to TFJS graph object\n\n\n  mapFunction(functionDef) {\n    const tfNodes = functionDef.nodeDef;\n    const placeholders = [];\n    const weights = [];\n    let nodes = {};\n\n    if (tfNodes != null) {\n      nodes = tfNodes.reduce((map, node) => {\n        map[node.name] = this.mapNode(node);\n\n        if (node.op === 'Const') {\n          weights.push(map[node.name]);\n        }\n\n        return map;\n      }, {});\n    }\n\n    const inputs = [];\n    const outputs = [];\n    functionDef.signature.inputArg.forEach(arg => {\n      const [nodeName] = getNodeNameAndIndex(arg.name);\n      const node = {\n        name: nodeName,\n        op: 'Placeholder',\n        inputs: [],\n        inputNames: [],\n        category: 'graph',\n        inputParams: {},\n        attrParams: {\n          dtype: {\n            value: parseDtypeParam(arg.type),\n            type: 'dtype'\n          }\n        },\n        children: []\n      };\n      node.signatureKey = arg.name;\n      inputs.push(node);\n      nodes[nodeName] = node;\n    });\n    const allNodes = Object.keys(nodes);\n    allNodes.forEach(key => {\n      const node = nodes[key];\n      node.inputNames.forEach((name, index) => {\n        const [nodeName,, outputName] = getNodeNameAndIndex(name);\n        const inputNode = nodes[nodeName];\n\n        if (inputNode.outputs != null) {\n          const outputIndex = inputNode.outputs.indexOf(outputName);\n\n          if (outputIndex !== -1) {\n            const inputName = `${nodeName}:${outputIndex}`; // update the input name to use the mapped output index directly.\n\n            node.inputNames[index] = inputName;\n          }\n        }\n\n        node.inputs.push(inputNode);\n        inputNode.children.push(node);\n      });\n    });\n    const returnNodeMap = functionDef.ret;\n    functionDef.signature.outputArg.forEach(output => {\n      const [nodeName, index] = getNodeNameAndIndex(returnNodeMap[output.name]);\n      const node = nodes[nodeName];\n\n      if (node != null) {\n        node.defaultOutput = index;\n        outputs.push(node);\n      }\n    });\n    const signature = this.mapArgsToSignature(functionDef);\n    return {\n      nodes,\n      inputs,\n      outputs,\n      weights,\n      placeholders,\n      signature\n    };\n  }\n\n  mapArgsToSignature(functionDef) {\n    return {\n      methodName: functionDef.signature.name,\n      inputs: functionDef.signature.inputArg.reduce((map, arg) => {\n        map[arg.name] = this.mapArgToTensorInfo(arg);\n        return map;\n      }, {}),\n      outputs: functionDef.signature.outputArg.reduce((map, arg) => {\n        map[arg.name] = this.mapArgToTensorInfo(arg, functionDef.ret);\n        return map;\n      }, {})\n    };\n  }\n\n  mapArgToTensorInfo(arg, nameMap) {\n    let name = arg.name;\n\n    if (nameMap != null) {\n      name = nameMap[name];\n    }\n\n    return {\n      name,\n      dtype: arg.type\n    };\n  }\n\n}\nexport function decodeBase64(text) {\n  const global = env().global;\n\n  if (typeof global.atob !== 'undefined') {\n    return global.atob(text);\n  } else if (typeof Buffer !== 'undefined') {\n    return new Buffer(text, 'base64').toString();\n  } else {\n    throw new Error('Unable to decode base64 in this environment. ' + 'Missing built-in atob() or Buffer()');\n  }\n}\nexport function parseStringParam(s, keepCase) {\n  const value = Array.isArray(s) ? String.fromCharCode.apply(null, s) : decodeBase64(s);\n  return keepCase ? value : value.toLowerCase();\n}\nexport function getStringParam(attrs, name, def, keepCase = false) {\n  const param = attrs[name];\n\n  if (param != null) {\n    return parseStringParam(param.s, keepCase);\n  }\n\n  return def;\n}\nexport function getBoolParam(attrs, name, def) {\n  const param = attrs[name];\n  return param ? param.b : def;\n}\nexport function getNumberParam(attrs, name, def) {\n  const param = attrs[name] || {};\n  const value = param['i'] != null ? param['i'] : param['f'] != null ? param['f'] : def;\n  return typeof value === 'number' ? value : parseInt(value, 10);\n}\nexport function parseDtypeParam(value) {\n  if (typeof value === 'string') {\n    // tslint:disable-next-line:no-any\n    value = tensorflow.DataType[value];\n  }\n\n  switch (value) {\n    case tensorflow.DataType.DT_FLOAT:\n    case tensorflow.DataType.DT_HALF:\n      return 'float32';\n\n    case tensorflow.DataType.DT_INT32:\n    case tensorflow.DataType.DT_INT64:\n    case tensorflow.DataType.DT_INT8:\n    case tensorflow.DataType.DT_UINT8:\n      return 'int32';\n\n    case tensorflow.DataType.DT_BOOL:\n      return 'bool';\n\n    case tensorflow.DataType.DT_DOUBLE:\n      return 'float32';\n\n    case tensorflow.DataType.DT_STRING:\n      return 'string';\n\n    default:\n      // Unknown dtype error will happen at runtime (instead of parse time),\n      // since these nodes might not be used by the actual subgraph execution.\n      return null;\n  }\n}\nexport function getFuncParam(attrs, name, def) {\n  const param = attrs[name];\n\n  if (param && param.func) {\n    return param.func.name;\n  }\n\n  return def;\n}\nexport function getDtypeParam(attrs, name, def) {\n  const param = attrs[name];\n\n  if (param && param.type) {\n    return parseDtypeParam(param.type);\n  }\n\n  return def;\n}\nexport function getDtypeArrayParam(attrs, name, def) {\n  const param = attrs[name];\n\n  if (param && param.list && param.list.type) {\n    return param.list.type.map(v => parseDtypeParam(v));\n  }\n\n  return def;\n}\nexport function parseTensorShapeParam(shape) {\n  if (shape.unknownRank) {\n    return undefined;\n  }\n\n  if (shape.dim != null) {\n    return shape.dim.map(dim => typeof dim.size === 'number' ? dim.size : parseInt(dim.size, 10));\n  }\n\n  return [];\n}\nexport function getTensorShapeParam(attrs, name, def) {\n  const param = attrs[name];\n\n  if (param && param.shape) {\n    return parseTensorShapeParam(param.shape);\n  }\n\n  return def;\n}\nexport function getNumericArrayParam(attrs, name, def) {\n  const param = attrs[name];\n\n  if (param) {\n    return ((param.list.f && param.list.f.length ? param.list.f : param.list.i) || []).map(v => typeof v === 'number' ? v : parseInt(v, 10));\n  }\n\n  return def;\n}\nexport function getStringArrayParam(attrs, name, def, keepCase = false) {\n  const param = attrs[name];\n\n  if (param && param.list && param.list.s) {\n    return param.list.s.map(v => {\n      return parseStringParam(v, keepCase);\n    });\n  }\n\n  return def;\n}\nexport function getTensorShapeArrayParam(attrs, name, def) {\n  const param = attrs[name];\n\n  if (param && param.list && param.list.shape) {\n    return param.list.shape.map(v => {\n      return parseTensorShapeParam(v);\n    });\n  }\n\n  return def;\n}\nexport function getBoolArrayParam(attrs, name, def) {\n  const param = attrs[name];\n\n  if (param && param.list && param.list.b) {\n    return param.list.b;\n  }\n\n  return def;\n}","map":{"version":3,"names":["env","tensorflow","getRegisteredOp","getNodeNameAndIndex","arithmetic","basicMath","control","convolution","creation","dynamic","evaluation","graph","hashTable","image","logical","matrices","normalization","reduction","sliceJoin","sparse","spectral","string","transformation","OperationMapper","Instance","_instance","constructor","ops","mappersJson","concat","map","op","json","opMappers","reduce","mapper","tfOpName","transformGraph","signature","tfNodes","node","placeholders","weights","initNodes","nodes","name","mapNode","startsWith","push","input","length","inputs","outputs","inputNodeNameToKey","outputNodeNameToKey","mapSignatureEntries","allNodes","Object","keys","forEach","key","inputNames","index","nodeName","outputName","inputNode","outputIndex","indexOf","inputName","children","signatureKey","functions","library","function","func","mapFunction","result","entries","prev","curr","attr","newNode","category","slice","inputParams","attrParams","rawAttrs","param","type","inputIndexStart","start","inputIndexEnd","end","attrs","value","undefined","getStringParam","tfName","defaultValue","tfDeprecatedName","getStringArrayParam","getNumberParam","getNumericArrayParam","getBoolParam","getBoolArrayParam","getTensorShapeParam","getTensorShapeArrayParam","getDtypeParam","getDtypeArrayParam","getFuncParam","Error","functionDef","nodeDef","inputArg","arg","dtype","parseDtypeParam","returnNodeMap","ret","outputArg","output","defaultOutput","mapArgsToSignature","methodName","mapArgToTensorInfo","nameMap","decodeBase64","text","global","atob","Buffer","toString","parseStringParam","s","keepCase","Array","isArray","String","fromCharCode","apply","toLowerCase","def","b","parseInt","DataType","DT_FLOAT","DT_HALF","DT_INT32","DT_INT64","DT_INT8","DT_UINT8","DT_BOOL","DT_DOUBLE","DT_STRING","list","v","parseTensorShapeParam","shape","unknownRank","dim","size","f","i"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-converter/dist/operations/operation_mapper.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport * as tensorflow from '../data/compiled_api';\nimport { getRegisteredOp } from './custom_op/register';\nimport { getNodeNameAndIndex } from './executors/utils';\nimport * as arithmetic from './op_list/arithmetic';\nimport * as basicMath from './op_list/basic_math';\nimport * as control from './op_list/control';\nimport * as convolution from './op_list/convolution';\nimport * as creation from './op_list/creation';\nimport * as dynamic from './op_list/dynamic';\nimport * as evaluation from './op_list/evaluation';\nimport * as graph from './op_list/graph';\nimport * as hashTable from './op_list/hash_table';\nimport * as image from './op_list/image';\nimport * as logical from './op_list/logical';\nimport * as matrices from './op_list/matrices';\nimport * as normalization from './op_list/normalization';\nimport * as reduction from './op_list/reduction';\nimport * as sliceJoin from './op_list/slice_join';\nimport * as sparse from './op_list/sparse';\nimport * as spectral from './op_list/spectral';\nimport * as string from './op_list/string';\nimport * as transformation from './op_list/transformation';\nexport class OperationMapper {\n    // Singleton instance for the mapper\n    static get Instance() {\n        return this._instance || (this._instance = new this());\n    }\n    // Loads the op mapping from the JSON file.\n    constructor() {\n        const ops = [\n            arithmetic, basicMath, control, convolution, creation, dynamic,\n            evaluation, graph, hashTable, image, logical, matrices, normalization,\n            reduction, sliceJoin, sparse, spectral, string, transformation\n        ];\n        const mappersJson = [].concat(...ops.map(op => op.json));\n        this.opMappers = mappersJson.reduce((map, mapper) => {\n            map[mapper.tfOpName] = mapper;\n            return map;\n        }, {});\n    }\n    // Converts the model inference graph from Tensorflow GraphDef to local\n    // representation for TensorFlow.js API\n    transformGraph(graph, signature = {}) {\n        const tfNodes = graph.node;\n        const placeholders = [];\n        const weights = [];\n        const initNodes = [];\n        const nodes = tfNodes.reduce((map, node) => {\n            map[node.name] = this.mapNode(node);\n            if (node.op.startsWith('Placeholder')) {\n                placeholders.push(map[node.name]);\n            }\n            else if (node.op === 'Const') {\n                weights.push(map[node.name]);\n            }\n            else if (node.input == null || node.input.length === 0) {\n                initNodes.push(map[node.name]);\n            }\n            return map;\n        }, {});\n        let inputs = [];\n        const outputs = [];\n        let inputNodeNameToKey = {};\n        let outputNodeNameToKey = {};\n        if (signature != null) {\n            inputNodeNameToKey = this.mapSignatureEntries(signature.inputs);\n            outputNodeNameToKey = this.mapSignatureEntries(signature.outputs);\n        }\n        const allNodes = Object.keys(nodes);\n        allNodes.forEach(key => {\n            const node = nodes[key];\n            node.inputNames.forEach((name, index) => {\n                const [nodeName, , outputName] = getNodeNameAndIndex(name);\n                const inputNode = nodes[nodeName];\n                if (inputNode.outputs != null) {\n                    const outputIndex = inputNode.outputs.indexOf(outputName);\n                    if (outputIndex !== -1) {\n                        const inputName = `${nodeName}:${outputIndex}`;\n                        // update the input name to use the mapped output index directly.\n                        node.inputNames[index] = inputName;\n                    }\n                }\n                node.inputs.push(inputNode);\n                inputNode.children.push(node);\n            });\n        });\n        // if signature has not outputs set, add any node that does not have\n        // outputs.\n        if (Object.keys(outputNodeNameToKey).length === 0) {\n            allNodes.forEach(key => {\n                const node = nodes[key];\n                if (node.children.length === 0) {\n                    outputs.push(node);\n                }\n            });\n        }\n        else {\n            Object.keys(outputNodeNameToKey).forEach(name => {\n                const [nodeName,] = getNodeNameAndIndex(name);\n                const node = nodes[nodeName];\n                if (node != null) {\n                    node.signatureKey = outputNodeNameToKey[name];\n                    outputs.push(node);\n                }\n            });\n        }\n        if (Object.keys(inputNodeNameToKey).length > 0) {\n            Object.keys(inputNodeNameToKey).forEach(name => {\n                const [nodeName,] = getNodeNameAndIndex(name);\n                const node = nodes[nodeName];\n                if (node) {\n                    node.signatureKey = inputNodeNameToKey[name];\n                    inputs.push(node);\n                }\n            });\n        }\n        else {\n            inputs = placeholders;\n        }\n        let functions = {};\n        if (graph.library != null && graph.library.function != null) {\n            functions = graph.library.function.reduce((functions, func) => {\n                functions[func.signature.name] = this.mapFunction(func);\n                return functions;\n            }, {});\n        }\n        const result = { nodes, inputs, outputs, weights, placeholders, signature, functions };\n        if (initNodes.length > 0) {\n            result.initNodes = initNodes;\n        }\n        return result;\n    }\n    mapSignatureEntries(entries) {\n        return Object.keys(entries || {})\n            .reduce((prev, curr) => {\n            prev[entries[curr].name] = curr;\n            return prev;\n        }, {});\n    }\n    mapNode(node) {\n        // Unsupported ops will cause an error at run-time (not parse time), since\n        // they may not be used by the actual execution subgraph.\n        const mapper = getRegisteredOp(node.op) || this.opMappers[node.op] || {};\n        if (node.attr == null) {\n            node.attr = {};\n        }\n        const newNode = {\n            name: node.name,\n            op: node.op,\n            category: mapper.category,\n            inputNames: (node.input ||\n                []).map(input => input.startsWith('^') ? input.slice(1) : input),\n            inputs: [],\n            children: [],\n            inputParams: {},\n            attrParams: {},\n            rawAttrs: node.attr,\n            outputs: mapper.outputs\n        };\n        if (mapper.inputs != null) {\n            newNode.inputParams =\n                mapper.inputs.reduce((map, param) => {\n                    map[param.name] = {\n                        type: param.type,\n                        inputIndexStart: param.start,\n                        inputIndexEnd: param.end\n                    };\n                    return map;\n                }, {});\n        }\n        if (mapper.attrs != null) {\n            newNode.attrParams =\n                mapper.attrs.reduce((map, param) => {\n                    const type = param.type;\n                    let value = undefined;\n                    switch (param.type) {\n                        case 'string':\n                            value = getStringParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getStringParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'string[]':\n                            value = getStringArrayParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getStringArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'number':\n                            value = getNumberParam(node.attr, param.tfName, (param.defaultValue || 0));\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getNumberParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'number[]':\n                            value = getNumericArrayParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getNumericArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'bool':\n                            value = getBoolParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getBoolParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'bool[]':\n                            value = getBoolArrayParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getBoolArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'shape':\n                            value = getTensorShapeParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getTensorShapeParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'shape[]':\n                            value = getTensorShapeArrayParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getTensorShapeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'dtype':\n                            value = getDtypeParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getDtypeParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'dtype[]':\n                            value = getDtypeArrayParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getDtypeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'func':\n                            value = getFuncParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getFuncParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'tensor':\n                        case 'tensors':\n                            break;\n                        default:\n                            throw new Error(`Unsupported param type: ${param.type} for op: ${node.op}`);\n                    }\n                    map[param.name] = { value, type };\n                    return map;\n                }, {});\n        }\n        return newNode;\n    }\n    // map the TFunctionDef to TFJS graph object\n    mapFunction(functionDef) {\n        const tfNodes = functionDef.nodeDef;\n        const placeholders = [];\n        const weights = [];\n        let nodes = {};\n        if (tfNodes != null) {\n            nodes = tfNodes.reduce((map, node) => {\n                map[node.name] = this.mapNode(node);\n                if (node.op === 'Const') {\n                    weights.push(map[node.name]);\n                }\n                return map;\n            }, {});\n        }\n        const inputs = [];\n        const outputs = [];\n        functionDef.signature.inputArg.forEach(arg => {\n            const [nodeName,] = getNodeNameAndIndex(arg.name);\n            const node = {\n                name: nodeName,\n                op: 'Placeholder',\n                inputs: [],\n                inputNames: [],\n                category: 'graph',\n                inputParams: {},\n                attrParams: { dtype: { value: parseDtypeParam(arg.type), type: 'dtype' } },\n                children: []\n            };\n            node.signatureKey = arg.name;\n            inputs.push(node);\n            nodes[nodeName] = node;\n        });\n        const allNodes = Object.keys(nodes);\n        allNodes.forEach(key => {\n            const node = nodes[key];\n            node.inputNames.forEach((name, index) => {\n                const [nodeName, , outputName] = getNodeNameAndIndex(name);\n                const inputNode = nodes[nodeName];\n                if (inputNode.outputs != null) {\n                    const outputIndex = inputNode.outputs.indexOf(outputName);\n                    if (outputIndex !== -1) {\n                        const inputName = `${nodeName}:${outputIndex}`;\n                        // update the input name to use the mapped output index directly.\n                        node.inputNames[index] = inputName;\n                    }\n                }\n                node.inputs.push(inputNode);\n                inputNode.children.push(node);\n            });\n        });\n        const returnNodeMap = functionDef.ret;\n        functionDef.signature.outputArg.forEach(output => {\n            const [nodeName, index] = getNodeNameAndIndex(returnNodeMap[output.name]);\n            const node = nodes[nodeName];\n            if (node != null) {\n                node.defaultOutput = index;\n                outputs.push(node);\n            }\n        });\n        const signature = this.mapArgsToSignature(functionDef);\n        return { nodes, inputs, outputs, weights, placeholders, signature };\n    }\n    mapArgsToSignature(functionDef) {\n        return {\n            methodName: functionDef.signature.name,\n            inputs: functionDef.signature.inputArg.reduce((map, arg) => {\n                map[arg.name] = this.mapArgToTensorInfo(arg);\n                return map;\n            }, {}),\n            outputs: functionDef.signature.outputArg.reduce((map, arg) => {\n                map[arg.name] = this.mapArgToTensorInfo(arg, functionDef.ret);\n                return map;\n            }, {}),\n        };\n    }\n    mapArgToTensorInfo(arg, nameMap) {\n        let name = arg.name;\n        if (nameMap != null) {\n            name = nameMap[name];\n        }\n        return { name, dtype: arg.type };\n    }\n}\nexport function decodeBase64(text) {\n    const global = env().global;\n    if (typeof global.atob !== 'undefined') {\n        return global.atob(text);\n    }\n    else if (typeof Buffer !== 'undefined') {\n        return new Buffer(text, 'base64').toString();\n    }\n    else {\n        throw new Error('Unable to decode base64 in this environment. ' +\n            'Missing built-in atob() or Buffer()');\n    }\n}\nexport function parseStringParam(s, keepCase) {\n    const value = Array.isArray(s) ? String.fromCharCode.apply(null, s) : decodeBase64(s);\n    return keepCase ? value : value.toLowerCase();\n}\nexport function getStringParam(attrs, name, def, keepCase = false) {\n    const param = attrs[name];\n    if (param != null) {\n        return parseStringParam(param.s, keepCase);\n    }\n    return def;\n}\nexport function getBoolParam(attrs, name, def) {\n    const param = attrs[name];\n    return param ? param.b : def;\n}\nexport function getNumberParam(attrs, name, def) {\n    const param = attrs[name] || {};\n    const value = param['i'] != null ? param['i'] : (param['f'] != null ? param['f'] : def);\n    return (typeof value === 'number') ? value : parseInt(value, 10);\n}\nexport function parseDtypeParam(value) {\n    if (typeof (value) === 'string') {\n        // tslint:disable-next-line:no-any\n        value = tensorflow.DataType[value];\n    }\n    switch (value) {\n        case tensorflow.DataType.DT_FLOAT:\n        case tensorflow.DataType.DT_HALF:\n            return 'float32';\n        case tensorflow.DataType.DT_INT32:\n        case tensorflow.DataType.DT_INT64:\n        case tensorflow.DataType.DT_INT8:\n        case tensorflow.DataType.DT_UINT8:\n            return 'int32';\n        case tensorflow.DataType.DT_BOOL:\n            return 'bool';\n        case tensorflow.DataType.DT_DOUBLE:\n            return 'float32';\n        case tensorflow.DataType.DT_STRING:\n            return 'string';\n        default:\n            // Unknown dtype error will happen at runtime (instead of parse time),\n            // since these nodes might not be used by the actual subgraph execution.\n            return null;\n    }\n}\nexport function getFuncParam(attrs, name, def) {\n    const param = attrs[name];\n    if (param && param.func) {\n        return param.func.name;\n    }\n    return def;\n}\nexport function getDtypeParam(attrs, name, def) {\n    const param = attrs[name];\n    if (param && param.type) {\n        return parseDtypeParam(param.type);\n    }\n    return def;\n}\nexport function getDtypeArrayParam(attrs, name, def) {\n    const param = attrs[name];\n    if (param && param.list && param.list.type) {\n        return param.list.type.map(v => parseDtypeParam(v));\n    }\n    return def;\n}\nexport function parseTensorShapeParam(shape) {\n    if (shape.unknownRank) {\n        return undefined;\n    }\n    if (shape.dim != null) {\n        return shape.dim.map(dim => (typeof dim.size === 'number') ? dim.size : parseInt(dim.size, 10));\n    }\n    return [];\n}\nexport function getTensorShapeParam(attrs, name, def) {\n    const param = attrs[name];\n    if (param && param.shape) {\n        return parseTensorShapeParam(param.shape);\n    }\n    return def;\n}\nexport function getNumericArrayParam(attrs, name, def) {\n    const param = attrs[name];\n    if (param) {\n        return ((param.list.f && param.list.f.length ? param.list.f :\n            param.list.i) ||\n            [])\n            .map(v => (typeof v === 'number') ? v : parseInt(v, 10));\n    }\n    return def;\n}\nexport function getStringArrayParam(attrs, name, def, keepCase = false) {\n    const param = attrs[name];\n    if (param && param.list && param.list.s) {\n        return param.list.s.map((v) => {\n            return parseStringParam(v, keepCase);\n        });\n    }\n    return def;\n}\nexport function getTensorShapeArrayParam(attrs, name, def) {\n    const param = attrs[name];\n    if (param && param.list && param.list.shape) {\n        return param.list.shape.map((v) => {\n            return parseTensorShapeParam(v);\n        });\n    }\n    return def;\n}\nexport function getBoolArrayParam(attrs, name, def) {\n    const param = attrs[name];\n    if (param && param.list && param.list.b) {\n        return param.list.b;\n    }\n    return def;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}