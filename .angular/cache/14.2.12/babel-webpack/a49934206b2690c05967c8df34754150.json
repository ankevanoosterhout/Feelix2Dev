{"ast":null,"code":"/**\n * ExecutionContext captures the runtime environment of the node. It keeps\n * track of the current frame and iteration for the control flow ops.\n *\n * For example, typical Dynamic RNN model may contain loops, for which\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\n * current execution frame, and NextIteration Nodes for iteration id increment.\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\n */\nexport class ExecutionContext {\n  constructor(weightMap = {}, tensorArrayMap = {}, tensorListMap = {}, functionMap = {}) {\n    this.weightMap = weightMap;\n    this.tensorArrayMap = tensorArrayMap;\n    this.tensorListMap = tensorListMap;\n    this.functionMap = functionMap;\n    this.rootContext = {\n      id: 0,\n      frameName: '',\n      iterationId: 0\n    };\n    this.contexts = [this.rootContext];\n    this.lastId = 0;\n    this.generateCurrentContextIds();\n  }\n\n  newFrame(id, frameName) {\n    return {\n      id,\n      frameName,\n      iterationId: 0\n    };\n  }\n  /**\n   * Set the current context\n   * @param contexts: ExecutionContextInfo[] the current path of execution\n   * frames\n   */\n\n\n  set currentContext(contexts) {\n    if (this.contexts !== contexts) {\n      this.contexts = contexts;\n      this.generateCurrentContextIds();\n    }\n  }\n\n  get currentContext() {\n    return this.contexts;\n  }\n  /**\n   * Returns the current context in string format.\n   */\n\n\n  get currentContextId() {\n    return this._currentContextIds[0];\n  }\n  /**\n   * Returns the current context and all parent contexts in string format.\n   * This allow access to the nodes in the current and parent frames.\n   */\n\n\n  get currentContextIds() {\n    return this._currentContextIds;\n  }\n\n  generateCurrentContextIds() {\n    const names = [];\n\n    for (let i = 0; i < this.contexts.length - 1; i++) {\n      const contexts = this.contexts.slice(0, this.contexts.length - i);\n      names.push(this.contextIdforContexts(contexts));\n    }\n\n    names.push('');\n    this._currentContextIds = names;\n  }\n\n  contextIdforContexts(contexts) {\n    return contexts ? contexts.map(context => context.id === 0 && context.iterationId === 0 ? '' : `${context.frameName}-${context.iterationId}`).join('/') : '';\n  }\n  /**\n   * Enter a new frame, a new context is pushed on the current context list.\n   * @param frameId new frame id\n   */\n\n\n  enterFrame(frameId) {\n    if (this.contexts) {\n      this.lastId++;\n      this.contexts = this.contexts.slice();\n      this.contexts.push(this.newFrame(this.lastId, frameId));\n\n      this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n    }\n  }\n  /**\n   * Exit the current frame, the last context is removed from the current\n   * context list.\n   */\n\n\n  exitFrame() {\n    if (this.contexts && this.contexts.length > 1) {\n      this.contexts = this.contexts.slice();\n      this.contexts.splice(-1);\n      this.currentContextIds.shift();\n    } else {\n      throw new Error('Cannot exit frame, the context is empty');\n    }\n  }\n  /**\n   * Enter the next iteration of a loop, the iteration id of last context is\n   * increased.\n   */\n\n\n  nextIteration() {\n    if (this.contexts && this.contexts.length > 0) {\n      this.contexts = this.contexts.slice();\n      this.lastId++;\n      const context = Object.assign({}, this.contexts[this.contexts.length - 1]);\n      context.iterationId += 1;\n      context.id = this.lastId;\n      this.contexts.splice(-1, 1, context);\n\n      this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));\n    } else {\n      throw new Error('Cannot increase frame iteration, the context is empty');\n    }\n  }\n\n  getWeight(name) {\n    return this.weightMap[name];\n  }\n\n  addTensorArray(tensorArray) {\n    this.tensorArrayMap[tensorArray.id] = tensorArray;\n  }\n\n  getTensorArray(id) {\n    return this.tensorArrayMap[id];\n  }\n\n  addTensorList(tensorList) {\n    this.tensorListMap[tensorList.id] = tensorList;\n  }\n\n  getTensorList(id) {\n    return this.tensorListMap[id];\n  }\n\n  dispose(keepIds) {\n    for (const key in this.tensorArrayMap) {\n      this.tensorArrayMap[key].clearAndClose(keepIds);\n    }\n\n    for (const key in this.tensorListMap) {\n      this.tensorListMap[key].clearAndClose(keepIds);\n    }\n  }\n\n}","map":{"version":3,"names":["ExecutionContext","constructor","weightMap","tensorArrayMap","tensorListMap","functionMap","rootContext","id","frameName","iterationId","contexts","lastId","generateCurrentContextIds","newFrame","currentContext","currentContextId","_currentContextIds","currentContextIds","names","i","length","slice","push","contextIdforContexts","map","context","join","enterFrame","frameId","unshift","exitFrame","splice","shift","Error","nextIteration","Object","assign","getWeight","name","addTensorArray","tensorArray","getTensorArray","addTensorList","tensorList","getTensorList","dispose","keepIds","key","clearAndClose"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-converter/dist/executor/execution_context.js"],"sourcesContent":["/**\n * ExecutionContext captures the runtime environment of the node. It keeps\n * track of the current frame and iteration for the control flow ops.\n *\n * For example, typical Dynamic RNN model may contain loops, for which\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\n * current execution frame, and NextIteration Nodes for iteration id increment.\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\n */\nexport class ExecutionContext {\n    constructor(weightMap = {}, tensorArrayMap = {}, tensorListMap = {}, functionMap = {}) {\n        this.weightMap = weightMap;\n        this.tensorArrayMap = tensorArrayMap;\n        this.tensorListMap = tensorListMap;\n        this.functionMap = functionMap;\n        this.rootContext = { id: 0, frameName: '', iterationId: 0 };\n        this.contexts = [this.rootContext];\n        this.lastId = 0;\n        this.generateCurrentContextIds();\n    }\n    newFrame(id, frameName) {\n        return { id, frameName, iterationId: 0 };\n    }\n    /**\n     * Set the current context\n     * @param contexts: ExecutionContextInfo[] the current path of execution\n     * frames\n     */\n    set currentContext(contexts) {\n        if (this.contexts !== contexts) {\n            this.contexts = contexts;\n            this.generateCurrentContextIds();\n        }\n    }\n    get currentContext() {\n        return this.contexts;\n    }\n    /**\n     * Returns the current context in string format.\n     */\n    get currentContextId() {\n        return this._currentContextIds[0];\n    }\n    /**\n     * Returns the current context and all parent contexts in string format.\n     * This allow access to the nodes in the current and parent frames.\n     */\n    get currentContextIds() {\n        return this._currentContextIds;\n    }\n    generateCurrentContextIds() {\n        const names = [];\n        for (let i = 0; i < this.contexts.length - 1; i++) {\n            const contexts = this.contexts.slice(0, this.contexts.length - i);\n            names.push(this.contextIdforContexts(contexts));\n        }\n        names.push('');\n        this._currentContextIds = names;\n    }\n    contextIdforContexts(contexts) {\n        return contexts ?\n            contexts\n                .map(context => (context.id === 0 && context.iterationId === 0) ?\n                '' :\n                `${context.frameName}-${context.iterationId}`)\n                .join('/') :\n            '';\n    }\n    /**\n     * Enter a new frame, a new context is pushed on the current context list.\n     * @param frameId new frame id\n     */\n    enterFrame(frameId) {\n        if (this.contexts) {\n            this.lastId++;\n            this.contexts = this.contexts.slice();\n            this.contexts.push(this.newFrame(this.lastId, frameId));\n            this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n        }\n    }\n    /**\n     * Exit the current frame, the last context is removed from the current\n     * context list.\n     */\n    exitFrame() {\n        if (this.contexts && this.contexts.length > 1) {\n            this.contexts = this.contexts.slice();\n            this.contexts.splice(-1);\n            this.currentContextIds.shift();\n        }\n        else {\n            throw new Error('Cannot exit frame, the context is empty');\n        }\n    }\n    /**\n     * Enter the next iteration of a loop, the iteration id of last context is\n     * increased.\n     */\n    nextIteration() {\n        if (this.contexts && this.contexts.length > 0) {\n            this.contexts = this.contexts.slice();\n            this.lastId++;\n            const context = Object.assign({}, this.contexts[this.contexts.length - 1]);\n            context.iterationId += 1;\n            context.id = this.lastId;\n            this.contexts.splice(-1, 1, context);\n            this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));\n        }\n        else {\n            throw new Error('Cannot increase frame iteration, the context is empty');\n        }\n    }\n    getWeight(name) {\n        return this.weightMap[name];\n    }\n    addTensorArray(tensorArray) {\n        this.tensorArrayMap[tensorArray.id] = tensorArray;\n    }\n    getTensorArray(id) {\n        return this.tensorArrayMap[id];\n    }\n    addTensorList(tensorList) {\n        this.tensorListMap[tensorList.id] = tensorList;\n    }\n    getTensorList(id) {\n        return this.tensorListMap[id];\n    }\n    dispose(keepIds) {\n        for (const key in this.tensorArrayMap) {\n            this.tensorArrayMap[key].clearAndClose(keepIds);\n        }\n        for (const key in this.tensorListMap) {\n            this.tensorListMap[key].clearAndClose(keepIds);\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}