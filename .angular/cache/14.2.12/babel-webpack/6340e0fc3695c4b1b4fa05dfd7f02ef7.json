{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { SparseFillEmptyRows } from '@tensorflow/tfjs-core';\nimport { sparseFillEmptyRowsImpl } from './SparseFillEmptyRows_impl';\nexport function sparseFillEmptyRows(args) {\n  const {\n    inputs,\n    backend\n  } = args;\n  const {\n    indices,\n    values,\n    denseShape,\n    defaultValue\n  } = inputs;\n\n  if (denseShape.shape.length !== 1) {\n    throw new Error(`Dense shape must be a vector, saw:\n        ${denseShape.shape}`);\n  }\n\n  if (indices.shape.length !== 2) {\n    throw new Error(`Indices must be a matrix, saw:\n        ${indices.shape}`);\n  }\n\n  if (values.shape.length !== 1) {\n    throw new Error(`Values must be a vector, saw:\n        ${values.shape}`);\n  }\n\n  if (defaultValue.shape.length !== 0) {\n    throw new Error(`Default value must be a scalar, saw:\n        ${defaultValue.shape}`);\n  }\n\n  const $indices = backend.data.get(indices.dataId).values;\n  const $values = backend.data.get(values.dataId).values;\n  const $denseShape = backend.data.get(denseShape.dataId).values;\n  const $defaultValue = backend.data.get(defaultValue.dataId).values[0];\n  const [outputIndices, outputIndicesShape, outputValues, emptyRowIndicator, reverseIndexMap] = sparseFillEmptyRowsImpl($indices, indices.shape, indices.dtype, $values, values.dtype, $denseShape, $defaultValue);\n  return [backend.makeTensorInfo(outputIndicesShape, indices.dtype, outputIndices), backend.makeTensorInfo([outputIndicesShape[0]], values.dtype, outputValues), backend.makeTensorInfo([emptyRowIndicator.length], 'bool', new Uint8Array(emptyRowIndicator.map(value => Number(value)))), backend.makeTensorInfo([reverseIndexMap.length], indices.dtype, new Int32Array(reverseIndexMap))];\n}\nexport const sparseFillEmptyRowsConfig = {\n  kernelName: SparseFillEmptyRows,\n  backendName: 'cpu',\n  kernelFunc: sparseFillEmptyRows\n};","map":{"version":3,"names":["SparseFillEmptyRows","sparseFillEmptyRowsImpl","sparseFillEmptyRows","args","inputs","backend","indices","values","denseShape","defaultValue","shape","length","Error","$indices","data","get","dataId","$values","$denseShape","$defaultValue","outputIndices","outputIndicesShape","outputValues","emptyRowIndicator","reverseIndexMap","dtype","makeTensorInfo","Uint8Array","map","value","Number","Int32Array","sparseFillEmptyRowsConfig","kernelName","backendName","kernelFunc"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseFillEmptyRows.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { SparseFillEmptyRows } from '@tensorflow/tfjs-core';\nimport { sparseFillEmptyRowsImpl } from './SparseFillEmptyRows_impl';\nexport function sparseFillEmptyRows(args) {\n    const { inputs, backend } = args;\n    const { indices, values, denseShape, defaultValue } = inputs;\n    if (denseShape.shape.length !== 1) {\n        throw new Error(`Dense shape must be a vector, saw:\n        ${denseShape.shape}`);\n    }\n    if (indices.shape.length !== 2) {\n        throw new Error(`Indices must be a matrix, saw:\n        ${indices.shape}`);\n    }\n    if (values.shape.length !== 1) {\n        throw new Error(`Values must be a vector, saw:\n        ${values.shape}`);\n    }\n    if (defaultValue.shape.length !== 0) {\n        throw new Error(`Default value must be a scalar, saw:\n        ${defaultValue.shape}`);\n    }\n    const $indices = backend.data.get(indices.dataId).values;\n    const $values = backend.data.get(values.dataId).values;\n    const $denseShape = backend.data.get(denseShape.dataId).values;\n    const $defaultValue = backend.data.get(defaultValue.dataId).values[0];\n    const [outputIndices, outputIndicesShape, outputValues, emptyRowIndicator, reverseIndexMap] = sparseFillEmptyRowsImpl($indices, indices.shape, indices.dtype, $values, values.dtype, $denseShape, $defaultValue);\n    return [\n        backend.makeTensorInfo(outputIndicesShape, indices.dtype, outputIndices),\n        backend.makeTensorInfo([outputIndicesShape[0]], values.dtype, outputValues),\n        backend.makeTensorInfo([emptyRowIndicator.length], 'bool', new Uint8Array(emptyRowIndicator.map((value) => Number(value)))),\n        backend.makeTensorInfo([reverseIndexMap.length], indices.dtype, new Int32Array(reverseIndexMap)),\n    ];\n}\nexport const sparseFillEmptyRowsConfig = {\n    kernelName: SparseFillEmptyRows,\n    backendName: 'cpu',\n    kernelFunc: sparseFillEmptyRows,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}