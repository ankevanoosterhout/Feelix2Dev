{"ast":null,"code":"import { vec3, vec4, mat4 } from 'gl-matrix';\nimport { accumulateClosureError, accumulateTargetError } from './utils/solver.js';\nimport { mat } from './utils/matrix.js';\nimport { getMatrixDifference } from './utils/glmatrix.js'; // temp reusable variables\n\nconst targetRelativeToJointMatrix = new Float64Array(16);\nconst targetDeltaWorldMatrix = new Float64Array(16);\nconst tempDeltaWorldMatrix = new Float64Array(16);\nconst tempInverseMatrixWorld = new Float64Array(16);\nconst tempQuat = new Float64Array(4);\nconst tempPos = new Float64Array(3);\nconst tempQuat2 = new Float64Array(4);\nconst tempPos2 = new Float64Array(3);\nconst targetJoints = [];\nconst freeJoints = [];\nconst errorResultInfo = {\n  rowCount: 0,\n  isConverged: false,\n  totalError: 0\n};\nconst dofResultInfo = {\n  errorRows: 0,\n  freeDoF: 0,\n  totalError: 0\n};\nexport const SOLVE_STATUS = {\n  CONVERGED: 0,\n  STALLED: 1,\n  DIVERGED: 2,\n  TIMEOUT: 3\n};\nexport const SOLVE_STATUS_NAMES = Object.entries(SOLVE_STATUS).sort((a, b) => a[1] - b[1]).map(el => el[0]);\nexport class ChainSolver {\n  constructor(chain) {\n    this.chain = Array.from(chain); // list of targets we're trying to minimize in the chain\n\n    this.targets = null; // map of joint -> closures that the given joint affects\n\n    this.affectedClosures = null; // map of joint -> closure children that the given joint affects\n\n    this.affectedConnectedClosures = null; // map of joint -> that stores the amount of DoF that are locked after\n    // hitting a joint limit.\n    // Undefined or 0 if none are locked\n\n    this.lockedJointDoFCount = null; // map of joint -> list of locked DoF\n\n    this.lockedJointDoF = null; // map of joint -> previous joint angles for resetting joint angles on\n    // divergence check.\n\n    this.prevDoFValues = null; // options -- these are set by the containing Solver.\n\n    this.maxIterations = -1;\n    this.matrixPool = null;\n    this.useSVD = false;\n    this.translationConvergeThreshold = -1;\n    this.rotationConvergeThreshold = -1;\n    this.translationFactor = -1;\n    this.rotationFactor = -1;\n    this.translationStep = -1;\n    this.rotationStep = -1;\n    this.translationErrorClamp = -1;\n    this.rotationErrorClamp = -1;\n    this.stallThreshold = -1;\n    this.dampingFactor = -1;\n    this.divergeThreshold = -1;\n    this.restPoseFactor = -1;\n    this.init();\n  }\n\n  init() {\n    // Find all joints with targets.\n    const chain = this.chain;\n    const targets = chain.filter(j => j.targetSet || j.isClosure);\n    const lockedJointDoF = new Map();\n    const lockedJointDoFCount = new Map();\n    const prevDoFValues = new Map();\n    const affectedClosures = new Map();\n    const affectedConnectedClosures = new Map();\n    chain.forEach(j => {\n      // Track which joints will have a direct affect on which targets move\n      // for closure end effectors.\n      affectedClosures.set(j, new Set());\n      affectedConnectedClosures.set(j, new Set()); // Initialize our array with all possible degrees of freedom\n\n      lockedJointDoF.set(j, new Uint8Array(6));\n      prevDoFValues.set(j, new Float64Array(6));\n    });\n    targets.forEach(target => {\n      if (target.isClosure) {\n        let currJoint = target; // climb the joint tree and mark every joint as affecting this closure end.\n\n        while (currJoint) {\n          if (currJoint.isJoint) {\n            affectedClosures.get(currJoint).add(target);\n          }\n\n          currJoint = currJoint.parent;\n        } // and mark the joints up the other chain as effecting the other connector link.\n\n\n        currJoint = target.child;\n\n        while (currJoint) {\n          if (currJoint.isJoint) {\n            affectedConnectedClosures.get(currJoint).add(target);\n          }\n\n          currJoint = currJoint.parent;\n        }\n      }\n    });\n    this.targets = targets;\n    this.affectedClosures = affectedClosures;\n    this.affectedConnectedClosures = affectedConnectedClosures;\n    this.lockedJointDoF = lockedJointDoF;\n    this.lockedJointDoFCount = lockedJointDoFCount;\n    this.prevDoFValues = prevDoFValues;\n  }\n\n  solve() {\n    const {\n      divergeThreshold,\n      stallThreshold,\n      chain,\n      restPoseFactor,\n      lockedJointDoFCount,\n      prevDoFValues,\n      useSVD,\n      matrixPool\n    } = this;\n    let iterations = 0;\n    let prevErrorMagnitude = Infinity;\n    let status = -1; // Clear out all the locked joints\n\n    lockedJointDoFCount.clear(); // TODO: instead of trying to use minimal euler angles we should try to represent joint\n    // error as a quaternion in the quaternion vector.\n\n    for (let i = 0, l = chain.length; i < l; i++) {\n      const joint = chain[i];\n\n      if (joint.targetSet || joint.restPoseSet) {\n        joint.tryMinimizeEulerAngles();\n      }\n    }\n\n    do {\n      matrixPool.releaseAll(); // Make sure our matrices are all up to date\n\n      for (let i = 0, l = chain.length; i < l; i++) {\n        const joint = chain[i];\n        joint.updateMatrixWorld();\n      } // TODO: this only needs to be recomputed if a joint was locked so maybe lets check that? We also\n      // lock joints inside this function so maybe we can forgo that?\n\n\n      targetJoints.length = 0;\n      freeJoints.length = 0;\n      this.countUnconvergedVariables(freeJoints, targetJoints, dofResultInfo);\n      const {\n        freeDoF,\n        errorRows,\n        totalError\n      } = dofResultInfo; // Check if we've converged\n\n      if (errorRows === 0) {\n        status = SOLVE_STATUS.CONVERGED;\n        break;\n      } // Check if we've diverged\n\n\n      if (totalError > prevErrorMagnitude + divergeThreshold) {\n        prevDoFValues.forEach((dofValues, joint) => {\n          joint.dofValues.set(dofValues);\n          joint.setMatrixDoFNeedsUpdate();\n        });\n        status = SOLVE_STATUS.DIVERGED;\n        break;\n      }\n\n      prevErrorMagnitude = totalError; // Check if we've hit max iterations\n\n      iterations++;\n\n      if (iterations > this.maxIterations) {\n        status = SOLVE_STATUS.TIMEOUT;\n        break;\n      } // A * x = b\n      // find x such that it yields b where is the clamped error we're trying to work towards\n      // and A is the jacobian, and x is the delta joint angles.\n\n\n      const errorVector = matrixPool.get(errorRows, 1);\n      this.fillErrorVector(targetJoints, errorVector);\n      const jacobian = matrixPool.get(errorRows, freeDoF);\n      this.fillJacobian(targetJoints, freeJoints, jacobian); // Solve for the pseudo inverse of the jacobian\n\n      const pseudoInverse = matrixPool.get(freeDoF, errorRows);\n      let failedSVD = false;\n\n      if (useSVD) {\n        try {\n          const m = errorRows;\n          const n = freeDoF;\n          const k = Math.min(m, n);\n          const u = matrixPool.get(m, k); // m x k\n\n          const q = matrixPool.get(k, k); // k x k\n\n          const v = matrixPool.get(n, k); // ( k x n )^T -> ( n x k )\n\n          mat.svd(u, q, v, jacobian);\n          const uTranspose = matrixPool.get(k, m);\n          const qInverse = matrixPool.get(k, k);\n          mat.transpose(uTranspose, u); // if the diagonal value is close to 0 when taking the inverse\n          // then set it to zero.\n\n          for (let i = 0, l = q.length; i < l; i++) {\n            const val = q[i][i];\n            let inv;\n\n            if (Math.abs(val) < 0.001) {\n              inv = 0;\n            } else {\n              inv = 1 / val;\n            }\n\n            qInverse[i][i] = inv;\n          } // V * Qinv * Ut\n\n\n          const vqinv = matrixPool.get(n, k);\n          mat.multiply(vqinv, v, qInverse);\n          mat.multiply(pseudoInverse, vqinv, uTranspose);\n        } catch (err) {\n          failedSVD = true;\n        }\n      }\n\n      if (!useSVD || failedSVD) {\n        // Use a transpose pseudo inverse approach: A^T * A * x = A^T * b with the damping term\n        // J^T * J * x = J^T * e\n        // x = J^T * ( J * J^T )^-1 * e\n        // and with the adding damping\n        // x = J^T * ( J * J^T + l^2 * I )^-1 * e\n        // l^2 * I\n        const jacobianIdentityDamping = matrixPool.get(errorRows, errorRows);\n        mat.identity(jacobianIdentityDamping);\n        mat.scale(jacobianIdentityDamping, jacobianIdentityDamping, this.dampingFactor ** 2); // J^T\n\n        const jacobianTranspose = matrixPool.get(freeDoF, errorRows);\n        mat.transpose(jacobianTranspose, jacobian); // J * J^T\n\n        const jjt = matrixPool.get(errorRows, errorRows);\n        mat.multiply(jjt, jacobian, jacobianTranspose); // J * J^T + l^2 * I\n\n        const jjti = matrixPool.get(errorRows, errorRows);\n        mat.add(jjti, jjt, jacobianIdentityDamping); // ( J * J^T + l^2 * I )^-1\n\n        const jjtii = matrixPool.get(errorRows, errorRows);\n        mat.invert(jjtii, jjti); // J^T * ( J * J^T + l^2 * I )^-1\n\n        mat.multiply(pseudoInverse, jacobianTranspose, jjtii);\n      } // x = deltaTheta = J^T * ( J * J^T + l^2 * I )^-1 * e\n\n\n      const deltaTheta = matrixPool.get(freeDoF, 1);\n      mat.multiply(deltaTheta, pseudoInverse, errorVector);\n\n      if (restPoseFactor !== 0) {\n        // Nullspace Projection\n        // I - J^-1 * J is the orthogonal null space of J where J^-1 is the pseudoinverse\n        // Multiplied by the rest position of each dof\n        // ( I - J^-1 * J ) * restPose\n        const restPose = matrixPool.get(freeDoF, 1);\n        const restPoseResult = matrixPool.get(freeDoF, 1);\n        let colIndex = 0;\n\n        for (let i = 0, l = freeJoints.length; i < l; i++) {\n          const joint = freeJoints[i];\n          const lockedDoFCount = this.lockedJointDoFCount.get(joint) || 0;\n          const isLocked = lockedDoFCount !== 0;\n          const lockedDoF = this.lockedJointDoF.get(joint);\n          const colCount = joint.rotationDoFCount + joint.translationDoFCount - lockedDoFCount;\n\n          if (joint.restPoseSet) {\n            const dofList = joint.dof;\n            const dofValues = joint.dofValues;\n            const dofRestPose = joint.dofRestPose;\n\n            for (let d = 0; d < colCount; d++) {\n              const dof = dofList[d];\n              if (isLocked && lockedDoF[dof]) continue;\n              restPose[colIndex][0] = dofRestPose[dof] - dofValues[dof];\n              colIndex++;\n            }\n          } else {\n            for (let d = 0; d < colCount; d++) {\n              restPose[colIndex][0] = 0;\n              colIndex++;\n            }\n          }\n        } // J^-1 * J\n\n\n        const jij = matrixPool.get(freeDoF, freeDoF);\n        mat.multiply(jij, pseudoInverse, jacobian); // ( I - J^-1 * J )\n\n        const ident = matrixPool.get(freeDoF, freeDoF);\n        mat.identity(ident);\n        const nullSpaceProjection = matrixPool.get(freeDoF, freeDoF);\n        mat.subtract(nullSpaceProjection, ident, jij); // ( I - J^-1 * J ) * restPose\n\n        mat.multiply(restPoseResult, nullSpaceProjection, restPose);\n\n        for (let r = 0; r < freeDoF; r++) {\n          const val = restPoseResult[r][0];\n          deltaTheta[r][0] += val * restPoseFactor;\n        }\n      } // Check if our joints have not moved and returned stalled\n\n\n      if (stallThreshold > 0) {\n        let stalled = true;\n\n        for (let i = 0, l = deltaTheta.length; i < l; i++) {\n          const delta = deltaTheta[i][0];\n\n          if (Math.abs(delta) > stallThreshold) {\n            stalled = false;\n            break;\n          }\n        }\n\n        if (stalled) {\n          status = SOLVE_STATUS.STALLED;\n          break;\n        }\n      } // Prep for a divergence check\n\n\n      prevDoFValues.forEach((dofValues, joint) => {\n        dofValues.set(joint.dofValues);\n      }); // apply the latest joint angles and lock and joints that have\n      // hit their joint limits.\n\n      this.applyJointAngles(freeJoints, deltaTheta); // there's still error and we're under the max iterations\n    } while (true);\n\n    targetJoints.length = 0;\n    freeJoints.length = 0;\n    return status;\n  } // Apply the delta values from the solve to the free joints in the list\n\n\n  applyJointAngles(freeJoints, deltaTheta) {\n    const {\n      lockedJointDoF,\n      lockedJointDoFCount\n    } = this;\n    let lockedJoint = false;\n    let dti = 0;\n\n    for (let i = 0, l = freeJoints.length; i < l; i++) {\n      // Apply the delta to every free joint\n      const joint = freeJoints[i];\n      const dofList = joint.dof;\n      const lockedDoF = lockedJointDoF.get(joint);\n      const isLocked = lockedJointDoFCount.has(joint);\n\n      for (let d = 0, l = dofList.length; d < l; d++) {\n        const dof = dofList[d];\n\n        if (isLocked && lockedDoF[dof]) {\n          continue;\n        }\n\n        const value = joint.getDoFValue(dof);\n        const hitLimit = joint.setDoFValue(dof, value + deltaTheta[dti][0]); // lock the joint if we hit a limit\n\n        if (hitLimit) {\n          if (!lockedJointDoFCount.has(joint)) {\n            lockedJointDoFCount.set(joint, 0);\n            lockedDoF.fill(0);\n          }\n\n          const lockedCount = lockedJointDoFCount.get(joint);\n          lockedJointDoFCount.set(joint, lockedCount + 1);\n          lockedDoF[dof] = 1;\n          lockedJoint = true;\n        }\n\n        dti++;\n      }\n    }\n\n    if (dti !== deltaTheta.length) {\n      throw new Error();\n    }\n\n    return lockedJoint;\n  } // generate the jacobian\n  // The jacobian has one column for each free degree of freedom and a row for every\n  // target degree of freedom we have. The entries are generated by adjusting every\n  // DoF by some epsilon and storing how much it affected the target error.\n\n\n  fillJacobian(targetJoints, freeJoints, outJacobian) {\n    const {\n      translationStep,\n      rotationStep,\n      lockedJointDoF,\n      lockedJointDoFCount,\n      translationFactor,\n      rotationFactor\n    } = this; // TODO: abstract this\n\n    const affectedClosures = this.affectedClosures;\n    const affectedConnectedClosures = this.affectedConnectedClosures;\n    let colIndex = 0;\n\n    for (let c = 0, tc = freeJoints.length; c < tc; c++) {\n      // TODO: If this is a goal we should skip adding it to the jacabian columns\n      const freeJoint = freeJoints[c];\n      const relevantClosures = affectedClosures.get(freeJoint);\n      const relevantConnectedClosures = affectedConnectedClosures.get(freeJoint);\n      const dofList = freeJoint.dof;\n      const colCount = freeJoint.translationDoFCount + freeJoint.rotationDoFCount;\n      const isLocked = lockedJointDoFCount.has(freeJoint);\n      const lockedDoF = lockedJointDoF.get(freeJoint); // get the world inverse of the free joint\n\n      mat4.invert(tempInverseMatrixWorld, freeJoint.matrixWorld); // iterate over every degree of freedom in the joint\n\n      for (let co = 0; co < colCount; co++) {\n        const dof = dofList[co]; // skip this joint if it's locked\n\n        if (isLocked && lockedDoF[dof]) {\n          continue;\n        }\n\n        let rowIndex = 0; // generate the adjusted matrix based on the epsilon for the joint.\n\n        let delta = dof < 3 ? translationStep : rotationStep;\n\n        if (freeJoint.getDeltaWorldMatrix(dof, delta, tempDeltaWorldMatrix)) {\n          delta *= -1;\n        } // Iterate over every target\n\n\n        for (let r = 0, tr = targetJoints.length; r < tr; r++) {\n          const targetJoint = targetJoints[r]; // if it's a closure target\n\n          if (targetJoint.isClosure) {\n            if (relevantClosures.has(targetJoint) || relevantConnectedClosures.has(targetJoint)) {\n              // TODO: If this is a Goal it only add 1 or 2 fields if only two axes are set. Quat is only\n              // needed if 3 eulers are used.\n              // TODO: these could be cached per target joint get the current error within the closure joint\n              // Get the error from child towards the closure target\n              targetJoint.getClosureError(tempPos, tempQuat);\n\n              if (relevantConnectedClosures.has(targetJoint)) {\n                // If this is affecting a link connected to a closure joint then adjust that child link by\n                // the delta rotation.\n                mat4.multiply(targetRelativeToJointMatrix, tempInverseMatrixWorld, targetJoint.child.matrixWorld);\n                mat4.multiply(targetDeltaWorldMatrix, tempDeltaWorldMatrix, targetRelativeToJointMatrix); // Get the new error\n\n                getMatrixDifference(targetJoint.matrixWorld, targetDeltaWorldMatrix, tempPos2, tempQuat2);\n              } else {\n                // If this is directly affecting a closure joint then adjust that child link by the delta\n                // rotation.\n                mat4.multiply(targetRelativeToJointMatrix, tempInverseMatrixWorld, targetJoint.matrixWorld);\n                mat4.multiply(targetDeltaWorldMatrix, tempDeltaWorldMatrix, targetRelativeToJointMatrix); // Get the new error\n\n                getMatrixDifference(targetDeltaWorldMatrix, targetJoint.child.matrixWorld, tempPos2, tempQuat2);\n              } // Get the amount that the rotation and translation error changed due to the\n              // small DoF adjustment to serve as the derivative.\n\n\n              vec3.subtract(tempPos, tempPos, tempPos2);\n              vec3.scale(tempPos, tempPos, translationFactor / delta);\n              vec4.subtract(tempQuat, tempQuat, tempQuat2);\n              vec4.scale(tempQuat, tempQuat, rotationFactor / delta);\n\n              if (targetJoint.isGoal) {\n                const {\n                  translationDoFCount,\n                  rotationDoFCount,\n                  dof\n                } = targetJoint;\n\n                for (let i = 0; i < translationDoFCount; i++) {\n                  const d = dof[i];\n                  outJacobian[rowIndex + i][colIndex] = tempPos[d];\n                }\n\n                if (rotationDoFCount === 3) {\n                  outJacobian[rowIndex + translationDoFCount + 0][colIndex] = tempQuat[0];\n                  outJacobian[rowIndex + translationDoFCount + 1][colIndex] = tempQuat[1];\n                  outJacobian[rowIndex + translationDoFCount + 2][colIndex] = tempQuat[2];\n                  outJacobian[rowIndex + translationDoFCount + 3][colIndex] = tempQuat[3];\n                  rowIndex += 4;\n                }\n\n                rowIndex += translationDoFCount;\n              } else {\n                // set translation\n                outJacobian[rowIndex + 0][colIndex] = tempPos[0];\n                outJacobian[rowIndex + 1][colIndex] = tempPos[1];\n                outJacobian[rowIndex + 2][colIndex] = tempPos[2]; // set rotation\n\n                outJacobian[rowIndex + 3][colIndex] = tempQuat[0];\n                outJacobian[rowIndex + 4][colIndex] = tempQuat[1];\n                outJacobian[rowIndex + 5][colIndex] = tempQuat[2];\n                outJacobian[rowIndex + 6][colIndex] = tempQuat[3];\n                rowIndex += 7;\n              }\n            } else {\n              // if the target isn't relevant then there's no delta\n              let totalRows = 7;\n\n              if (targetJoint.isGoal) {\n                totalRows = targetJoint.translationDoFCount;\n\n                if (targetJoint.rotationDoFCount === 3) {\n                  totalRows += 4;\n                }\n              }\n\n              for (let i = 0; i < totalRows; i++) {\n                outJacobian[rowIndex + i][colIndex] = 0;\n              }\n\n              rowIndex += totalRows;\n            }\n          } // Check if this joint has a target set and update the jacobian rows if it does\n\n\n          if (targetJoint.targetSet) {\n            const rowCount = targetJoint.translationDoFCount + targetJoint.rotationDoFCount;\n\n            if (freeJoint === targetJoint) {\n              // if we're just dealing with a target dof joint then there can't be any influence\n              // but otherwise the only joint that can have an effect on this error is the joint\n              // itself.\n              // TODO: Having noted that is this really necessary? Is there any way that this doesn't just\n              // jump to the solution and lock? How can we afford some slack? With a low weight? Does that\n              // get applied here?\n              // TODO: If this joint happens to have three euler joints we need to use a quat here. Otherwise we\n              // use the euler angles.\n              for (let i = 0; i < rowCount; i++) {\n                outJacobian[rowIndex + colIndex][colIndex] = -1;\n              }\n            } else {\n              for (let i = 0; i < rowCount; i++) {\n                outJacobian[rowIndex + i][colIndex] = 0;\n              }\n            }\n\n            rowIndex += rowCount;\n          }\n        }\n\n        colIndex++;\n      }\n    }\n\n    if (colIndex !== outJacobian[0].length) {\n      throw new Error();\n    }\n  } // Fill in the error vector\n\n\n  fillErrorVector(targetJoints, errorVector) {\n    let rowIndex = 0;\n\n    for (let i = 0, l = targetJoints.length; i < l; i++) {\n      const joint = targetJoints[i];\n\n      if (joint.isClosure) {\n        accumulateClosureError(this, joint, rowIndex, errorVector, errorResultInfo);\n        rowIndex += errorResultInfo.rowCount;\n      }\n\n      if (joint.targetSet) {\n        accumulateTargetError(this, joint, rowIndex, errorVector, errorResultInfo);\n        rowIndex += errorResultInfo.rowCount;\n      }\n    }\n  } // Count the unconverged targets in the chain and store them in targetJoints and store\n  // any freeJoints in\n\n\n  countUnconvergedVariables(freeJoints, targetJoints, dofResultInfo) {\n    const {\n      lockedJointDoFCount\n    } = this;\n    const chain = this.chain;\n    let totalError = 0;\n    let errorRows = 0;\n    let unconvergedRows = 0;\n    let freeDoF = 0;\n\n    for (let i = 0, l = chain.length; i < l; i++) {\n      let addToTargetList = false;\n      const joint = chain[i];\n      const lockedDoF = lockedJointDoFCount.get(joint) || 0; // TODO: Should we check every variable against the convergence threshold or is\n      // it better to check the magnitude?\n      // TODO: We may be able to speed this up by using the square distance and length\n      // to compare error.\n      // TODO: If this is a goal we shouldnt add to the free dof because they won't be added\n      // to the jacobian\n      // If this is a closure joint then we need to make sure we're solving\n      // for the other child end to meet this joint so this error is important.\n\n      if (joint.isClosure) {\n        accumulateClosureError(this, joint, errorRows, null, errorResultInfo);\n\n        if (!errorResultInfo.isConverged) {\n          unconvergedRows += errorResultInfo.rowCount;\n          totalError += errorResultInfo.totalError;\n        }\n\n        addToTargetList = true;\n        errorRows += errorResultInfo.rowCount;\n      } // Check out far the joint is from the target dof value.\n\n\n      const dofList = joint.dof;\n\n      if (joint.targetSet) {\n        accumulateTargetError(this, joint, errorRows, null, errorResultInfo);\n\n        if (!errorResultInfo.isConverged) {\n          unconvergedRows += errorResultInfo.rowCount;\n          totalError += errorResultInfo.totalError;\n        }\n\n        addToTargetList = true;\n        errorRows += errorResultInfo.rowCount;\n      }\n\n      if (!joint.isGoal && dofList.length > 0) {\n        freeDoF += dofList.length - lockedDoF;\n        freeJoints.push(joint);\n      }\n\n      if (addToTargetList) {\n        targetJoints.push(joint);\n      }\n    } // if it turns out that everything is converged.\n\n\n    if (unconvergedRows === 0) {\n      errorRows = 0;\n    }\n\n    dofResultInfo.errorRows = errorRows;\n    dofResultInfo.freeDoF = freeDoF;\n    dofResultInfo.totalError = totalError;\n  }\n\n}","map":{"version":3,"names":["vec3","vec4","mat4","accumulateClosureError","accumulateTargetError","mat","getMatrixDifference","targetRelativeToJointMatrix","Float64Array","targetDeltaWorldMatrix","tempDeltaWorldMatrix","tempInverseMatrixWorld","tempQuat","tempPos","tempQuat2","tempPos2","targetJoints","freeJoints","errorResultInfo","rowCount","isConverged","totalError","dofResultInfo","errorRows","freeDoF","SOLVE_STATUS","CONVERGED","STALLED","DIVERGED","TIMEOUT","SOLVE_STATUS_NAMES","Object","entries","sort","a","b","map","el","ChainSolver","constructor","chain","Array","from","targets","affectedClosures","affectedConnectedClosures","lockedJointDoFCount","lockedJointDoF","prevDoFValues","maxIterations","matrixPool","useSVD","translationConvergeThreshold","rotationConvergeThreshold","translationFactor","rotationFactor","translationStep","rotationStep","translationErrorClamp","rotationErrorClamp","stallThreshold","dampingFactor","divergeThreshold","restPoseFactor","init","filter","j","targetSet","isClosure","Map","forEach","set","Set","Uint8Array","target","currJoint","isJoint","get","add","parent","child","solve","iterations","prevErrorMagnitude","Infinity","status","clear","i","l","length","joint","restPoseSet","tryMinimizeEulerAngles","releaseAll","updateMatrixWorld","countUnconvergedVariables","dofValues","setMatrixDoFNeedsUpdate","errorVector","fillErrorVector","jacobian","fillJacobian","pseudoInverse","failedSVD","m","n","k","Math","min","u","q","v","svd","uTranspose","qInverse","transpose","val","inv","abs","vqinv","multiply","err","jacobianIdentityDamping","identity","scale","jacobianTranspose","jjt","jjti","jjtii","invert","deltaTheta","restPose","restPoseResult","colIndex","lockedDoFCount","isLocked","lockedDoF","colCount","rotationDoFCount","translationDoFCount","dofList","dof","dofRestPose","d","jij","ident","nullSpaceProjection","subtract","r","stalled","delta","applyJointAngles","lockedJoint","dti","has","value","getDoFValue","hitLimit","setDoFValue","fill","lockedCount","Error","outJacobian","c","tc","freeJoint","relevantClosures","relevantConnectedClosures","matrixWorld","co","rowIndex","getDeltaWorldMatrix","tr","targetJoint","getClosureError","isGoal","totalRows","unconvergedRows","addToTargetList","push"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/closed-chain-ik/src/core/ChainSolver.js"],"sourcesContent":["import { vec3, vec4, mat4 } from 'gl-matrix';\r\nimport { accumulateClosureError, accumulateTargetError } from './utils/solver.js';\r\nimport { mat } from './utils/matrix.js';\r\nimport { getMatrixDifference } from './utils/glmatrix.js';\r\n\r\n// temp reusable variables\r\nconst targetRelativeToJointMatrix = new Float64Array( 16 );\r\nconst targetDeltaWorldMatrix = new Float64Array( 16 );\r\nconst tempDeltaWorldMatrix = new Float64Array( 16 );\r\nconst tempInverseMatrixWorld = new Float64Array( 16 );\r\nconst tempQuat = new Float64Array( 4 );\r\nconst tempPos = new Float64Array( 3 );\r\nconst tempQuat2 = new Float64Array( 4 );\r\nconst tempPos2 = new Float64Array( 3 );\r\n\r\nconst targetJoints = [];\r\nconst freeJoints = [];\r\nconst errorResultInfo = {\r\n\trowCount: 0,\r\n\tisConverged: false,\r\n\ttotalError: 0,\r\n};\r\nconst dofResultInfo = {\r\n\terrorRows: 0,\r\n\tfreeDoF: 0,\r\n\ttotalError: 0,\r\n};\r\n\r\nexport const SOLVE_STATUS = {\r\n\r\n\tCONVERGED: 0,\r\n\tSTALLED: 1,\r\n\tDIVERGED: 2,\r\n\tTIMEOUT: 3,\r\n\r\n};\r\n\r\nexport const SOLVE_STATUS_NAMES = Object.entries( SOLVE_STATUS ).sort( ( a, b ) => a[ 1 ] - b[ 1 ] ).map( el => el[ 0 ] );\r\n\r\nexport class ChainSolver {\r\n\r\n\tconstructor( chain ) {\r\n\r\n\t\tthis.chain = Array.from( chain );\r\n\r\n\t\t// list of targets we're trying to minimize in the chain\r\n\t\tthis.targets = null;\r\n\r\n\t\t// map of joint -> closures that the given joint affects\r\n\t\tthis.affectedClosures = null;\r\n\r\n\t\t// map of joint -> closure children that the given joint affects\r\n\t\tthis.affectedConnectedClosures = null;\r\n\r\n\t\t// map of joint -> that stores the amount of DoF that are locked after\r\n\t\t// hitting a joint limit.\r\n\t\t// Undefined or 0 if none are locked\r\n\t\tthis.lockedJointDoFCount = null;\r\n\r\n\t\t// map of joint -> list of locked DoF\r\n\t\tthis.lockedJointDoF = null;\r\n\r\n\t\t// map of joint -> previous joint angles for resetting joint angles on\r\n\t\t// divergence check.\r\n\t\tthis.prevDoFValues = null;\r\n\r\n\t\t// options -- these are set by the containing Solver.\r\n\t\tthis.maxIterations = - 1;\r\n\r\n\t\tthis.matrixPool = null;\r\n\r\n\t\tthis.useSVD = false;\r\n\r\n\t\tthis.translationConvergeThreshold = - 1;\r\n\t\tthis.rotationConvergeThreshold = - 1;\r\n\r\n\t\tthis.translationFactor = - 1;\r\n\t\tthis.rotationFactor = - 1;\r\n\r\n\t\tthis.translationStep = - 1;\r\n\t\tthis.rotationStep = - 1;\r\n\r\n\t\tthis.translationErrorClamp = - 1;\r\n\t\tthis.rotationErrorClamp = - 1;\r\n\r\n\t\tthis.stallThreshold = - 1;\r\n\t\tthis.dampingFactor = - 1;\r\n\t\tthis.divergeThreshold = - 1;\r\n\t\tthis.restPoseFactor = - 1;\r\n\r\n\t\tthis.init();\r\n\r\n\t}\r\n\r\n\tinit() {\r\n\r\n\t\t// Find all joints with targets.\r\n\t\tconst chain = this.chain;\r\n\t\tconst targets = chain.filter( j => j.targetSet || j.isClosure );\r\n\r\n\t\tconst lockedJointDoF = new Map();\r\n\t\tconst lockedJointDoFCount = new Map();\r\n\t\tconst prevDoFValues = new Map();\r\n\r\n\t\tconst affectedClosures = new Map();\r\n\t\tconst affectedConnectedClosures = new Map();\r\n\t\tchain.forEach( j => {\r\n\r\n\t\t\t// Track which joints will have a direct affect on which targets move\r\n\t\t\t// for closure end effectors.\r\n\t\t\taffectedClosures.set( j, new Set() );\r\n\t\t\taffectedConnectedClosures.set( j, new Set() );\r\n\r\n\t\t\t// Initialize our array with all possible degrees of freedom\r\n\t\t\tlockedJointDoF.set( j, new Uint8Array( 6 ) );\r\n\t\t\tprevDoFValues.set( j, new Float64Array( 6 ) );\r\n\r\n\t\t} );\r\n\r\n\t\ttargets.forEach( target => {\r\n\r\n\t\t\tif ( target.isClosure ) {\r\n\r\n\t\t\t\tlet currJoint = target;\r\n\r\n\t\t\t\t// climb the joint tree and mark every joint as affecting this closure end.\r\n\t\t\t\twhile ( currJoint ) {\r\n\r\n\t\t\t\t\tif ( currJoint.isJoint ) {\r\n\r\n\t\t\t\t\t\taffectedClosures.get( currJoint ).add( target );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcurrJoint = currJoint.parent;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// and mark the joints up the other chain as effecting the other connector link.\r\n\t\t\t\tcurrJoint = target.child;\r\n\t\t\t\twhile ( currJoint ) {\r\n\r\n\t\t\t\t\tif ( currJoint.isJoint ) {\r\n\r\n\t\t\t\t\t\taffectedConnectedClosures.get( currJoint ).add( target );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcurrJoint = currJoint.parent;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tthis.targets = targets;\r\n\t\tthis.affectedClosures = affectedClosures;\r\n\t\tthis.affectedConnectedClosures = affectedConnectedClosures;\r\n\t\tthis.lockedJointDoF = lockedJointDoF;\r\n\t\tthis.lockedJointDoFCount = lockedJointDoFCount;\r\n\t\tthis.prevDoFValues = prevDoFValues;\r\n\r\n\t}\r\n\r\n\tsolve() {\r\n\r\n\t\tconst {\r\n\t\t\tdivergeThreshold,\r\n\t\t\tstallThreshold,\r\n\t\t\tchain,\r\n\t\t\trestPoseFactor,\r\n\t\t\tlockedJointDoFCount,\r\n\t\t\tprevDoFValues,\r\n\t\t\tuseSVD,\r\n\t\t\tmatrixPool,\r\n\t\t} = this;\r\n\r\n\t\tlet iterations = 0;\r\n\t\tlet prevErrorMagnitude = Infinity;\r\n\t\tlet status = - 1;\r\n\r\n\t\t// Clear out all the locked joints\r\n\t\tlockedJointDoFCount.clear();\r\n\r\n\t\t// TODO: instead of trying to use minimal euler angles we should try to represent joint\r\n\t\t// error as a quaternion in the quaternion vector.\r\n\t\tfor ( let i = 0, l = chain.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst joint = chain[ i ];\r\n\t\t\tif ( joint.targetSet || joint.restPoseSet ) {\r\n\r\n\t\t\t\tjoint.tryMinimizeEulerAngles();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tdo {\r\n\r\n\t\t\tmatrixPool.releaseAll();\r\n\r\n\t\t\t// Make sure our matrices are all up to date\r\n\t\t\tfor ( let i = 0, l = chain.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst joint = chain[ i ];\r\n\t\t\t\tjoint.updateMatrixWorld();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// TODO: this only needs to be recomputed if a joint was locked so maybe lets check that? We also\r\n\t\t\t// lock joints inside this function so maybe we can forgo that?\r\n\t\t\ttargetJoints.length = 0;\r\n\t\t\tfreeJoints.length = 0;\r\n\t\t\tthis.countUnconvergedVariables( freeJoints, targetJoints, dofResultInfo );\r\n\t\t\tconst { freeDoF, errorRows, totalError } = dofResultInfo;\r\n\r\n\t\t\t// Check if we've converged\r\n\t\t\tif ( errorRows === 0 ) {\r\n\r\n\t\t\t\tstatus = SOLVE_STATUS.CONVERGED;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Check if we've diverged\r\n\t\t\tif ( totalError > prevErrorMagnitude + divergeThreshold ) {\r\n\r\n\t\t\t\tprevDoFValues.forEach( ( dofValues, joint ) => {\r\n\r\n\t\t\t\t\tjoint.dofValues.set( dofValues );\r\n\t\t\t\t\tjoint.setMatrixDoFNeedsUpdate();\r\n\r\n\t\t\t\t} );\r\n\r\n\r\n\t\t\t\tstatus = SOLVE_STATUS.DIVERGED;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tprevErrorMagnitude = totalError;\r\n\r\n\t\t\t// Check if we've hit max iterations\r\n\t\t\titerations ++;\r\n\t\t\tif ( iterations > this.maxIterations ) {\r\n\r\n\t\t\t\tstatus = SOLVE_STATUS.TIMEOUT;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// A * x = b\r\n\t\t\t// find x such that it yields b where is the clamped error we're trying to work towards\r\n\t\t\t// and A is the jacobian, and x is the delta joint angles.\r\n\r\n\t\t\tconst errorVector = matrixPool.get( errorRows, 1 );\r\n\t\t\tthis.fillErrorVector( targetJoints, errorVector );\r\n\r\n\t\t\tconst jacobian = matrixPool.get( errorRows, freeDoF );\r\n\t\t\tthis.fillJacobian( targetJoints, freeJoints, jacobian );\r\n\r\n\t\t\t// Solve for the pseudo inverse of the jacobian\r\n\t\t\tconst pseudoInverse = matrixPool.get( freeDoF, errorRows );\r\n\t\t\tlet failedSVD = false;\r\n\t\t\tif ( useSVD ) {\r\n\r\n\t\t\t\ttry {\r\n\r\n\t\t\t\t\tconst m = errorRows;\r\n\t\t\t\t\tconst n = freeDoF;\r\n\t\t\t\t\tconst k = Math.min( m, n );\r\n\r\n\t\t\t\t\tconst u = matrixPool.get( m, k ); // m x k\r\n\t\t\t\t\tconst q = matrixPool.get( k, k ); // k x k\r\n\t\t\t\t\tconst v = matrixPool.get( n, k ); // ( k x n )^T -> ( n x k )\r\n\r\n\t\t\t\t\tmat.svd( u, q, v, jacobian );\r\n\r\n\t\t\t\t\tconst uTranspose = matrixPool.get( k, m );\r\n\t\t\t\t\tconst qInverse = matrixPool.get( k, k );\r\n\t\t\t\t\tmat.transpose( uTranspose, u );\r\n\r\n\t\t\t\t\t// if the diagonal value is close to 0 when taking the inverse\r\n\t\t\t\t\t// then set it to zero.\r\n\t\t\t\t\tfor ( let i = 0, l = q.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\tconst val = q[ i ][ i ];\r\n\t\t\t\t\t\tlet inv;\r\n\t\t\t\t\t\tif ( Math.abs( val ) < 0.001 ) {\r\n\r\n\t\t\t\t\t\t\tinv = 0;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tinv = 1 / val;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tqInverse[ i ][ i ] = inv;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// V * Qinv * Ut\r\n\t\t\t\t\tconst vqinv = matrixPool.get( n, k );\r\n\t\t\t\t\tmat.multiply( vqinv, v, qInverse );\r\n\t\t\t\t\tmat.multiply( pseudoInverse, vqinv, uTranspose );\r\n\r\n\t\t\t\t} catch ( err ) {\r\n\r\n\t\t\t\t\tfailedSVD = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! useSVD || failedSVD ) {\r\n\r\n\t\t\t\t// Use a transpose pseudo inverse approach: A^T * A * x = A^T * b with the damping term\r\n\t\t\t\t// J^T * J * x = J^T * e\r\n\t\t\t\t// x = J^T * ( J * J^T )^-1 * e\r\n\r\n\t\t\t\t// and with the adding damping\r\n\t\t\t\t// x = J^T * ( J * J^T + l^2 * I )^-1 * e\r\n\r\n\t\t\t\t// l^2 * I\r\n\t\t\t\tconst jacobianIdentityDamping = matrixPool.get( errorRows, errorRows );\r\n\t\t\t\tmat.identity( jacobianIdentityDamping );\r\n\t\t\t\tmat.scale( jacobianIdentityDamping, jacobianIdentityDamping, this.dampingFactor ** 2 );\r\n\r\n\t\t\t\t// J^T\r\n\t\t\t\tconst jacobianTranspose = matrixPool.get( freeDoF, errorRows );\r\n\t\t\t\tmat.transpose( jacobianTranspose, jacobian );\r\n\r\n\t\t\t\t// J * J^T\r\n\t\t\t\tconst jjt = matrixPool.get( errorRows, errorRows );\r\n\t\t\t\tmat.multiply( jjt, jacobian, jacobianTranspose );\r\n\r\n\t\t\t\t// J * J^T + l^2 * I\r\n\t\t\t\tconst jjti = matrixPool.get( errorRows, errorRows );\r\n\t\t\t\tmat.add( jjti, jjt, jacobianIdentityDamping );\r\n\r\n\t\t\t\t// ( J * J^T + l^2 * I )^-1\r\n\t\t\t\tconst jjtii = matrixPool.get( errorRows, errorRows );\r\n\t\t\t\tmat.invert( jjtii, jjti );\r\n\r\n\t\t\t\t// J^T * ( J * J^T + l^2 * I )^-1\r\n\t\t\t\tmat.multiply( pseudoInverse, jacobianTranspose, jjtii );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// x = deltaTheta = J^T * ( J * J^T + l^2 * I )^-1 * e\r\n\t\t\tconst deltaTheta = matrixPool.get( freeDoF, 1 );\r\n\t\t\tmat.multiply( deltaTheta, pseudoInverse, errorVector );\r\n\r\n\t\t\tif ( restPoseFactor !== 0 ) {\r\n\r\n\t\t\t\t// Nullspace Projection\r\n\t\t\t\t// I - J^-1 * J is the orthogonal null space of J where J^-1 is the pseudoinverse\r\n\t\t\t\t// Multiplied by the rest position of each dof\r\n\t\t\t\t// ( I - J^-1 * J ) * restPose\r\n\t\t\t\tconst restPose = matrixPool.get( freeDoF, 1 );\r\n\t\t\t\tconst restPoseResult = matrixPool.get( freeDoF, 1 );\r\n\t\t\t\tlet colIndex = 0;\r\n\t\t\t\tfor ( let i = 0, l = freeJoints.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst joint = freeJoints[ i ];\r\n\t\t\t\t\tconst lockedDoFCount = this.lockedJointDoFCount.get( joint ) || 0;\r\n\t\t\t\t\tconst isLocked = lockedDoFCount !== 0;\r\n\t\t\t\t\tconst lockedDoF = this.lockedJointDoF.get( joint );\r\n\r\n\t\t\t\t\tconst colCount = joint.rotationDoFCount + joint.translationDoFCount - lockedDoFCount;\r\n\t\t\t\t\tif ( joint.restPoseSet ) {\r\n\r\n\t\t\t\t\t\tconst dofList = joint.dof;\r\n\t\t\t\t\t\tconst dofValues = joint.dofValues;\r\n\t\t\t\t\t\tconst dofRestPose = joint.dofRestPose;\r\n\t\t\t\t\t\tfor ( let d = 0; d < colCount; d ++ ) {\r\n\r\n\t\t\t\t\t\t\tconst dof = dofList[ d ];\r\n\r\n\t\t\t\t\t\t\tif ( isLocked && lockedDoF[ dof ] ) continue;\r\n\r\n\t\t\t\t\t\t\trestPose[ colIndex ][ 0 ] = dofRestPose[ dof ] - dofValues[ dof ];\r\n\t\t\t\t\t\t\tcolIndex ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tfor ( let d = 0; d < colCount; d ++ ) {\r\n\r\n\t\t\t\t\t\t\trestPose[ colIndex ][ 0 ] = 0;\r\n\t\t\t\t\t\t\tcolIndex ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// J^-1 * J\r\n\t\t\t\tconst jij = matrixPool.get( freeDoF, freeDoF );\r\n\t\t\t\tmat.multiply( jij, pseudoInverse, jacobian );\r\n\r\n\t\t\t\t// ( I - J^-1 * J )\r\n\t\t\t\tconst ident = matrixPool.get( freeDoF, freeDoF );\r\n\t\t\t\tmat.identity( ident );\r\n\r\n\t\t\t\tconst nullSpaceProjection = matrixPool.get( freeDoF, freeDoF );\r\n\t\t\t\tmat.subtract( nullSpaceProjection, ident, jij );\r\n\r\n\t\t\t\t// ( I - J^-1 * J ) * restPose\r\n\t\t\t\tmat.multiply( restPoseResult, nullSpaceProjection, restPose );\r\n\r\n\t\t\t\tfor ( let r = 0; r < freeDoF; r ++ ) {\r\n\r\n\t\t\t\t\tconst val = restPoseResult[ r ][ 0 ];\r\n\t\t\t\t\tdeltaTheta[ r ][ 0 ] += val * restPoseFactor;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Check if our joints have not moved and returned stalled\r\n\t\t\tif ( stallThreshold > 0 ) {\r\n\r\n\t\t\t\tlet stalled = true;\r\n\t\t\t\tfor ( let i = 0, l = deltaTheta.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst delta = deltaTheta[ i ][ 0 ];\r\n\t\t\t\t\tif ( Math.abs( delta ) > stallThreshold ) {\r\n\r\n\t\t\t\t\t\tstalled = false;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( stalled ) {\r\n\r\n\t\t\t\t\tstatus = SOLVE_STATUS.STALLED;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Prep for a divergence check\r\n\t\t\tprevDoFValues.forEach( ( dofValues, joint ) => {\r\n\r\n\t\t\t\tdofValues.set( joint.dofValues );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\t// apply the latest joint angles and lock and joints that have\r\n\t\t\t// hit their joint limits.\r\n\t\t\tthis.applyJointAngles( freeJoints, deltaTheta );\r\n\r\n\t\t\t// there's still error and we're under the max iterations\r\n\r\n\t\t} while ( true );\r\n\r\n\t\ttargetJoints.length = 0;\r\n\t\tfreeJoints.length = 0;\r\n\t\treturn status;\r\n\r\n\t}\r\n\r\n\t// Apply the delta values from the solve to the free joints in the list\r\n\tapplyJointAngles( freeJoints, deltaTheta ) {\r\n\r\n\t\tconst {\r\n\t\t\tlockedJointDoF,\r\n\t\t\tlockedJointDoFCount,\r\n\t\t} = this;\r\n\r\n\t\tlet lockedJoint = false;\r\n\t\tlet dti = 0;\r\n\t\tfor ( let i = 0, l = freeJoints.length; i < l; i ++ ) {\r\n\r\n\t\t\t// Apply the delta to every free joint\r\n\t\t\tconst joint = freeJoints[ i ];\r\n\t\t\tconst dofList = joint.dof;\r\n\t\t\tconst lockedDoF = lockedJointDoF.get( joint );\r\n\t\t\tconst isLocked = lockedJointDoFCount.has( joint );\r\n\r\n\t\t\tfor ( let d = 0, l = dofList.length; d < l; d ++ ) {\r\n\r\n\t\t\t\tconst dof = dofList[ d ];\r\n\t\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst value = joint.getDoFValue( dof );\r\n\t\t\t\tconst hitLimit = joint.setDoFValue( dof, value + deltaTheta[ dti ][ 0 ] );\r\n\r\n\t\t\t\t// lock the joint if we hit a limit\r\n\t\t\t\tif ( hitLimit ) {\r\n\r\n\t\t\t\t\tif ( ! lockedJointDoFCount.has( joint ) ) {\r\n\r\n\t\t\t\t\t\tlockedJointDoFCount.set( joint, 0 );\r\n\t\t\t\t\t\tlockedDoF.fill( 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst lockedCount = lockedJointDoFCount.get( joint );\r\n\t\t\t\t\tlockedJointDoFCount.set( joint, lockedCount + 1 );\r\n\t\t\t\t\tlockedDoF[ dof ] = 1;\r\n\t\t\t\t\tlockedJoint = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdti ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dti !== deltaTheta.length ) {\r\n\r\n\t\t\tthrow new Error();\r\n\r\n\t\t}\r\n\r\n\t\treturn lockedJoint;\r\n\r\n\t}\r\n\r\n\t// generate the jacobian\r\n\t// The jacobian has one column for each free degree of freedom and a row for every\r\n\t// target degree of freedom we have. The entries are generated by adjusting every\r\n\t// DoF by some epsilon and storing how much it affected the target error.\r\n\tfillJacobian( targetJoints, freeJoints, outJacobian ) {\r\n\r\n\t\tconst {\r\n\t\t\ttranslationStep,\r\n\t\t\trotationStep,\r\n\t\t\tlockedJointDoF,\r\n\t\t\tlockedJointDoFCount,\r\n\t\t\ttranslationFactor,\r\n\t\t\trotationFactor,\r\n\t\t} = this;\r\n\r\n\t\t// TODO: abstract this\r\n\t\tconst affectedClosures = this.affectedClosures;\r\n\t\tconst affectedConnectedClosures = this.affectedConnectedClosures;\r\n\r\n\t\tlet colIndex = 0;\r\n\t\tfor ( let c = 0, tc = freeJoints.length; c < tc; c ++ ) {\r\n\r\n\t\t\t// TODO: If this is a goal we should skip adding it to the jacabian columns\r\n\t\t\tconst freeJoint = freeJoints[ c ];\r\n\t\t\tconst relevantClosures = affectedClosures.get( freeJoint );\r\n\t\t\tconst relevantConnectedClosures = affectedConnectedClosures.get( freeJoint );\r\n\t\t\tconst dofList = freeJoint.dof;\r\n\t\t\tconst colCount = freeJoint.translationDoFCount + freeJoint.rotationDoFCount;\r\n\r\n\t\t\tconst isLocked = lockedJointDoFCount.has( freeJoint );\r\n\t\t\tconst lockedDoF = lockedJointDoF.get( freeJoint );\r\n\r\n\t\t\t// get the world inverse of the free joint\r\n\t\t\tmat4.invert( tempInverseMatrixWorld, freeJoint.matrixWorld );\r\n\r\n\t\t\t// iterate over every degree of freedom in the joint\r\n\t\t\tfor ( let co = 0; co < colCount; co ++ ) {\r\n\r\n\t\t\t\tconst dof = dofList[ co ];\r\n\r\n\t\t\t\t// skip this joint if it's locked\r\n\t\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet rowIndex = 0;\r\n\r\n\t\t\t\t// generate the adjusted matrix based on the epsilon for the joint.\r\n\t\t\t\tlet delta = dof < 3 ? translationStep : rotationStep;\r\n\t\t\t\tif ( freeJoint.getDeltaWorldMatrix( dof, delta, tempDeltaWorldMatrix ) ) {\r\n\r\n\t\t\t\t\tdelta *= - 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Iterate over every target\r\n\t\t\t\tfor ( let r = 0, tr = targetJoints.length; r < tr; r ++ ) {\r\n\r\n\t\t\t\t\tconst targetJoint = targetJoints[ r ];\r\n\r\n\t\t\t\t\t// if it's a closure target\r\n\t\t\t\t\tif ( targetJoint.isClosure ) {\r\n\r\n\t\t\t\t\t\tif ( relevantClosures.has( targetJoint ) || relevantConnectedClosures.has( targetJoint ) ) {\r\n\r\n\t\t\t\t\t\t\t// TODO: If this is a Goal it only add 1 or 2 fields if only two axes are set. Quat is only\r\n\t\t\t\t\t\t\t// needed if 3 eulers are used.\r\n\t\t\t\t\t\t\t// TODO: these could be cached per target joint get the current error within the closure joint\r\n\r\n\t\t\t\t\t\t\t// Get the error from child towards the closure target\r\n\t\t\t\t\t\t\ttargetJoint.getClosureError( tempPos, tempQuat );\r\n\t\t\t\t\t\t\tif ( relevantConnectedClosures.has( targetJoint ) ) {\r\n\r\n\t\t\t\t\t\t\t\t// If this is affecting a link connected to a closure joint then adjust that child link by\r\n\t\t\t\t\t\t\t\t// the delta rotation.\r\n\t\t\t\t\t\t\t\tmat4.multiply( targetRelativeToJointMatrix, tempInverseMatrixWorld, targetJoint.child.matrixWorld );\r\n\t\t\t\t\t\t\t\tmat4.multiply( targetDeltaWorldMatrix, tempDeltaWorldMatrix, targetRelativeToJointMatrix );\r\n\r\n\t\t\t\t\t\t\t\t// Get the new error\r\n\t\t\t\t\t\t\t\tgetMatrixDifference( targetJoint.matrixWorld, targetDeltaWorldMatrix, tempPos2, tempQuat2 );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t// If this is directly affecting a closure joint then adjust that child link by the delta\r\n\t\t\t\t\t\t\t\t// rotation.\r\n\t\t\t\t\t\t\t\tmat4.multiply( targetRelativeToJointMatrix, tempInverseMatrixWorld, targetJoint.matrixWorld );\r\n\t\t\t\t\t\t\t\tmat4.multiply( targetDeltaWorldMatrix, tempDeltaWorldMatrix, targetRelativeToJointMatrix );\r\n\r\n\t\t\t\t\t\t\t\t// Get the new error\r\n\t\t\t\t\t\t\t\tgetMatrixDifference( targetDeltaWorldMatrix, targetJoint.child.matrixWorld, tempPos2, tempQuat2 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Get the amount that the rotation and translation error changed due to the\r\n\t\t\t\t\t\t\t// small DoF adjustment to serve as the derivative.\r\n\t\t\t\t\t\t\tvec3.subtract( tempPos, tempPos, tempPos2 );\r\n\t\t\t\t\t\t\tvec3.scale( tempPos, tempPos, translationFactor / delta );\r\n\r\n\t\t\t\t\t\t\tvec4.subtract( tempQuat, tempQuat, tempQuat2 );\r\n\t\t\t\t\t\t\tvec4.scale( tempQuat, tempQuat, rotationFactor / delta );\r\n\r\n\t\t\t\t\t\t\tif ( targetJoint.isGoal ) {\r\n\r\n\t\t\t\t\t\t\t\tconst { translationDoFCount, rotationDoFCount, dof } = targetJoint;\r\n\t\t\t\t\t\t\t\tfor ( let i = 0; i < translationDoFCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\tconst d = dof[ i ];\r\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + i ][ colIndex ] = tempPos[ d ];\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif ( rotationDoFCount === 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 0 ][ colIndex ] = tempQuat[ 0 ];\r\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 1 ][ colIndex ] = tempQuat[ 1 ];\r\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 2 ][ colIndex ] = tempQuat[ 2 ];\r\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 3 ][ colIndex ] = tempQuat[ 3 ];\r\n\t\t\t\t\t\t\t\t\trowIndex += 4;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\trowIndex += translationDoFCount;\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t// set translation\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 0 ][ colIndex ] = tempPos[ 0 ];\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 1 ][ colIndex ] = tempPos[ 1 ];\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 2 ][ colIndex ] = tempPos[ 2 ];\r\n\r\n\t\t\t\t\t\t\t\t// set rotation\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 3 ][ colIndex ] = tempQuat[ 0 ];\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 4 ][ colIndex ] = tempQuat[ 1 ];\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 5 ][ colIndex ] = tempQuat[ 2 ];\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 6 ][ colIndex ] = tempQuat[ 3 ];\r\n\t\t\t\t\t\t\t\trowIndex += 7;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// if the target isn't relevant then there's no delta\r\n\t\t\t\t\t\t\tlet totalRows = 7;\r\n\t\t\t\t\t\t\tif ( targetJoint.isGoal ) {\r\n\r\n\t\t\t\t\t\t\t\ttotalRows = targetJoint.translationDoFCount;\r\n\t\t\t\t\t\t\t\tif ( targetJoint.rotationDoFCount === 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\ttotalRows += 4;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tfor ( let i = 0; i < totalRows; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + i ][ colIndex ] = 0;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\trowIndex += totalRows;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Check if this joint has a target set and update the jacobian rows if it does\r\n\t\t\t\t\tif ( targetJoint.targetSet ) {\r\n\r\n\t\t\t\t\t\tconst rowCount = targetJoint.translationDoFCount + targetJoint.rotationDoFCount;\r\n\r\n\t\t\t\t\t\tif ( freeJoint === targetJoint ) {\r\n\r\n\t\t\t\t\t\t\t// if we're just dealing with a target dof joint then there can't be any influence\r\n\t\t\t\t\t\t\t// but otherwise the only joint that can have an effect on this error is the joint\r\n\t\t\t\t\t\t\t// itself.\r\n\t\t\t\t\t\t\t// TODO: Having noted that is this really necessary? Is there any way that this doesn't just\r\n\t\t\t\t\t\t\t// jump to the solution and lock? How can we afford some slack? With a low weight? Does that\r\n\t\t\t\t\t\t\t// get applied here?\r\n\t\t\t\t\t\t\t// TODO: If this joint happens to have three euler joints we need to use a quat here. Otherwise we\r\n\t\t\t\t\t\t\t// use the euler angles.\r\n\t\t\t\t\t\t\tfor ( let i = 0; i < rowCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + colIndex ][ colIndex ] = - 1;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( let i = 0; i < rowCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + i ][ colIndex ] = 0;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\trowIndex += rowCount;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcolIndex ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( colIndex !== outJacobian[ 0 ].length ) {\r\n\r\n\t\t\tthrow new Error();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Fill in the error vector\r\n\tfillErrorVector( targetJoints, errorVector ) {\r\n\r\n\t\tlet rowIndex = 0;\r\n\t\tfor ( let i = 0, l = targetJoints.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst joint = targetJoints[ i ];\r\n\t\t\tif ( joint.isClosure ) {\r\n\r\n\t\t\t\taccumulateClosureError( this, joint, rowIndex, errorVector, errorResultInfo );\r\n\t\t\t\trowIndex += errorResultInfo.rowCount;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( joint.targetSet ) {\r\n\r\n\t\t\t\taccumulateTargetError( this, joint, rowIndex, errorVector, errorResultInfo );\r\n\t\t\t\trowIndex += errorResultInfo.rowCount;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Count the unconverged targets in the chain and store them in targetJoints and store\r\n\t// any freeJoints in\r\n\tcountUnconvergedVariables( freeJoints, targetJoints, dofResultInfo ) {\r\n\r\n\t\tconst { lockedJointDoFCount } = this;\r\n\r\n\t\tconst chain = this.chain;\r\n\t\tlet totalError = 0;\r\n\t\tlet errorRows = 0;\r\n\t\tlet unconvergedRows = 0;\r\n\t\tlet freeDoF = 0;\r\n\t\tfor ( let i = 0, l = chain.length; i < l; i ++ ) {\r\n\r\n\t\t\tlet addToTargetList = false;\r\n\t\t\tconst joint = chain[ i ];\r\n\t\t\tconst lockedDoF = lockedJointDoFCount.get( joint ) || 0;\r\n\r\n\t\t\t// TODO: Should we check every variable against the convergence threshold or is\r\n\t\t\t// it better to check the magnitude?\r\n\r\n\t\t\t// TODO: We may be able to speed this up by using the square distance and length\r\n\t\t\t// to compare error.\r\n\r\n\t\t\t// TODO: If this is a goal we shouldnt add to the free dof because they won't be added\r\n\t\t\t// to the jacobian\r\n\r\n\t\t\t// If this is a closure joint then we need to make sure we're solving\r\n\t\t\t// for the other child end to meet this joint so this error is important.\r\n\t\t\tif ( joint.isClosure ) {\r\n\r\n\t\t\t\taccumulateClosureError( this, joint, errorRows, null, errorResultInfo );\r\n\t\t\t\tif ( ! errorResultInfo.isConverged ) {\r\n\r\n\t\t\t\t\tunconvergedRows += errorResultInfo.rowCount;\r\n\t\t\t\t\ttotalError += errorResultInfo.totalError;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\taddToTargetList = true;\r\n\t\t\t\terrorRows += errorResultInfo.rowCount;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Check out far the joint is from the target dof value.\r\n\t\t\tconst dofList = joint.dof;\r\n\t\t\tif ( joint.targetSet ) {\r\n\r\n\t\t\t\taccumulateTargetError( this, joint, errorRows, null, errorResultInfo );\r\n\t\t\t\tif ( ! errorResultInfo.isConverged ) {\r\n\r\n\t\t\t\t\tunconvergedRows += errorResultInfo.rowCount;\r\n\t\t\t\t\ttotalError += errorResultInfo.totalError;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\taddToTargetList = true;\r\n\t\t\t\terrorRows += errorResultInfo.rowCount;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! joint.isGoal && dofList.length > 0 ) {\r\n\r\n\t\t\t\tfreeDoF += dofList.length - lockedDoF;\r\n\t\t\t\tfreeJoints.push( joint );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( addToTargetList ) {\r\n\r\n\t\t\t\ttargetJoints.push( joint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// if it turns out that everything is converged.\r\n\t\tif ( unconvergedRows === 0 ) {\r\n\r\n\t\t\terrorRows = 0;\r\n\r\n\t\t}\r\n\r\n\t\tdofResultInfo.errorRows = errorRows;\r\n\t\tdofResultInfo.freeDoF = freeDoF;\r\n\t\tdofResultInfo.totalError = totalError;\r\n\r\n\t}\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}