{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, sumOutType, UnsortedSegmentSum, util } from '@tensorflow/tfjs-core';\nimport { SegmentOpProgram } from '../segment_gpu';\nimport { range } from './Range';\nimport { reshape } from './Reshape';\nimport { tile } from './Tile';\nimport { transpose } from './Transpose';\nexport function unsortedSegmentSum(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x,\n    segmentIds\n  } = inputs;\n  const {\n    numSegments\n  } = attrs;\n  const xRank = x.shape.length;\n  const toDispose = [];\n  let axis = 0;\n  const permutation = backend_util.getAxesPermutation([axis], xRank);\n  let permutedX = x;\n\n  if (permutation != null) {\n    permutedX = transpose({\n      inputs: {\n        x\n      },\n      backend,\n      attrs: {\n        perm: permutation\n      }\n    });\n    toDispose.push(permutedX);\n    axis = backend_util.getInnerMostAxes(1, xRank)[0];\n  }\n\n  const outShape = backend_util.segment_util.computeOutShape(permutedX.shape, axis, numSegments);\n  const inSize = util.sizeFromShape([permutedX.shape[axis]]);\n  const a2D = reshape({\n    inputs: {\n      x: permutedX\n    },\n    backend,\n    attrs: {\n      shape: [-1, inSize]\n    }\n  });\n  toDispose.push(a2D);\n  const outputDType = sumOutType(x.dtype);\n\n  const segOpCompute = (x, segOpType, segmentIds, dtype, numSegments) => {\n    const batchSize = x.shape[0];\n    const inSize = x.shape[1];\n    const windowSize = backend_util.segment_util.segOpComputeOptimalWindowSize(inSize, numSegments);\n    const segOpInfo = {\n      windowSize,\n      inSize,\n      batchSize,\n      numSegments\n    };\n    const program = new SegmentOpProgram(segOpInfo, segOpType);\n    const output = backend.compileAndRun(program, [x, segmentIds], dtype);\n    toDispose.push(output); // No need to run another GPGPU program.\n\n    if (output.shape[1] === numSegments) {\n      return output;\n    }\n\n    const rangeInfo = range({\n      backend,\n      attrs: {\n        start: 0,\n        stop: numSegments,\n        step: 1,\n        dtype: 'float32'\n      }\n    });\n    const tileInfo = tile({\n      inputs: {\n        x: rangeInfo\n      },\n      backend,\n      attrs: {\n        reps: [inSize / windowSize]\n      }\n    });\n    toDispose.push(rangeInfo);\n    toDispose.push(tileInfo);\n    const result = segOpCompute(output, segOpType, tileInfo, dtype, numSegments);\n    return result;\n  };\n\n  const segOpResult = segOpCompute(a2D, 'unsortedSegmentSum', segmentIds, outputDType, numSegments);\n  const reshaped = reshape({\n    inputs: {\n      x: segOpResult\n    },\n    backend,\n    attrs: {\n      shape: outShape\n    }\n  });\n  let result = reshaped;\n\n  if (permutation != null) {\n    toDispose.push(reshaped);\n    const perm = backend_util.getUndoAxesPermutation(permutation);\n    result = transpose({\n      inputs: {\n        x: result\n      },\n      backend,\n      attrs: {\n        perm\n      }\n    });\n  }\n\n  toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n  return result;\n}\nexport const unsortedSegmentSumConfig = {\n  kernelName: UnsortedSegmentSum,\n  backendName: 'webgl',\n  kernelFunc: unsortedSegmentSum\n};","map":{"version":3,"names":["backend_util","sumOutType","UnsortedSegmentSum","util","SegmentOpProgram","range","reshape","tile","transpose","unsortedSegmentSum","args","inputs","backend","attrs","x","segmentIds","numSegments","xRank","shape","length","toDispose","axis","permutation","getAxesPermutation","permutedX","perm","push","getInnerMostAxes","outShape","segment_util","computeOutShape","inSize","sizeFromShape","a2D","outputDType","dtype","segOpCompute","segOpType","batchSize","windowSize","segOpComputeOptimalWindowSize","segOpInfo","program","output","compileAndRun","rangeInfo","start","stop","step","tileInfo","reps","result","segOpResult","reshaped","getUndoAxesPermutation","forEach","t","disposeIntermediateTensorInfo","unsortedSegmentSumConfig","kernelName","backendName","kernelFunc"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/UnsortedSegmentSum.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, sumOutType, UnsortedSegmentSum, util } from '@tensorflow/tfjs-core';\nimport { SegmentOpProgram } from '../segment_gpu';\nimport { range } from './Range';\nimport { reshape } from './Reshape';\nimport { tile } from './Tile';\nimport { transpose } from './Transpose';\nexport function unsortedSegmentSum(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, segmentIds } = inputs;\n    const { numSegments } = attrs;\n    const xRank = x.shape.length;\n    const toDispose = [];\n    let axis = 0;\n    const permutation = backend_util.getAxesPermutation([axis], xRank);\n    let permutedX = x;\n    if (permutation != null) {\n        permutedX = transpose({ inputs: { x }, backend, attrs: { perm: permutation } });\n        toDispose.push(permutedX);\n        axis = backend_util.getInnerMostAxes(1, xRank)[0];\n    }\n    const outShape = backend_util.segment_util.computeOutShape(permutedX.shape, axis, numSegments);\n    const inSize = util.sizeFromShape([permutedX.shape[axis]]);\n    const a2D = reshape({ inputs: { x: permutedX }, backend, attrs: { shape: [-1, inSize] } });\n    toDispose.push(a2D);\n    const outputDType = sumOutType(x.dtype);\n    const segOpCompute = (x, segOpType, segmentIds, dtype, numSegments) => {\n        const batchSize = x.shape[0];\n        const inSize = x.shape[1];\n        const windowSize = backend_util.segment_util.segOpComputeOptimalWindowSize(inSize, numSegments);\n        const segOpInfo = { windowSize, inSize, batchSize, numSegments };\n        const program = new SegmentOpProgram(segOpInfo, segOpType);\n        const output = backend.compileAndRun(program, [x, segmentIds], dtype);\n        toDispose.push(output);\n        // No need to run another GPGPU program.\n        if (output.shape[1] === numSegments) {\n            return output;\n        }\n        const rangeInfo = range({\n            backend,\n            attrs: { start: 0, stop: numSegments, step: 1, dtype: 'float32' }\n        });\n        const tileInfo = tile({\n            inputs: { x: rangeInfo },\n            backend,\n            attrs: { reps: [inSize / windowSize] }\n        });\n        toDispose.push(rangeInfo);\n        toDispose.push(tileInfo);\n        const result = segOpCompute(output, segOpType, tileInfo, dtype, numSegments);\n        return result;\n    };\n    const segOpResult = segOpCompute(a2D, 'unsortedSegmentSum', segmentIds, outputDType, numSegments);\n    const reshaped = reshape({ inputs: { x: segOpResult }, backend, attrs: { shape: outShape } });\n    let result = reshaped;\n    if (permutation != null) {\n        toDispose.push(reshaped);\n        const perm = backend_util.getUndoAxesPermutation(permutation);\n        result = transpose({ inputs: { x: result }, backend, attrs: { perm } });\n    }\n    toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n    return result;\n}\nexport const unsortedSegmentSumConfig = {\n    kernelName: UnsortedSegmentSum,\n    backendName: 'webgl',\n    kernelFunc: unsortedSegmentSum\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}