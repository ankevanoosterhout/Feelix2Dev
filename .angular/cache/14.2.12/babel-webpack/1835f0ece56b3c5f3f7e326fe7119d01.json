{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * Merges real and imaginary Float32Arrays into a single complex Float32Array.\n *\n * The memory layout is interleaved as follows:\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n * complex: [r0, i0, r1, i1, r2, i2]\n *\n * This is the inverse of splitRealAndImagArrays.\n *\n * @param real The real values of the complex tensor values.\n * @param imag The imag values of the complex tensor values.\n * @returns A complex tensor as a Float32Array with merged values.\n */\nexport function mergeRealAndImagArrays(real, imag) {\n  if (real.length !== imag.length) {\n    throw new Error(`Cannot merge real and imag arrays of different lengths. real:` + `${real.length}, imag: ${imag.length}.`);\n  }\n\n  const result = new Float32Array(real.length * 2);\n\n  for (let i = 0; i < result.length; i += 2) {\n    result[i] = real[i / 2];\n    result[i + 1] = imag[i / 2];\n  }\n\n  return result;\n}\n/**\n * Splits a complex Float32Array into real and imag parts.\n *\n * The memory layout is interleaved as follows:\n * complex: [r0, i0, r1, i1, r2, i2]\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n *\n * This is the inverse of mergeRealAndImagArrays.\n *\n * @param complex The complex tensor values.\n * @returns An object with real and imag Float32Array components of the complex\n *     tensor.\n */\n\nexport function splitRealAndImagArrays(complex) {\n  const real = new Float32Array(complex.length / 2);\n  const imag = new Float32Array(complex.length / 2);\n\n  for (let i = 0; i < complex.length; i += 2) {\n    real[i / 2] = complex[i];\n    imag[i / 2] = complex[i + 1];\n  }\n\n  return {\n    real,\n    imag\n  };\n}\n/**\n * Extracts even indexed complex values in the given array.\n * @param complex The complex tensor values\n */\n\nexport function complexWithEvenIndex(complex) {\n  const len = Math.ceil(complex.length / 4);\n  const real = new Float32Array(len);\n  const imag = new Float32Array(len);\n\n  for (let i = 0; i < complex.length; i += 4) {\n    real[Math.floor(i / 4)] = complex[i];\n    imag[Math.floor(i / 4)] = complex[i + 1];\n  }\n\n  return {\n    real,\n    imag\n  };\n}\n/**\n * Extracts odd indexed comple values in the given array.\n * @param complex The complex tensor values\n */\n\nexport function complexWithOddIndex(complex) {\n  const len = Math.floor(complex.length / 4);\n  const real = new Float32Array(len);\n  const imag = new Float32Array(len);\n\n  for (let i = 2; i < complex.length; i += 4) {\n    real[Math.floor(i / 4)] = complex[i];\n    imag[Math.floor(i / 4)] = complex[i + 1];\n  }\n\n  return {\n    real,\n    imag\n  };\n}\n/**\n * Get the map representing a complex value in the given array.\n * @param complex The complex tensor values.\n * @param index An index of the target complex value.\n */\n\nexport function getComplexWithIndex(complex, index) {\n  const real = complex[index * 2];\n  const imag = complex[index * 2 + 1];\n  return {\n    real,\n    imag\n  };\n}\n/**\n * Insert a given complex value into the TypedArray.\n * @param data The array in which the complex value is inserted.\n * @param c The complex value to be inserted.\n * @param index An index of the target complex value.\n */\n\nexport function assignToTypedArray(data, real, imag, index) {\n  data[index * 2] = real;\n  data[index * 2 + 1] = imag;\n}\n/**\n * Make the list of exponent terms used by FFT.\n */\n\nexport function exponents(n, inverse) {\n  const real = new Float32Array(n / 2);\n  const imag = new Float32Array(n / 2);\n\n  for (let i = 0; i < Math.ceil(n / 2); i++) {\n    const x = (inverse ? 2 : -2) * Math.PI * (i / n);\n    real[i] = Math.cos(x);\n    imag[i] = Math.sin(x);\n  }\n\n  return {\n    real,\n    imag\n  };\n}\n/**\n * Make the exponent term used by FFT.\n */\n\nexport function exponent(k, n, inverse) {\n  const x = (inverse ? 2 : -2) * Math.PI * (k / n);\n  const real = Math.cos(x);\n  const imag = Math.sin(x);\n  return {\n    real,\n    imag\n  };\n}","map":{"version":3,"names":["mergeRealAndImagArrays","real","imag","length","Error","result","Float32Array","i","splitRealAndImagArrays","complex","complexWithEvenIndex","len","Math","ceil","floor","complexWithOddIndex","getComplexWithIndex","index","assignToTypedArray","data","exponents","n","inverse","x","PI","cos","sin","exponent","k"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-core/dist/backends/complex_util.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Merges real and imaginary Float32Arrays into a single complex Float32Array.\n *\n * The memory layout is interleaved as follows:\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n * complex: [r0, i0, r1, i1, r2, i2]\n *\n * This is the inverse of splitRealAndImagArrays.\n *\n * @param real The real values of the complex tensor values.\n * @param imag The imag values of the complex tensor values.\n * @returns A complex tensor as a Float32Array with merged values.\n */\nexport function mergeRealAndImagArrays(real, imag) {\n    if (real.length !== imag.length) {\n        throw new Error(`Cannot merge real and imag arrays of different lengths. real:` +\n            `${real.length}, imag: ${imag.length}.`);\n    }\n    const result = new Float32Array(real.length * 2);\n    for (let i = 0; i < result.length; i += 2) {\n        result[i] = real[i / 2];\n        result[i + 1] = imag[i / 2];\n    }\n    return result;\n}\n/**\n * Splits a complex Float32Array into real and imag parts.\n *\n * The memory layout is interleaved as follows:\n * complex: [r0, i0, r1, i1, r2, i2]\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n *\n * This is the inverse of mergeRealAndImagArrays.\n *\n * @param complex The complex tensor values.\n * @returns An object with real and imag Float32Array components of the complex\n *     tensor.\n */\nexport function splitRealAndImagArrays(complex) {\n    const real = new Float32Array(complex.length / 2);\n    const imag = new Float32Array(complex.length / 2);\n    for (let i = 0; i < complex.length; i += 2) {\n        real[i / 2] = complex[i];\n        imag[i / 2] = complex[i + 1];\n    }\n    return { real, imag };\n}\n/**\n * Extracts even indexed complex values in the given array.\n * @param complex The complex tensor values\n */\nexport function complexWithEvenIndex(complex) {\n    const len = Math.ceil(complex.length / 4);\n    const real = new Float32Array(len);\n    const imag = new Float32Array(len);\n    for (let i = 0; i < complex.length; i += 4) {\n        real[Math.floor(i / 4)] = complex[i];\n        imag[Math.floor(i / 4)] = complex[i + 1];\n    }\n    return { real, imag };\n}\n/**\n * Extracts odd indexed comple values in the given array.\n * @param complex The complex tensor values\n */\nexport function complexWithOddIndex(complex) {\n    const len = Math.floor(complex.length / 4);\n    const real = new Float32Array(len);\n    const imag = new Float32Array(len);\n    for (let i = 2; i < complex.length; i += 4) {\n        real[Math.floor(i / 4)] = complex[i];\n        imag[Math.floor(i / 4)] = complex[i + 1];\n    }\n    return { real, imag };\n}\n/**\n * Get the map representing a complex value in the given array.\n * @param complex The complex tensor values.\n * @param index An index of the target complex value.\n */\nexport function getComplexWithIndex(complex, index) {\n    const real = complex[index * 2];\n    const imag = complex[index * 2 + 1];\n    return { real, imag };\n}\n/**\n * Insert a given complex value into the TypedArray.\n * @param data The array in which the complex value is inserted.\n * @param c The complex value to be inserted.\n * @param index An index of the target complex value.\n */\nexport function assignToTypedArray(data, real, imag, index) {\n    data[index * 2] = real;\n    data[index * 2 + 1] = imag;\n}\n/**\n * Make the list of exponent terms used by FFT.\n */\nexport function exponents(n, inverse) {\n    const real = new Float32Array(n / 2);\n    const imag = new Float32Array(n / 2);\n    for (let i = 0; i < Math.ceil(n / 2); i++) {\n        const x = (inverse ? 2 : -2) * Math.PI * (i / n);\n        real[i] = Math.cos(x);\n        imag[i] = Math.sin(x);\n    }\n    return { real, imag };\n}\n/**\n * Make the exponent term used by FFT.\n */\nexport function exponent(k, n, inverse) {\n    const x = (inverse ? 2 : -2) * Math.PI * (k / n);\n    const real = Math.cos(x);\n    const imag = Math.sin(x);\n    return { real, imag };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}