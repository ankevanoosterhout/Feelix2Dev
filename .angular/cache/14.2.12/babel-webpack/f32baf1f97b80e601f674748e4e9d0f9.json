{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { serialization } from '@tensorflow/tfjs-core';\nimport { getUid } from '../backend/state';\nimport { ValueError } from '../errors';\nimport { Layer, Node, SymbolicTensor } from './topology';\nexport class InputLayer extends Layer {\n  constructor(args) {\n    super({\n      dtype: args.dtype,\n      name: args.name != null ? args.name : getUid('input').toString()\n    }); // Normalize config.batchSize and config.sparse\n\n    if (args.batchSize == null) {\n      args.batchSize = null;\n    }\n\n    if (args.sparse == null) {\n      args.sparse = false;\n    }\n\n    this.trainable = false;\n    this.built = true;\n    this.sparse = args.sparse;\n\n    if (args.inputShape != null && args.batchInputShape != null) {\n      throw new ValueError('Only provide the inputShape OR ' + 'batchInputShape argument to inputLayer, not both at the same time.');\n    }\n\n    let batchInputShape = args.batchInputShape;\n\n    if (batchInputShape == null) {\n      if (args.inputShape == null) {\n        throw new ValueError('An InputLayer should be passed either a ' + '`batchInputShape` or an `inputShape`.');\n      } else {\n        batchInputShape = [args.batchSize].concat(args.inputShape);\n      }\n    } else {\n      // TODO(michaelterry): Backport to PyKeras\n      if (args.batchSize != null) {\n        throw new ValueError('Cannot specify batchSize if batchInputShape is ' + 'specified when creating an InputLayer.');\n      }\n    }\n\n    const dtype = args.dtype || 'float32';\n    this.batchInputShape = batchInputShape;\n    this.dtype = dtype; // TODO(michaelterry): Backport this to PyKeras?\n\n    this.inputSpec = [{\n      shape: batchInputShape\n    }];\n    const inputTensor = new SymbolicTensor(this.dtype, this.batchInputShape, this, [], {}, this.name);\n    inputTensor.nodeIndex = 0;\n    inputTensor.tensorIndex = 0; // Create an input node to add to this.outboundNode.\n    // (This call has side effects.)\n    // tslint:disable-next-line:no-unused-expression\n\n    new Node({\n      outboundLayer: this,\n      inboundLayers: [],\n      nodeIndices: [],\n      tensorIndices: [],\n      inputTensors: [inputTensor],\n      outputTensors: [inputTensor],\n      inputMasks: [null],\n      outputMasks: [null],\n      inputShapes: [batchInputShape],\n      outputShapes: [batchInputShape]\n    });\n  }\n\n  apply(inputs, kwargs) {\n    throw new ValueError('Cannot pass any input to an ' + `InputLayer's apply() method. InputLayer name: ${this.name}`);\n  }\n\n  dispose() {\n    // dispose() for InputLayer is overridden as no-op.\n    return {\n      refCountAfterDispose: this._refCount,\n      numDisposedVariables: 0\n    };\n  }\n\n  getConfig() {\n    return {\n      batchInputShape: this.batchInputShape,\n      dtype: this.dtype,\n      sparse: this.sparse,\n      name: this.name\n    };\n  }\n\n}\n/** @nocollapse */\n\nInputLayer.className = 'InputLayer';\nserialization.registerClass(InputLayer);\nexport function Input(config) {\n  if (config.batchShape == null && config.shape == null) {\n    throw new Error('Please provide to Input either a `shape`' + ' or a `batchShape` argument. Note that ' + '`shape` does not include the batch ' + 'dimension.');\n  }\n\n  if (config.batchShape != null && config.shape != null) {\n    // TODO(michaelterry): Backport to PyKeras.\n    throw new ValueError('Please provide either a `shape` or `batchShape` ' + 'argument to Input, but not both.');\n  }\n\n  let batchShape = config.batchShape;\n\n  if (config.shape != null && batchShape == null) {\n    batchShape = [null].concat(config.shape);\n  }\n\n  let dtype = config.dtype;\n\n  if (dtype == null) {\n    dtype = 'float32';\n  }\n\n  const inputLayer = new InputLayer({\n    batchInputShape: batchShape,\n    name: config.name,\n    dtype,\n    sparse: config.sparse\n  });\n  const outputs = inputLayer.inboundNodes[0].outputTensors;\n  return outputs[0];\n}","map":{"version":3,"names":["serialization","getUid","ValueError","Layer","Node","SymbolicTensor","InputLayer","constructor","args","dtype","name","toString","batchSize","sparse","trainable","built","inputShape","batchInputShape","concat","inputSpec","shape","inputTensor","nodeIndex","tensorIndex","outboundLayer","inboundLayers","nodeIndices","tensorIndices","inputTensors","outputTensors","inputMasks","outputMasks","inputShapes","outputShapes","apply","inputs","kwargs","dispose","refCountAfterDispose","_refCount","numDisposedVariables","getConfig","className","registerClass","Input","config","batchShape","Error","inputLayer","outputs","inboundNodes"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-layers/dist/engine/input_layer.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { serialization } from '@tensorflow/tfjs-core';\nimport { getUid } from '../backend/state';\nimport { ValueError } from '../errors';\nimport { Layer, Node, SymbolicTensor } from './topology';\nexport class InputLayer extends Layer {\n    constructor(args) {\n        super({\n            dtype: args.dtype,\n            name: args.name != null ? args.name : getUid('input').toString()\n        });\n        // Normalize config.batchSize and config.sparse\n        if (args.batchSize == null) {\n            args.batchSize = null;\n        }\n        if (args.sparse == null) {\n            args.sparse = false;\n        }\n        this.trainable = false;\n        this.built = true;\n        this.sparse = args.sparse;\n        if (args.inputShape != null && args.batchInputShape != null) {\n            throw new ValueError('Only provide the inputShape OR ' +\n                'batchInputShape argument to inputLayer, not both at the same time.');\n        }\n        let batchInputShape = args.batchInputShape;\n        if (batchInputShape == null) {\n            if (args.inputShape == null) {\n                throw new ValueError('An InputLayer should be passed either a ' +\n                    '`batchInputShape` or an `inputShape`.');\n            }\n            else {\n                batchInputShape = [args.batchSize].concat(args.inputShape);\n            }\n        }\n        else {\n            // TODO(michaelterry): Backport to PyKeras\n            if (args.batchSize != null) {\n                throw new ValueError('Cannot specify batchSize if batchInputShape is ' +\n                    'specified when creating an InputLayer.');\n            }\n        }\n        const dtype = args.dtype || 'float32';\n        this.batchInputShape = batchInputShape;\n        this.dtype = dtype;\n        // TODO(michaelterry): Backport this to PyKeras?\n        this.inputSpec = [{ shape: batchInputShape }];\n        const inputTensor = new SymbolicTensor(this.dtype, this.batchInputShape, this, [], {}, this.name);\n        inputTensor.nodeIndex = 0;\n        inputTensor.tensorIndex = 0;\n        // Create an input node to add to this.outboundNode.\n        // (This call has side effects.)\n        // tslint:disable-next-line:no-unused-expression\n        new Node({\n            outboundLayer: this,\n            inboundLayers: [],\n            nodeIndices: [],\n            tensorIndices: [],\n            inputTensors: [inputTensor],\n            outputTensors: [inputTensor],\n            inputMasks: [null],\n            outputMasks: [null],\n            inputShapes: [batchInputShape],\n            outputShapes: [batchInputShape]\n        });\n    }\n    apply(inputs, kwargs) {\n        throw new ValueError('Cannot pass any input to an ' +\n            `InputLayer's apply() method. InputLayer name: ${this.name}`);\n    }\n    dispose() {\n        // dispose() for InputLayer is overridden as no-op.\n        return { refCountAfterDispose: this._refCount, numDisposedVariables: 0 };\n    }\n    getConfig() {\n        return {\n            batchInputShape: this.batchInputShape,\n            dtype: this.dtype,\n            sparse: this.sparse,\n            name: this.name\n        };\n    }\n}\n/** @nocollapse */\nInputLayer.className = 'InputLayer';\nserialization.registerClass(InputLayer);\nexport function Input(config) {\n    if (config.batchShape == null && config.shape == null) {\n        throw new Error('Please provide to Input either a `shape`' +\n            ' or a `batchShape` argument. Note that ' +\n            '`shape` does not include the batch ' +\n            'dimension.');\n    }\n    if (config.batchShape != null && config.shape != null) {\n        // TODO(michaelterry): Backport to PyKeras.\n        throw new ValueError('Please provide either a `shape` or `batchShape` ' +\n            'argument to Input, but not both.');\n    }\n    let batchShape = config.batchShape;\n    if (config.shape != null && batchShape == null) {\n        batchShape = [null].concat(config.shape);\n    }\n    let dtype = config.dtype;\n    if (dtype == null) {\n        dtype = 'float32';\n    }\n    const inputLayer = new InputLayer({\n        batchInputShape: batchShape,\n        name: config.name,\n        dtype,\n        sparse: config.sparse\n    });\n    const outputs = inputLayer.inboundNodes[0].outputTensors;\n    return outputs[0];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}