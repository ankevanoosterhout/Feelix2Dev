{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport { Cast, util } from '@tensorflow/tfjs-core';\nimport { castImplCPU } from '../kernel_utils/shared';\nimport { complex } from './Complex';\nimport { identity } from './Identity';\nimport { notEqual } from './NotEqual';\nimport { real } from './Real';\nimport { int } from '../kernel_utils/int';\nexport function cast(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x\n  } = inputs;\n  const {\n    dtype\n  } = attrs; // Casting to complex64.\n\n  if (dtype === 'complex64') {\n    if (x.dtype === 'complex64') {\n      return identity({\n        inputs: {\n          x\n        },\n        backend\n      });\n    } // TODO(annxingyuan): Import kernel function once zeros is modularized.\n\n\n    const zerosTensor = tf.zeros(x.shape);\n    const floatX = cast({\n      inputs: {\n        x\n      },\n      backend,\n      attrs: {\n        dtype: 'float32'\n      }\n    });\n    const result = complex({\n      inputs: {\n        real: floatX,\n        imag: zerosTensor\n      },\n      backend\n    });\n    zerosTensor.dispose();\n    backend.disposeIntermediateTensorInfo(floatX);\n    return result;\n  } // Casting from complex64\n\n\n  if (x.dtype === 'complex64') {\n    const realPart = real({\n      inputs: {\n        input: x\n      },\n      backend\n    });\n    const result = cast({\n      inputs: {\n        x: realPart\n      },\n      backend,\n      attrs: {\n        dtype\n      }\n    });\n    backend.disposeIntermediateTensorInfo(realPart);\n    return result;\n  }\n\n  if (!util.hasEncodingLoss(x.dtype, dtype)) {\n    // We don't change the underlying data, since we cast to higher\n    // precision.\n    const result = identity({\n      inputs: {\n        x\n      },\n      backend\n    });\n    return {\n      dataId: result.dataId,\n      shape: result.shape,\n      dtype\n    };\n  }\n\n  if (backend.shouldExecuteOnCPU([x])) {\n    const values = backend.texData.get(x.dataId).values;\n    const [resultShape, resultType, resultData] = castImplCPU(values, x.shape, x.dtype, dtype);\n    return backend.makeTensorInfo(resultShape, resultType, resultData);\n  }\n\n  if (dtype === 'int32') {\n    return int(x, backend);\n  }\n\n  if (dtype === 'bool') {\n    const zerosTensorInfo = backend.makeTensorInfo([], 'bool', util.getTypedArrayFromDType('bool', 1));\n    const binaryInputs = {\n      a: x,\n      b: zerosTensorInfo\n    };\n    const result = notEqual({\n      inputs: binaryInputs,\n      backend\n    });\n    backend.disposeIntermediateTensorInfo(zerosTensorInfo);\n    return result;\n  }\n\n  throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);\n}\nexport const castConfig = {\n  kernelName: Cast,\n  backendName: 'webgl',\n  kernelFunc: cast\n};","map":{"version":3,"names":["tf","Cast","util","castImplCPU","complex","identity","notEqual","real","int","cast","args","inputs","backend","attrs","x","dtype","zerosTensor","zeros","shape","floatX","result","imag","dispose","disposeIntermediateTensorInfo","realPart","input","hasEncodingLoss","dataId","shouldExecuteOnCPU","values","texData","get","resultShape","resultType","resultData","makeTensorInfo","zerosTensorInfo","getTypedArrayFromDType","binaryInputs","a","b","Error","castConfig","kernelName","backendName","kernelFunc"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cast.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport { Cast, util } from '@tensorflow/tfjs-core';\nimport { castImplCPU } from '../kernel_utils/shared';\nimport { complex } from './Complex';\nimport { identity } from './Identity';\nimport { notEqual } from './NotEqual';\nimport { real } from './Real';\nimport { int } from '../kernel_utils/int';\nexport function cast(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { dtype } = attrs;\n    // Casting to complex64.\n    if (dtype === 'complex64') {\n        if (x.dtype === 'complex64') {\n            return identity({ inputs: { x }, backend });\n        }\n        // TODO(annxingyuan): Import kernel function once zeros is modularized.\n        const zerosTensor = tf.zeros(x.shape);\n        const floatX = cast({ inputs: { x }, backend, attrs: { dtype: 'float32' } });\n        const result = complex({ inputs: { real: floatX, imag: zerosTensor }, backend });\n        zerosTensor.dispose();\n        backend.disposeIntermediateTensorInfo(floatX);\n        return result;\n    }\n    // Casting from complex64\n    if (x.dtype === 'complex64') {\n        const realPart = real({ inputs: { input: x }, backend });\n        const result = cast({ inputs: { x: realPart }, backend, attrs: { dtype } });\n        backend.disposeIntermediateTensorInfo(realPart);\n        return result;\n    }\n    if (!util.hasEncodingLoss(x.dtype, dtype)) {\n        // We don't change the underlying data, since we cast to higher\n        // precision.\n        const result = identity({ inputs: { x }, backend });\n        return { dataId: result.dataId, shape: result.shape, dtype };\n    }\n    if (backend.shouldExecuteOnCPU([x])) {\n        const values = backend.texData.get(x.dataId).values;\n        const [resultShape, resultType, resultData] = castImplCPU(values, x.shape, x.dtype, dtype);\n        return backend.makeTensorInfo(resultShape, resultType, resultData);\n    }\n    if (dtype === 'int32') {\n        return int(x, backend);\n    }\n    if (dtype === 'bool') {\n        const zerosTensorInfo = backend.makeTensorInfo([], 'bool', util.getTypedArrayFromDType('bool', 1));\n        const binaryInputs = { a: x, b: zerosTensorInfo };\n        const result = notEqual({ inputs: binaryInputs, backend });\n        backend.disposeIntermediateTensorInfo(zerosTensorInfo);\n        return result;\n    }\n    throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);\n}\nexport const castConfig = {\n    kernelName: Cast,\n    backendName: 'webgl',\n    kernelFunc: cast\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}