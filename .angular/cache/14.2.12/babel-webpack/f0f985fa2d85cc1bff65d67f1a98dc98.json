{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\n/**\n * A ring buffer, providing O(1) FIFO, LIFO, and related operations.\n */\nexport class RingBuffer {\n  /**\n   * Constructs a `RingBuffer`.\n   * @param capacity The number of items that the buffer can accomodate.\n   */\n  constructor(capacity) {\n    this.capacity = capacity; // Note we store the indices in the range 0 <= index < 2*capacity.\n    // This allows us to distinguish the full from the empty case.\n    // See https://www.snellman.net/blog/archive/2016-12-13-ring-buffers/\n\n    this.begin = 0; // inclusive\n\n    this.end = 0; // exclusive\n\n    if (capacity == null) {\n      throw new RangeError('Can\\'t create a ring buffer of unknown capacity.');\n    }\n\n    if (capacity < 1) {\n      throw new RangeError('Can\\'t create ring buffer of capacity < 1.');\n    }\n\n    this.data = new Array(capacity);\n    this.doubledCapacity = 2 * capacity;\n  }\n  /**\n   * Map any index into the range 0 <= index < 2*capacity.\n   */\n\n\n  wrap(index) {\n    // don't trust % on negative numbers\n    while (index < 0) {\n      index += this.doubledCapacity;\n    }\n\n    return index % this.doubledCapacity;\n  }\n\n  get(index) {\n    if (index < 0) {\n      throw new RangeError('Can\\'t get item at a negative index.');\n    }\n\n    return this.data[index % this.capacity];\n  }\n\n  set(index, value) {\n    if (index < 0) {\n      throw new RangeError('Can\\'t set item at a negative index.');\n    }\n\n    this.data[index % this.capacity] = value;\n  }\n  /**\n   * Returns the current number of items in the buffer.\n   */\n\n\n  length() {\n    let length = this.end - this.begin;\n\n    if (length < 0) {\n      length = this.doubledCapacity + length;\n    }\n\n    return length;\n  }\n  /**\n   * Reports whether the buffer is full.\n   * @returns true if the number of items in the buffer equals its capacity, and\n   *   false otherwise.\n   */\n\n\n  isFull() {\n    return this.length() === this.capacity;\n  }\n  /**\n   * Reports whether the buffer is empty.\n   * @returns true if the number of items in the buffer equals zero, and\n   *   false otherwise.\n   */\n\n\n  isEmpty() {\n    return this.length() === 0;\n  }\n  /**\n   * Adds an item to the end of the buffer.\n   */\n\n\n  push(value) {\n    if (this.isFull()) {\n      throw new RangeError('Ring buffer is full.');\n    }\n\n    this.set(this.end, value);\n    this.end = this.wrap(this.end + 1);\n  }\n  /**\n   * Adds many items to the end of the buffer, in order.\n   */\n\n\n  pushAll(values) {\n    for (const value of values) {\n      this.push(value);\n    }\n  }\n  /**\n   * Removes and returns the last item in the buffer.\n   */\n\n\n  pop() {\n    if (this.isEmpty()) {\n      throw new RangeError('Ring buffer is empty.');\n    }\n\n    this.end = this.wrap(this.end - 1);\n    const result = this.get(this.end);\n    this.set(this.end, undefined);\n    return result;\n  }\n  /**\n   * Adds an item to the beginning of the buffer.\n   */\n\n\n  unshift(value) {\n    if (this.isFull()) {\n      throw new RangeError('Ring buffer is full.');\n    }\n\n    this.begin = this.wrap(this.begin - 1);\n    this.set(this.begin, value);\n  }\n  /**\n   * Removes and returns the first item in the buffer.\n   */\n\n\n  shift() {\n    if (this.isEmpty()) {\n      throw new RangeError('Ring buffer is empty.');\n    }\n\n    const result = this.get(this.begin);\n    this.set(this.begin, undefined);\n    this.begin = this.wrap(this.begin + 1);\n    return result;\n  }\n  /**\n   * Removes and returns a specific item in the buffer, and moves the last item\n   * to the vacated slot.  This is useful for implementing a shuffling stream.\n   * Note that this operation necessarily scrambles the original order.\n   *\n   * @param relativeIndex: the index of the item to remove, relative to the\n   *   first item in the buffer (e.g., hiding the ring nature of the underlying\n   *   storage).\n   */\n\n\n  shuffleExcise(relativeIndex) {\n    if (this.isEmpty()) {\n      throw new RangeError('Ring buffer is empty.');\n    }\n\n    const index = this.wrap(this.begin + relativeIndex);\n    const result = this.get(index);\n    this.set(index, this.pop());\n    return result;\n  }\n\n}","map":{"version":3,"names":["RingBuffer","constructor","capacity","begin","end","RangeError","data","Array","doubledCapacity","wrap","index","get","set","value","length","isFull","isEmpty","push","pushAll","values","pop","result","undefined","unshift","shift","shuffleExcise","relativeIndex"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-data/dist/util/ring_buffer.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n/**\n * A ring buffer, providing O(1) FIFO, LIFO, and related operations.\n */\nexport class RingBuffer {\n    /**\n     * Constructs a `RingBuffer`.\n     * @param capacity The number of items that the buffer can accomodate.\n     */\n    constructor(capacity) {\n        this.capacity = capacity;\n        // Note we store the indices in the range 0 <= index < 2*capacity.\n        // This allows us to distinguish the full from the empty case.\n        // See https://www.snellman.net/blog/archive/2016-12-13-ring-buffers/\n        this.begin = 0; // inclusive\n        this.end = 0; // exclusive\n        if (capacity == null) {\n            throw new RangeError('Can\\'t create a ring buffer of unknown capacity.');\n        }\n        if (capacity < 1) {\n            throw new RangeError('Can\\'t create ring buffer of capacity < 1.');\n        }\n        this.data = new Array(capacity);\n        this.doubledCapacity = 2 * capacity;\n    }\n    /**\n     * Map any index into the range 0 <= index < 2*capacity.\n     */\n    wrap(index) {\n        // don't trust % on negative numbers\n        while (index < 0) {\n            index += this.doubledCapacity;\n        }\n        return index % this.doubledCapacity;\n    }\n    get(index) {\n        if (index < 0) {\n            throw new RangeError('Can\\'t get item at a negative index.');\n        }\n        return this.data[index % this.capacity];\n    }\n    set(index, value) {\n        if (index < 0) {\n            throw new RangeError('Can\\'t set item at a negative index.');\n        }\n        this.data[index % this.capacity] = value;\n    }\n    /**\n     * Returns the current number of items in the buffer.\n     */\n    length() {\n        let length = this.end - this.begin;\n        if (length < 0) {\n            length = this.doubledCapacity + length;\n        }\n        return length;\n    }\n    /**\n     * Reports whether the buffer is full.\n     * @returns true if the number of items in the buffer equals its capacity, and\n     *   false otherwise.\n     */\n    isFull() {\n        return this.length() === this.capacity;\n    }\n    /**\n     * Reports whether the buffer is empty.\n     * @returns true if the number of items in the buffer equals zero, and\n     *   false otherwise.\n     */\n    isEmpty() {\n        return this.length() === 0;\n    }\n    /**\n     * Adds an item to the end of the buffer.\n     */\n    push(value) {\n        if (this.isFull()) {\n            throw new RangeError('Ring buffer is full.');\n        }\n        this.set(this.end, value);\n        this.end = this.wrap(this.end + 1);\n    }\n    /**\n     * Adds many items to the end of the buffer, in order.\n     */\n    pushAll(values) {\n        for (const value of values) {\n            this.push(value);\n        }\n    }\n    /**\n     * Removes and returns the last item in the buffer.\n     */\n    pop() {\n        if (this.isEmpty()) {\n            throw new RangeError('Ring buffer is empty.');\n        }\n        this.end = this.wrap(this.end - 1);\n        const result = this.get(this.end);\n        this.set(this.end, undefined);\n        return result;\n    }\n    /**\n     * Adds an item to the beginning of the buffer.\n     */\n    unshift(value) {\n        if (this.isFull()) {\n            throw new RangeError('Ring buffer is full.');\n        }\n        this.begin = this.wrap(this.begin - 1);\n        this.set(this.begin, value);\n    }\n    /**\n     * Removes and returns the first item in the buffer.\n     */\n    shift() {\n        if (this.isEmpty()) {\n            throw new RangeError('Ring buffer is empty.');\n        }\n        const result = this.get(this.begin);\n        this.set(this.begin, undefined);\n        this.begin = this.wrap(this.begin + 1);\n        return result;\n    }\n    /**\n     * Removes and returns a specific item in the buffer, and moves the last item\n     * to the vacated slot.  This is useful for implementing a shuffling stream.\n     * Note that this operation necessarily scrambles the original order.\n     *\n     * @param relativeIndex: the index of the item to remove, relative to the\n     *   first item in the buffer (e.g., hiding the ring nature of the underlying\n     *   storage).\n     */\n    shuffleExcise(relativeIndex) {\n        if (this.isEmpty()) {\n            throw new RangeError('Ring buffer is empty.');\n        }\n        const index = this.wrap(this.begin + relativeIndex);\n        const result = this.get(index);\n        this.set(index, this.pop());\n        return result;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}