{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\n\nfunction validateIndices(indices, indicesShape, numParams) {\n  indices.forEach((index, i) => {\n    if (index < 0 || index >= numParams) {\n      const locString = util.indexToLoc(i, indicesShape.length, util.computeStrides(indicesShape)).join(',');\n      throw new Error(`indices[${locString}] = ${index} is not in [0, ${numParams})`);\n    }\n  });\n}\n\nfunction validateSplits(paramsNestedSplits, numParamsDenseValues) {\n  // Validate\n  for (let dim = 0; dim < paramsNestedSplits.length; ++dim) {\n    const splits = paramsNestedSplits[dim];\n    const lastSplit = dim === paramsNestedSplits.length - 1 ? numParamsDenseValues : paramsNestedSplits[dim + 1].length;\n\n    if (splits.length === 0) {\n      throw new Error('Ragged splits may not be empty');\n    }\n\n    if (splits[0] < 0) {\n      throw new Error('Ragged splits must be non-negative');\n    }\n\n    if (splits[splits.length - 1] > lastSplit) {\n      throw new Error('Ragged splits must not point past values');\n    }\n\n    for (let i = 1; i < splits.length; ++i) {\n      if (splits[i - 1] > splits[i]) {\n        throw new Error('Ragged splits must be sorted in ascending order');\n      }\n    }\n  }\n} // Construct the `splits` output tensors, encoded using a nested vector.\n// Also find the slices of values that need to be copied, and store them\n// in `valueSlices`.  The total number of values that will be copied (which\n// we need for allocating the output values tensor) is stored in `numValues`.\n\n\nfunction makeSplits(indices, indicesShape, paramsNestedSplits, numParamsDenseValues) {\n  const valueSlices = [];\n  let numValues = 0;\n  const numSplits = indicesShape.length - 1 + paramsNestedSplits.length;\n  const outSplits = new Array(numSplits).fill(null).map(() => [0]);\n  validateSplits(paramsNestedSplits, numParamsDenseValues); // Add `splits` that come from all but the last dimension of the dense\n  // Tensor `indices`.  In particular, for each dimension D, we add a\n  // splits tensor whose values are:\n  //   range(reduceProd(splits.shape[:D]) + 1) * splits.shape[D+1]\n  // E.g., if indices.shape=[2, 3, 4] then we will add splits tensors:\n  //   [0, 3, 6]                    # length=2+1, stride=3\n  //   [0, 4, 8, 12, 16, 20, 24]    # length=2*3+1, stride=4\n\n  let nrows = 1;\n\n  for (let dim = 0; dim < indicesShape.length - 1; ++dim) {\n    nrows *= indicesShape[dim];\n    const rowLength = indicesShape[dim + 1];\n\n    for (let i = 1; i < nrows + 1; ++i) {\n      outSplits[dim].push(i * rowLength);\n    }\n  } // Add `splits` that come from `paramsNestedSplits`.  Starting with the\n  // outermost ragged dimension (i.e., the first `splits` tensor), we work\n  // our way in, finding the range of values that should be copied.  As we\n  // go, we update the output `splits` for each dimension with the appropriate\n  // values.  In particular, the *lengths* of the slices from `param_splits`\n  // should be copied to generate corresponding slice lengths in the output\n  // splits.  E.g., if we are copying a ragged row with length 4, then we\n  // should add a new split point to outSplits that is 4 greater than the\n  // previous split point in outSplits.\n\n\n  for (let i = 0; i < indices.length; ++i) {\n    let start = indices[i];\n    let limit = indices[i] + 1; // Copy splits.\n\n    for (let dim = 0; dim < paramsNestedSplits.length; ++dim) {\n      const splits = paramsNestedSplits[dim];\n      const outDim = dim + indicesShape.length - 1;\n\n      if (outDim >= 0) {\n        const outSplitsOutDim = outSplits[outDim];\n        const delta = outSplitsOutDim[outSplitsOutDim.length - 1] - splits[start];\n\n        for (let j = start; j < limit; ++j) {\n          outSplits[outDim].push(splits[j + 1] + delta);\n        }\n      }\n\n      start = splits[start];\n      limit = splits[limit];\n    }\n\n    if (limit !== start) {\n      valueSlices.push([start, limit]);\n      numValues += limit - start;\n    }\n  }\n\n  return {\n    outSplits,\n    valueSlices,\n    numValues\n  };\n}\n\nfunction getSplits(outSplits) {\n  const splitsOut = [];\n\n  for (let i = 0; i < outSplits.length; ++i) {\n    const numSplits = outSplits[i].length;\n    const splits = util.getArrayFromDType('int32', numSplits);\n    splitsOut.push(splits);\n    outSplits[i].forEach((value, j) => splits[j] = value);\n  }\n\n  return splitsOut;\n}\n\nfunction computeFlatOuterDims(orig, numOutDims) {\n  const outDims = orig.slice(0, numOutDims);\n\n  while (outDims.length < numOutDims) {\n    outDims.push(1);\n  }\n\n  for (let inDim = numOutDims; inDim < orig.length; inDim++) {\n    outDims[numOutDims - 1] *= orig[inDim];\n  }\n\n  return outDims;\n} // For each slice in `(start, limit)` in `valueSlices`, append\n// `paramsDenseValues[start,...,limit] to `values`.  `valueSize` indicates\n// the number of scalars contained in each value paramsDenseValues[i].\n\n\nfunction writeValueSlices(paramsDenseValues, paramsDenseValuesShape, valueSlices, valueSize, values, valuesShape) {\n  const denseM = computeFlatOuterDims(paramsDenseValuesShape, 2)[1];\n  const valuesM = computeFlatOuterDims(valuesShape, 2)[1];\n  let outPos = 0;\n\n  for (const slice of valueSlices) {\n    for (let i = slice[0]; i < slice[1]; ++i) {\n      for (let j = 0; j < valueSize; ++j) {\n        values[outPos * valuesM + j] = paramsDenseValues[i * denseM + j];\n      }\n\n      ++outPos;\n    }\n  }\n}\n\nfunction getValues(paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, valueSlices, numValues) {\n  const valuesShape = paramsDenseValuesShape.slice();\n  valuesShape[0] = numValues;\n  const valuesOut = util.getArrayFromDType(paramsDenseValuesDType, util.sizeFromShape(valuesShape));\n  const numElements = paramsDenseValues.length;\n  const valueSize = numElements === 0 ? 0 : numElements / paramsDenseValuesShape[0];\n  writeValueSlices(paramsDenseValues, paramsDenseValuesShape, valueSlices, valueSize, valuesOut, valuesShape);\n  return [valuesOut, valuesShape];\n}\n\nexport function raggedGatherImpl(paramsNestedSplits, paramsNestedSplitsShapes, paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, indices, indicesShape, outputRaggedRank) {\n  if (paramsNestedSplits.length === 0) {\n    throw new Error('paramsNestedSplits must be non empty');\n  }\n\n  if (paramsNestedSplitsShapes[0].length === 0) {\n    throw new Error('Split tensors must not be scalars');\n  }\n\n  const numParams = paramsNestedSplitsShapes[0][0] - 1;\n  validateIndices(indices, indicesShape, numParams);\n\n  if (paramsDenseValuesShape.length === 0) {\n    throw new Error('params.rank must be nonzero');\n  }\n\n  const numParamsDenseValues = paramsDenseValuesShape[0]; // Calculate the `splits`, and store the value slices that we need to\n  // copy in `valueSlices`.\n\n  const {\n    outSplits,\n    valueSlices,\n    numValues\n  } = makeSplits(indices, indicesShape, paramsNestedSplits, numParamsDenseValues); // Write the output tensors.\n\n  const outputNestedSplits = getSplits(outSplits);\n  const outputDenseValues = getValues(paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, valueSlices, numValues);\n  return [outputNestedSplits, outputDenseValues[0], outputDenseValues[1]];\n}","map":{"version":3,"names":["util","validateIndices","indices","indicesShape","numParams","forEach","index","i","locString","indexToLoc","length","computeStrides","join","Error","validateSplits","paramsNestedSplits","numParamsDenseValues","dim","splits","lastSplit","makeSplits","valueSlices","numValues","numSplits","outSplits","Array","fill","map","nrows","rowLength","push","start","limit","outDim","outSplitsOutDim","delta","j","getSplits","splitsOut","getArrayFromDType","value","computeFlatOuterDims","orig","numOutDims","outDims","slice","inDim","writeValueSlices","paramsDenseValues","paramsDenseValuesShape","valueSize","values","valuesShape","denseM","valuesM","outPos","getValues","paramsDenseValuesDType","valuesOut","sizeFromShape","numElements","raggedGatherImpl","paramsNestedSplitsShapes","outputRaggedRank","outputNestedSplits","outputDenseValues"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedGather_impl.js"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nfunction validateIndices(indices, indicesShape, numParams) {\n    indices.forEach((index, i) => {\n        if (index < 0 || index >= numParams) {\n            const locString = util.indexToLoc(i, indicesShape.length, util.computeStrides(indicesShape))\n                .join(',');\n            throw new Error(`indices[${locString}] = ${index} is not in [0, ${numParams})`);\n        }\n    });\n}\nfunction validateSplits(paramsNestedSplits, numParamsDenseValues) {\n    // Validate\n    for (let dim = 0; dim < paramsNestedSplits.length; ++dim) {\n        const splits = paramsNestedSplits[dim];\n        const lastSplit = (dim === paramsNestedSplits.length - 1) ?\n            numParamsDenseValues :\n            paramsNestedSplits[dim + 1].length;\n        if (splits.length === 0) {\n            throw new Error('Ragged splits may not be empty');\n        }\n        if (splits[0] < 0) {\n            throw new Error('Ragged splits must be non-negative');\n        }\n        if (splits[splits.length - 1] > lastSplit) {\n            throw new Error('Ragged splits must not point past values');\n        }\n        for (let i = 1; i < splits.length; ++i) {\n            if (splits[i - 1] > splits[i]) {\n                throw new Error('Ragged splits must be sorted in ascending order');\n            }\n        }\n    }\n}\n// Construct the `splits` output tensors, encoded using a nested vector.\n// Also find the slices of values that need to be copied, and store them\n// in `valueSlices`.  The total number of values that will be copied (which\n// we need for allocating the output values tensor) is stored in `numValues`.\nfunction makeSplits(indices, indicesShape, paramsNestedSplits, numParamsDenseValues) {\n    const valueSlices = [];\n    let numValues = 0;\n    const numSplits = indicesShape.length - 1 + paramsNestedSplits.length;\n    const outSplits = new Array(numSplits).fill(null).map(() => [0]);\n    validateSplits(paramsNestedSplits, numParamsDenseValues);\n    // Add `splits` that come from all but the last dimension of the dense\n    // Tensor `indices`.  In particular, for each dimension D, we add a\n    // splits tensor whose values are:\n    //   range(reduceProd(splits.shape[:D]) + 1) * splits.shape[D+1]\n    // E.g., if indices.shape=[2, 3, 4] then we will add splits tensors:\n    //   [0, 3, 6]                    # length=2+1, stride=3\n    //   [0, 4, 8, 12, 16, 20, 24]    # length=2*3+1, stride=4\n    let nrows = 1;\n    for (let dim = 0; dim < indicesShape.length - 1; ++dim) {\n        nrows *= indicesShape[dim];\n        const rowLength = indicesShape[dim + 1];\n        for (let i = 1; i < nrows + 1; ++i) {\n            outSplits[dim].push(i * rowLength);\n        }\n    }\n    // Add `splits` that come from `paramsNestedSplits`.  Starting with the\n    // outermost ragged dimension (i.e., the first `splits` tensor), we work\n    // our way in, finding the range of values that should be copied.  As we\n    // go, we update the output `splits` for each dimension with the appropriate\n    // values.  In particular, the *lengths* of the slices from `param_splits`\n    // should be copied to generate corresponding slice lengths in the output\n    // splits.  E.g., if we are copying a ragged row with length 4, then we\n    // should add a new split point to outSplits that is 4 greater than the\n    // previous split point in outSplits.\n    for (let i = 0; i < indices.length; ++i) {\n        let start = indices[i];\n        let limit = indices[i] + 1;\n        // Copy splits.\n        for (let dim = 0; dim < paramsNestedSplits.length; ++dim) {\n            const splits = paramsNestedSplits[dim];\n            const outDim = dim + indicesShape.length - 1;\n            if (outDim >= 0) {\n                const outSplitsOutDim = outSplits[outDim];\n                const delta = outSplitsOutDim[outSplitsOutDim.length - 1] - splits[start];\n                for (let j = start; j < limit; ++j) {\n                    outSplits[outDim].push(splits[j + 1] + delta);\n                }\n            }\n            start = splits[start];\n            limit = splits[limit];\n        }\n        if (limit !== start) {\n            valueSlices.push([start, limit]);\n            numValues += limit - start;\n        }\n    }\n    return { outSplits, valueSlices, numValues };\n}\nfunction getSplits(outSplits) {\n    const splitsOut = [];\n    for (let i = 0; i < outSplits.length; ++i) {\n        const numSplits = outSplits[i].length;\n        const splits = util.getArrayFromDType('int32', numSplits);\n        splitsOut.push(splits);\n        outSplits[i].forEach((value, j) => splits[j] = value);\n    }\n    return splitsOut;\n}\nfunction computeFlatOuterDims(orig, numOutDims) {\n    const outDims = orig.slice(0, numOutDims);\n    while (outDims.length < numOutDims) {\n        outDims.push(1);\n    }\n    for (let inDim = numOutDims; inDim < orig.length; inDim++) {\n        outDims[numOutDims - 1] *= orig[inDim];\n    }\n    return outDims;\n}\n// For each slice in `(start, limit)` in `valueSlices`, append\n// `paramsDenseValues[start,...,limit] to `values`.  `valueSize` indicates\n// the number of scalars contained in each value paramsDenseValues[i].\nfunction writeValueSlices(paramsDenseValues, paramsDenseValuesShape, valueSlices, valueSize, values, valuesShape) {\n    const denseM = computeFlatOuterDims(paramsDenseValuesShape, 2)[1];\n    const valuesM = computeFlatOuterDims(valuesShape, 2)[1];\n    let outPos = 0;\n    for (const slice of valueSlices) {\n        for (let i = slice[0]; i < slice[1]; ++i) {\n            for (let j = 0; j < valueSize; ++j) {\n                values[outPos * valuesM + j] = paramsDenseValues[i * denseM + j];\n            }\n            ++outPos;\n        }\n    }\n}\nfunction getValues(paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, valueSlices, numValues) {\n    const valuesShape = paramsDenseValuesShape.slice();\n    valuesShape[0] = numValues;\n    const valuesOut = util.getArrayFromDType(paramsDenseValuesDType, util.sizeFromShape(valuesShape));\n    const numElements = paramsDenseValues.length;\n    const valueSize = numElements === 0 ? 0 : (numElements / paramsDenseValuesShape[0]);\n    writeValueSlices(paramsDenseValues, paramsDenseValuesShape, valueSlices, valueSize, valuesOut, valuesShape);\n    return [valuesOut, valuesShape];\n}\nexport function raggedGatherImpl(paramsNestedSplits, paramsNestedSplitsShapes, paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, indices, indicesShape, outputRaggedRank) {\n    if (paramsNestedSplits.length === 0) {\n        throw new Error('paramsNestedSplits must be non empty');\n    }\n    if (paramsNestedSplitsShapes[0].length === 0) {\n        throw new Error('Split tensors must not be scalars');\n    }\n    const numParams = paramsNestedSplitsShapes[0][0] - 1;\n    validateIndices(indices, indicesShape, numParams);\n    if (paramsDenseValuesShape.length === 0) {\n        throw new Error('params.rank must be nonzero');\n    }\n    const numParamsDenseValues = paramsDenseValuesShape[0];\n    // Calculate the `splits`, and store the value slices that we need to\n    // copy in `valueSlices`.\n    const { outSplits, valueSlices, numValues } = makeSplits(indices, indicesShape, paramsNestedSplits, numParamsDenseValues);\n    // Write the output tensors.\n    const outputNestedSplits = getSplits(outSplits);\n    const outputDenseValues = getValues(paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, valueSlices, numValues);\n    return [outputNestedSplits, outputDenseValues[0], outputDenseValues[1]];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}