{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray } from '../util';\n/** This is shared code across all tensor creation methods. */\n\nexport function makeTensor(values, shape, inferredShape, dtype) {\n  if (dtype == null) {\n    dtype = inferDtype(values);\n  }\n\n  if (dtype === 'complex64') {\n    throw new Error(`Cannot construct a complex64 tensor directly. ` + `Please use tf.complex(real, imag).`);\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values) && typeof values !== 'number' && typeof values !== 'boolean' && typeof values !== 'string') {\n    throw new Error('values passed to tensor(values) must be a number/boolean/string or ' + 'an array of numbers/booleans/strings, or a TypedArray');\n  }\n\n  if (shape != null) {\n    assertNonNegativeIntegerDimensions(shape);\n    const providedSize = sizeFromShape(shape);\n    const inferredSize = sizeFromShape(inferredShape);\n    assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ` + `${providedSize} values but has ${inferredSize}`);\n\n    for (let i = 0; i < inferredShape.length; ++i) {\n      const inferred = inferredShape[i];\n      const flatDimsDontMatch = i === inferredShape.length - 1 ? inferred !== sizeFromShape(shape.slice(i)) : true;\n      assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape ` + `(${inferredShape}) does not match the provided ` + `shape (${shape}). `);\n    }\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values)) {\n    values = [values];\n  }\n\n  shape = shape || inferredShape;\n  values = dtype !== 'string' ? toTypedArray(values, dtype) : flatten(values, [], true);\n  return ENGINE.makeTensor(values, shape, dtype);\n}","map":{"version":3,"names":["ENGINE","assert","assertNonNegativeIntegerDimensions","flatten","inferDtype","isTypedArray","sizeFromShape","toTypedArray","makeTensor","values","shape","inferredShape","dtype","Error","Array","isArray","providedSize","inferredSize","i","length","inferred","flatDimsDontMatch","slice"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-core/dist/ops/tensor_ops_util.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray } from '../util';\n/** This is shared code across all tensor creation methods. */\nexport function makeTensor(values, shape, inferredShape, dtype) {\n    if (dtype == null) {\n        dtype = inferDtype(values);\n    }\n    if (dtype === 'complex64') {\n        throw new Error(`Cannot construct a complex64 tensor directly. ` +\n            `Please use tf.complex(real, imag).`);\n    }\n    if (!isTypedArray(values) && !Array.isArray(values) &&\n        typeof values !== 'number' && typeof values !== 'boolean' &&\n        typeof values !== 'string') {\n        throw new Error('values passed to tensor(values) must be a number/boolean/string or ' +\n            'an array of numbers/booleans/strings, or a TypedArray');\n    }\n    if (shape != null) {\n        assertNonNegativeIntegerDimensions(shape);\n        const providedSize = sizeFromShape(shape);\n        const inferredSize = sizeFromShape(inferredShape);\n        assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ` +\n            `${providedSize} values but has ${inferredSize}`);\n        for (let i = 0; i < inferredShape.length; ++i) {\n            const inferred = inferredShape[i];\n            const flatDimsDontMatch = i === inferredShape.length - 1 ?\n                inferred !== sizeFromShape(shape.slice(i)) :\n                true;\n            assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape ` +\n                `(${inferredShape}) does not match the provided ` +\n                `shape (${shape}). `);\n        }\n    }\n    if (!isTypedArray(values) && !Array.isArray(values)) {\n        values = [values];\n    }\n    shape = shape || inferredShape;\n    values = dtype !== 'string' ?\n        toTypedArray(values, dtype) :\n        flatten(values, [], true);\n    return ENGINE.makeTensor(values, shape, dtype);\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAT,QAAuB,WAAvB;AACA,SAASC,MAAT,EAAiBC,kCAAjB,EAAqDC,OAArD,EAA8DC,UAA9D,EAA0EC,YAA1E,EAAwFC,aAAxF,EAAuGC,YAAvG,QAA2H,SAA3H;AACA;;AACA,OAAO,SAASC,UAAT,CAAoBC,MAApB,EAA4BC,KAA5B,EAAmCC,aAAnC,EAAkDC,KAAlD,EAAyD;EAC5D,IAAIA,KAAK,IAAI,IAAb,EAAmB;IACfA,KAAK,GAAGR,UAAU,CAACK,MAAD,CAAlB;EACH;;EACD,IAAIG,KAAK,KAAK,WAAd,EAA2B;IACvB,MAAM,IAAIC,KAAJ,CAAW,gDAAD,GACX,oCADC,CAAN;EAEH;;EACD,IAAI,CAACR,YAAY,CAACI,MAAD,CAAb,IAAyB,CAACK,KAAK,CAACC,OAAN,CAAcN,MAAd,CAA1B,IACA,OAAOA,MAAP,KAAkB,QADlB,IAC8B,OAAOA,MAAP,KAAkB,SADhD,IAEA,OAAOA,MAAP,KAAkB,QAFtB,EAEgC;IAC5B,MAAM,IAAII,KAAJ,CAAU,wEACZ,uDADE,CAAN;EAEH;;EACD,IAAIH,KAAK,IAAI,IAAb,EAAmB;IACfR,kCAAkC,CAACQ,KAAD,CAAlC;IACA,MAAMM,YAAY,GAAGV,aAAa,CAACI,KAAD,CAAlC;IACA,MAAMO,YAAY,GAAGX,aAAa,CAACK,aAAD,CAAlC;IACAV,MAAM,CAACe,YAAY,KAAKC,YAAlB,EAAgC,MAAO,iCAAgCP,KAAM,4BAAvC,GACvC,GAAEM,YAAa,mBAAkBC,YAAa,EAD7C,CAAN;;IAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,aAAa,CAACQ,MAAlC,EAA0C,EAAED,CAA5C,EAA+C;MAC3C,MAAME,QAAQ,GAAGT,aAAa,CAACO,CAAD,CAA9B;MACA,MAAMG,iBAAiB,GAAGH,CAAC,KAAKP,aAAa,CAACQ,MAAd,GAAuB,CAA7B,GACtBC,QAAQ,KAAKd,aAAa,CAACI,KAAK,CAACY,KAAN,CAAYJ,CAAZ,CAAD,CADJ,GAEtB,IAFJ;MAGAjB,MAAM,CAACU,aAAa,CAACO,CAAD,CAAb,KAAqBR,KAAK,CAACQ,CAAD,CAA1B,IAAiC,CAACG,iBAAnC,EAAsD,MAAO,8CAAD,GAC7D,IAAGV,aAAc,gCAD4C,GAE7D,UAASD,KAAM,KAFd,CAAN;IAGH;EACJ;;EACD,IAAI,CAACL,YAAY,CAACI,MAAD,CAAb,IAAyB,CAACK,KAAK,CAACC,OAAN,CAAcN,MAAd,CAA9B,EAAqD;IACjDA,MAAM,GAAG,CAACA,MAAD,CAAT;EACH;;EACDC,KAAK,GAAGA,KAAK,IAAIC,aAAjB;EACAF,MAAM,GAAGG,KAAK,KAAK,QAAV,GACLL,YAAY,CAACE,MAAD,EAASG,KAAT,CADP,GAELT,OAAO,CAACM,MAAD,EAAS,EAAT,EAAa,IAAb,CAFX;EAGA,OAAOT,MAAM,CAACQ,UAAP,CAAkBC,MAAlB,EAA0BC,KAA1B,EAAiCE,KAAjC,CAAP;AACH"},"metadata":{},"sourceType":"module"}