{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { browser, cast, env, expandDims, image, reshape, tensor1d, tensor2d, tidy, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of image tensors from webcam video stream. Only works in\n * browser environment.\n */\n\nexport class WebcamIterator extends LazyIterator {\n  constructor(webcamVideoElement, webcamConfig) {\n    super();\n    this.webcamVideoElement = webcamVideoElement;\n    this.webcamConfig = webcamConfig;\n    this.isClosed = true;\n    this.resize = false;\n\n    if (this.needToResize()) {\n      this.resize = true;\n      this.cropSize = [this.webcamConfig.resizeHeight, this.webcamConfig.resizeWidth];\n      this.cropBoxInd = tensor1d([0], 'int32');\n\n      if (this.webcamConfig.centerCrop) {\n        // Calculate the box based on resizing shape.\n        const widthCroppingRatio = this.webcamConfig.resizeWidth * 1.0 / this.webcamVideoElement.width;\n        const heightCroppingRatio = this.webcamConfig.resizeHeight * 1.0 / this.webcamVideoElement.height;\n        const widthCropStart = (1 - widthCroppingRatio) / 2;\n        const heightCropStart = (1 - heightCroppingRatio) / 2;\n        const widthCropEnd = widthCropStart + widthCroppingRatio;\n        const heightCropEnd = heightCroppingRatio + heightCropStart;\n        this.cropBox = tensor2d([heightCropStart, widthCropStart, heightCropEnd, widthCropEnd], [1, 4]);\n      } else {\n        this.cropBox = tensor2d([0, 0, 1, 1], [1, 4]);\n      }\n    }\n  }\n\n  summary() {\n    return `webcam`;\n  } // Construct a WebcamIterator and start it's video stream.\n\n\n  static create(webcamVideoElement, webcamConfig = {}) {\n    return _asyncToGenerator(function* () {\n      if (!env().get('IS_BROWSER')) {\n        throw new Error('tf.data.webcam is only supported in browser environment.');\n      }\n\n      if (!webcamVideoElement) {\n        // If webcam video element is not provided, create a hidden video element\n        // with provided width and height.\n        webcamVideoElement = document.createElement('video');\n\n        if (!webcamConfig.resizeWidth || !webcamConfig.resizeHeight) {\n          throw new Error('Please provide webcam video element, or resizeWidth and ' + 'resizeHeight to create a hidden video element.');\n        }\n\n        webcamVideoElement.width = webcamConfig.resizeWidth;\n        webcamVideoElement.height = webcamConfig.resizeHeight;\n      }\n\n      const webcamIterator = new WebcamIterator(webcamVideoElement, webcamConfig); // Call async function to initialize the video stream.\n\n      yield webcamIterator.start();\n      return webcamIterator;\n    })();\n  } // Async function to start video stream.\n\n\n  start() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.webcamConfig.facingMode) {\n        util.assert(_this.webcamConfig.facingMode === 'user' || _this.webcamConfig.facingMode === 'environment', () => `Invalid webcam facing mode: ${_this.webcamConfig.facingMode}. ` + `Please provide 'user' or 'environment'`);\n      }\n\n      try {\n        _this.stream = yield navigator.mediaDevices.getUserMedia({\n          video: {\n            deviceId: _this.webcamConfig.deviceId,\n            facingMode: _this.webcamConfig.facingMode ? _this.webcamConfig.facingMode : 'user',\n            width: _this.webcamVideoElement.width,\n            height: _this.webcamVideoElement.height\n          }\n        });\n      } catch (e) {\n        // Modify the error message but leave the stack trace intact\n        e.message = `Error thrown while initializing video stream: ${e.message}`;\n        throw e;\n      }\n\n      if (!_this.stream) {\n        throw new Error('Could not obtain video from webcam.');\n      } // Older browsers may not have srcObject\n\n\n      try {\n        _this.webcamVideoElement.srcObject = _this.stream;\n      } catch (error) {\n        console.log(error);\n        _this.webcamVideoElement.src = window.URL.createObjectURL(_this.stream);\n      } // Start the webcam video stream\n\n\n      _this.webcamVideoElement.play();\n\n      _this.isClosed = false;\n      return new Promise(resolve => {\n        // Add event listener to make sure the webcam has been fully initialized.\n        _this.webcamVideoElement.onloadedmetadata = () => {\n          resolve();\n        };\n      });\n    })();\n  }\n\n  next() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this2.isClosed) {\n        return {\n          value: null,\n          done: true\n        };\n      }\n\n      let img;\n\n      try {\n        img = browser.fromPixels(_this2.webcamVideoElement);\n      } catch (e) {\n        throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`);\n      }\n\n      if (_this2.resize) {\n        try {\n          return {\n            value: _this2.cropAndResizeFrame(img),\n            done: false\n          };\n        } catch (e) {\n          throw new Error(`Error thrown cropping the video: ${e.message}`);\n        } finally {\n          img.dispose();\n        }\n      } else {\n        return {\n          value: img,\n          done: false\n        };\n      }\n    })();\n  }\n\n  needToResize() {\n    // If resizeWidth and resizeHeight are provided, and different from the\n    // width and height of original HTMLVideoElement, then resizing and cropping\n    // is required.\n    if (this.webcamConfig.resizeWidth && this.webcamConfig.resizeHeight && (this.webcamVideoElement.width !== this.webcamConfig.resizeWidth || this.webcamVideoElement.height !== this.webcamConfig.resizeHeight)) {\n      return true;\n    }\n\n    return false;\n  } // Cropping and resizing each frame based on config\n\n\n  cropAndResizeFrame(img) {\n    return tidy(() => {\n      const expandedImage = expandDims(cast(img, 'float32'), 0);\n      let resizedImage;\n      resizedImage = image.cropAndResize(expandedImage, this.cropBox, this.cropBoxInd, this.cropSize, 'bilinear'); // Extract image from batch cropping.\n\n      const shape = resizedImage.shape;\n      return reshape(resizedImage, shape.slice(1));\n    });\n  } // Capture one frame from the video stream, and extract the value from\n  // iterator.next() result.\n\n\n  capture() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this3.next()).value;\n    })();\n  } // Stop the video stream and pause webcam iterator.\n\n\n  stop() {\n    const tracks = this.stream.getTracks();\n    tracks.forEach(track => track.stop());\n\n    try {\n      this.webcamVideoElement.srcObject = null;\n    } catch (error) {\n      console.log(error);\n      this.webcamVideoElement.src = null;\n    }\n\n    this.isClosed = true;\n  } // Override toArray() function to prevent collecting.\n\n\n  toArray() {\n    throw new Error('Can not convert infinite video stream to array.');\n  }\n\n}","map":{"version":3,"names":["browser","cast","env","expandDims","image","reshape","tensor1d","tensor2d","tidy","util","LazyIterator","WebcamIterator","constructor","webcamVideoElement","webcamConfig","isClosed","resize","needToResize","cropSize","resizeHeight","resizeWidth","cropBoxInd","centerCrop","widthCroppingRatio","width","heightCroppingRatio","height","widthCropStart","heightCropStart","widthCropEnd","heightCropEnd","cropBox","summary","create","get","Error","document","createElement","webcamIterator","start","facingMode","assert","stream","navigator","mediaDevices","getUserMedia","video","deviceId","e","message","srcObject","error","console","log","src","window","URL","createObjectURL","play","Promise","resolve","onloadedmetadata","next","value","done","img","fromPixels","JSON","stringify","cropAndResizeFrame","dispose","expandedImage","resizedImage","cropAndResize","shape","slice","capture","stop","tracks","getTracks","forEach","track","toArray"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-data/dist/iterators/webcam_iterator.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { browser, cast, env, expandDims, image, reshape, tensor1d, tensor2d, tidy, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of image tensors from webcam video stream. Only works in\n * browser environment.\n */\nexport class WebcamIterator extends LazyIterator {\n    constructor(webcamVideoElement, webcamConfig) {\n        super();\n        this.webcamVideoElement = webcamVideoElement;\n        this.webcamConfig = webcamConfig;\n        this.isClosed = true;\n        this.resize = false;\n        if (this.needToResize()) {\n            this.resize = true;\n            this.cropSize =\n                [this.webcamConfig.resizeHeight, this.webcamConfig.resizeWidth];\n            this.cropBoxInd = tensor1d([0], 'int32');\n            if (this.webcamConfig.centerCrop) {\n                // Calculate the box based on resizing shape.\n                const widthCroppingRatio = this.webcamConfig.resizeWidth * 1.0 / this.webcamVideoElement.width;\n                const heightCroppingRatio = this.webcamConfig.resizeHeight * 1.0 /\n                    this.webcamVideoElement.height;\n                const widthCropStart = (1 - widthCroppingRatio) / 2;\n                const heightCropStart = (1 - heightCroppingRatio) / 2;\n                const widthCropEnd = widthCropStart + widthCroppingRatio;\n                const heightCropEnd = heightCroppingRatio + heightCropStart;\n                this.cropBox = tensor2d([heightCropStart, widthCropStart, heightCropEnd, widthCropEnd], [1, 4]);\n            }\n            else {\n                this.cropBox = tensor2d([0, 0, 1, 1], [1, 4]);\n            }\n        }\n    }\n    summary() {\n        return `webcam`;\n    }\n    // Construct a WebcamIterator and start it's video stream.\n    static async create(webcamVideoElement, webcamConfig = {}) {\n        if (!env().get('IS_BROWSER')) {\n            throw new Error('tf.data.webcam is only supported in browser environment.');\n        }\n        if (!webcamVideoElement) {\n            // If webcam video element is not provided, create a hidden video element\n            // with provided width and height.\n            webcamVideoElement = document.createElement('video');\n            if (!webcamConfig.resizeWidth || !webcamConfig.resizeHeight) {\n                throw new Error('Please provide webcam video element, or resizeWidth and ' +\n                    'resizeHeight to create a hidden video element.');\n            }\n            webcamVideoElement.width = webcamConfig.resizeWidth;\n            webcamVideoElement.height = webcamConfig.resizeHeight;\n        }\n        const webcamIterator = new WebcamIterator(webcamVideoElement, webcamConfig);\n        // Call async function to initialize the video stream.\n        await webcamIterator.start();\n        return webcamIterator;\n    }\n    // Async function to start video stream.\n    async start() {\n        if (this.webcamConfig.facingMode) {\n            util.assert((this.webcamConfig.facingMode === 'user') ||\n                (this.webcamConfig.facingMode === 'environment'), () => `Invalid webcam facing mode: ${this.webcamConfig.facingMode}. ` +\n                `Please provide 'user' or 'environment'`);\n        }\n        try {\n            this.stream = await navigator.mediaDevices.getUserMedia({\n                video: {\n                    deviceId: this.webcamConfig.deviceId,\n                    facingMode: this.webcamConfig.facingMode ?\n                        this.webcamConfig.facingMode :\n                        'user',\n                    width: this.webcamVideoElement.width,\n                    height: this.webcamVideoElement.height\n                }\n            });\n        }\n        catch (e) {\n            // Modify the error message but leave the stack trace intact\n            e.message = `Error thrown while initializing video stream: ${e.message}`;\n            throw e;\n        }\n        if (!this.stream) {\n            throw new Error('Could not obtain video from webcam.');\n        }\n        // Older browsers may not have srcObject\n        try {\n            this.webcamVideoElement.srcObject = this.stream;\n        }\n        catch (error) {\n            console.log(error);\n            this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);\n        }\n        // Start the webcam video stream\n        this.webcamVideoElement.play();\n        this.isClosed = false;\n        return new Promise(resolve => {\n            // Add event listener to make sure the webcam has been fully initialized.\n            this.webcamVideoElement.onloadedmetadata = () => {\n                resolve();\n            };\n        });\n    }\n    async next() {\n        if (this.isClosed) {\n            return { value: null, done: true };\n        }\n        let img;\n        try {\n            img = browser.fromPixels(this.webcamVideoElement);\n        }\n        catch (e) {\n            throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`);\n        }\n        if (this.resize) {\n            try {\n                return { value: this.cropAndResizeFrame(img), done: false };\n            }\n            catch (e) {\n                throw new Error(`Error thrown cropping the video: ${e.message}`);\n            }\n            finally {\n                img.dispose();\n            }\n        }\n        else {\n            return { value: img, done: false };\n        }\n    }\n    needToResize() {\n        // If resizeWidth and resizeHeight are provided, and different from the\n        // width and height of original HTMLVideoElement, then resizing and cropping\n        // is required.\n        if (this.webcamConfig.resizeWidth && this.webcamConfig.resizeHeight &&\n            (this.webcamVideoElement.width !== this.webcamConfig.resizeWidth ||\n                this.webcamVideoElement.height !== this.webcamConfig.resizeHeight)) {\n            return true;\n        }\n        return false;\n    }\n    // Cropping and resizing each frame based on config\n    cropAndResizeFrame(img) {\n        return tidy(() => {\n            const expandedImage = expandDims(cast(img, 'float32'), (0));\n            let resizedImage;\n            resizedImage = image.cropAndResize(expandedImage, this.cropBox, this.cropBoxInd, this.cropSize, 'bilinear');\n            // Extract image from batch cropping.\n            const shape = resizedImage.shape;\n            return reshape(resizedImage, shape.slice(1));\n        });\n    }\n    // Capture one frame from the video stream, and extract the value from\n    // iterator.next() result.\n    async capture() {\n        return (await this.next()).value;\n    }\n    // Stop the video stream and pause webcam iterator.\n    stop() {\n        const tracks = this.stream.getTracks();\n        tracks.forEach(track => track.stop());\n        try {\n            this.webcamVideoElement.srcObject = null;\n        }\n        catch (error) {\n            console.log(error);\n            this.webcamVideoElement.src = null;\n        }\n        this.isClosed = true;\n    }\n    // Override toArray() function to prevent collecting.\n    toArray() {\n        throw new Error('Can not convert infinite video stream to array.');\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}