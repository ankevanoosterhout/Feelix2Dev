{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeNearestNeighborGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function resizeNearestNeighborGrad(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    images,\n    dy\n  } = inputs;\n  const {\n    alignCorners\n  } = attrs;\n  assertNotComplex([dy, images], 'resizeNearestNeighborGrad');\n  const imagesStrides = util.computeStrides(images.shape);\n  const dyStrides = util.computeStrides(dy.shape);\n  const [batch, xHeight, xWidth, depth] = images.shape;\n  const [, yHeight, yWidth] = dy.shape;\n  const output = new Float32Array(batch * xHeight * xWidth * depth);\n  const dyValues = backend.data.get(dy.dataId).values; // In the backwards pass, we want to find the pixels that were generated\n  // for each pixel in the input image the forward pass\n\n  const effectiveXSize = [alignCorners && yHeight > 1 ? xHeight - 1 : xHeight, alignCorners && yWidth > 1 ? xWidth - 1 : xWidth];\n  const effectiveYSize = [alignCorners && yHeight > 1 ? yHeight - 1 : yHeight, alignCorners && yWidth > 1 ? yWidth - 1 : yWidth];\n  const heightScale = effectiveXSize[0] / effectiveYSize[0];\n  const widthScale = effectiveXSize[1] / effectiveYSize[1];\n  const invHeightScale = 1 / heightScale;\n  const invWidthScale = 1 / widthScale; // This defines the size of the window of values around a particular\n  // index in dy that we want to search for contributions to dx.\n\n  const winHeight = Math.ceil(invHeightScale) * 2 + 2;\n  const winWidth = Math.ceil(invWidthScale) * 2 + 2; // Loop over the output space.\n\n  for (let b = 0; b < batch; b++) {\n    const batchOffset = b * imagesStrides[0];\n\n    for (let r = 0; r < xHeight; r++) {\n      const rowOffset = batchOffset + r * imagesStrides[1]; // Compute bounds for where in dy we will look\n\n      const startRLerp = Math.floor(r * invHeightScale);\n      const startDyR = Math.floor(startRLerp - winHeight / 2);\n\n      for (let c = 0; c < xWidth; c++) {\n        const colOffset = rowOffset + c * imagesStrides[2]; // Compute bounds for where in dy we will look\n\n        const startCLerp = Math.floor(c * invWidthScale);\n        const startDyC = Math.floor(startCLerp - winWidth / 2);\n\n        for (let d = 0; d < depth; d++) {\n          let accum = 0; // loop over dy\n\n          for (let dyRIndex = 0; dyRIndex < winHeight; dyRIndex++) {\n            const dyR = dyRIndex + startDyR; // Guard against the window exceeding the bounds of dy\n\n            if (dyR < 0 || dyR >= yHeight) {\n              continue;\n            }\n\n            const dyROffset = batchOffset + dyR * dyStrides[1];\n            const sourceFracRow = dyR * heightScale;\n            const sourceNearestRow = Math.min(xHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));\n\n            if (r !== sourceNearestRow) {\n              continue;\n            }\n\n            for (let dyCIndex = 0; dyCIndex < winWidth; dyCIndex++) {\n              const dyC = dyCIndex + startDyC; // Guard against the window exceeding the bounds of dy\n\n              if (dyC < 0 || dyC >= yWidth) {\n                continue;\n              }\n\n              const dyCOffset = dyROffset + dyC * dyStrides[2];\n              const sourceFracCol = dyC * widthScale;\n              const sourceNearestCol = Math.min(xWidth - 1, alignCorners ? Math.round(sourceFracCol) : Math.floor(sourceFracCol));\n\n              if (c === sourceNearestCol) {\n                accum += dyValues[dyCOffset + d];\n              }\n            }\n          }\n\n          output[colOffset + d] = accum;\n        }\n      }\n    }\n  }\n\n  return backend.makeTensorInfo(images.shape, images.dtype, output);\n}\nexport const resizeNearestNeighborGradConfig = {\n  kernelName: ResizeNearestNeighborGrad,\n  backendName: 'cpu',\n  kernelFunc: resizeNearestNeighborGrad\n};","map":{"version":3,"names":["ResizeNearestNeighborGrad","util","assertNotComplex","resizeNearestNeighborGrad","args","inputs","backend","attrs","images","dy","alignCorners","imagesStrides","computeStrides","shape","dyStrides","batch","xHeight","xWidth","depth","yHeight","yWidth","output","Float32Array","dyValues","data","get","dataId","values","effectiveXSize","effectiveYSize","heightScale","widthScale","invHeightScale","invWidthScale","winHeight","Math","ceil","winWidth","b","batchOffset","r","rowOffset","startRLerp","floor","startDyR","c","colOffset","startCLerp","startDyC","d","accum","dyRIndex","dyR","dyROffset","sourceFracRow","sourceNearestRow","min","round","dyCIndex","dyC","dyCOffset","sourceFracCol","sourceNearestCol","makeTensorInfo","dtype","resizeNearestNeighborGradConfig","kernelName","backendName","kernelFunc"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ResizeNearestNeighborGrad.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeNearestNeighborGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function resizeNearestNeighborGrad(args) {\n    const { inputs, backend, attrs } = args;\n    const { images, dy } = inputs;\n    const { alignCorners } = attrs;\n    assertNotComplex([dy, images], 'resizeNearestNeighborGrad');\n    const imagesStrides = util.computeStrides(images.shape);\n    const dyStrides = util.computeStrides(dy.shape);\n    const [batch, xHeight, xWidth, depth] = images.shape;\n    const [, yHeight, yWidth] = dy.shape;\n    const output = new Float32Array(batch * xHeight * xWidth * depth);\n    const dyValues = backend.data.get(dy.dataId).values;\n    // In the backwards pass, we want to find the pixels that were generated\n    // for each pixel in the input image the forward pass\n    const effectiveXSize = [\n        (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n        (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n    ];\n    const effectiveYSize = [\n        (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n        (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n    ];\n    const heightScale = effectiveXSize[0] / effectiveYSize[0];\n    const widthScale = effectiveXSize[1] / effectiveYSize[1];\n    const invHeightScale = 1 / heightScale;\n    const invWidthScale = 1 / widthScale;\n    // This defines the size of the window of values around a particular\n    // index in dy that we want to search for contributions to dx.\n    const winHeight = (Math.ceil(invHeightScale) * 2) + 2;\n    const winWidth = (Math.ceil(invWidthScale) * 2) + 2;\n    // Loop over the output space.\n    for (let b = 0; b < batch; b++) {\n        const batchOffset = b * imagesStrides[0];\n        for (let r = 0; r < xHeight; r++) {\n            const rowOffset = batchOffset + r * imagesStrides[1];\n            // Compute bounds for where in dy we will look\n            const startRLerp = Math.floor(r * invHeightScale);\n            const startDyR = Math.floor(startRLerp - (winHeight / 2));\n            for (let c = 0; c < xWidth; c++) {\n                const colOffset = rowOffset + c * imagesStrides[2];\n                // Compute bounds for where in dy we will look\n                const startCLerp = Math.floor(c * invWidthScale);\n                const startDyC = Math.floor(startCLerp - (winWidth / 2));\n                for (let d = 0; d < depth; d++) {\n                    let accum = 0;\n                    // loop over dy\n                    for (let dyRIndex = 0; dyRIndex < winHeight; dyRIndex++) {\n                        const dyR = dyRIndex + startDyR;\n                        // Guard against the window exceeding the bounds of dy\n                        if (dyR < 0 || dyR >= yHeight) {\n                            continue;\n                        }\n                        const dyROffset = batchOffset + dyR * dyStrides[1];\n                        const sourceFracRow = dyR * heightScale;\n                        const sourceNearestRow = Math.min(xHeight - 1, alignCorners ? Math.round(sourceFracRow) :\n                            Math.floor(sourceFracRow));\n                        if (r !== sourceNearestRow) {\n                            continue;\n                        }\n                        for (let dyCIndex = 0; dyCIndex < winWidth; dyCIndex++) {\n                            const dyC = dyCIndex + startDyC;\n                            // Guard against the window exceeding the bounds of dy\n                            if (dyC < 0 || dyC >= yWidth) {\n                                continue;\n                            }\n                            const dyCOffset = dyROffset + dyC * dyStrides[2];\n                            const sourceFracCol = dyC * widthScale;\n                            const sourceNearestCol = Math.min(xWidth - 1, alignCorners ? Math.round(sourceFracCol) :\n                                Math.floor(sourceFracCol));\n                            if (c === sourceNearestCol) {\n                                accum += dyValues[dyCOffset + d];\n                            }\n                        }\n                    }\n                    output[colOffset + d] = accum;\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo(images.shape, images.dtype, output);\n}\nexport const resizeNearestNeighborGradConfig = {\n    kernelName: ResizeNearestNeighborGrad,\n    backendName: 'cpu',\n    kernelFunc: resizeNearestNeighborGrad\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}