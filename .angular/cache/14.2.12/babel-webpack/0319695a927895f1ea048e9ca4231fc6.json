{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { Transform } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport * as util from '../../util';\nimport { op } from '../operation';\n/**\n * Applies the given transform(s) to the image(s).\n *\n * @param image 4d tensor of shape `[batch, imageHeight, imageWidth, depth]`.\n * @param transforms Projective transform matrix/matrices. A tensor1d of length\n *     8 or tensor of size N x 8. If one row of transforms is [a0, a1, a2, b0,\n *     b1, b2, c0, c1], then it maps the output point (x, y) to a transformed\n *     input point (x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k),\n *     where k = c0 x + c1 y + 1. The transforms are inverted compared to the\n *     transform mapping input points to output points.\n * @param interpolation Interpolation mode.\n *     Supported values: 'nearest', 'bilinear'. Default to 'nearest'.\n * @param fillMode Points outside the boundaries of the input are filled\n *     according to the given mode, one of 'constant', 'reflect', 'wrap',\n *     'nearest'. Default to 'constant'.\n *     'reflect': (d c b a | a b c d | d c b a ) The input is extended by\n *     reflecting about the edge of the last pixel.\n *     'constant': (k k k k | a b c d | k k k k) The input is extended by\n *     filling all values beyond the edge with the same constant value k.\n *     'wrap': (a b c d | a b c d | a b c d) The input is extended by\n *     wrapping around to the opposite edge.\n *     'nearest': (a a a a | a b c d | d d d d) The input is extended by\n *     the nearest pixel.\n * @param fillValue A float represents the value to be filled outside the\n *     boundaries when fillMode is 'constant'.\n * @param Output dimension after the transform, [height, width]. If undefined,\n *     output is the same size as input image.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\n\nfunction transform_(image, transforms, interpolation = 'nearest', fillMode = 'constant', fillValue = 0, outputShape) {\n  const $image = convertToTensor(image, 'image', 'transform', 'float32');\n  const $transforms = convertToTensor(transforms, 'transforms', 'transform', 'float32');\n  util.assert($image.rank === 4, () => 'Error in transform: image must be rank 4,' + `but got rank ${$image.rank}.`);\n  util.assert($transforms.rank === 2 && ($transforms.shape[0] === $image.shape[0] || $transforms.shape[0] === 1) && $transforms.shape[1] === 8, () => `Error in transform: Input transform should be batch x 8 or 1 x 8`);\n  util.assert(outputShape == null || outputShape.length === 2, () => 'Error in transform: outputShape must be [height, width] or null, ' + `but got ${outputShape}.`);\n  const inputs = {\n    image: $image,\n    transforms: $transforms\n  };\n  const attrs = {\n    interpolation,\n    fillMode,\n    fillValue,\n    outputShape\n  };\n  return ENGINE.runKernel(Transform, inputs, attrs);\n}\n\nexport const transform = op({\n  transform_\n});","map":{"version":3,"names":["ENGINE","Transform","convertToTensor","util","op","transform_","image","transforms","interpolation","fillMode","fillValue","outputShape","$image","$transforms","assert","rank","shape","length","inputs","attrs","runKernel","transform"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-core/dist/ops/image/transform.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { Transform } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport * as util from '../../util';\nimport { op } from '../operation';\n/**\n * Applies the given transform(s) to the image(s).\n *\n * @param image 4d tensor of shape `[batch, imageHeight, imageWidth, depth]`.\n * @param transforms Projective transform matrix/matrices. A tensor1d of length\n *     8 or tensor of size N x 8. If one row of transforms is [a0, a1, a2, b0,\n *     b1, b2, c0, c1], then it maps the output point (x, y) to a transformed\n *     input point (x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k),\n *     where k = c0 x + c1 y + 1. The transforms are inverted compared to the\n *     transform mapping input points to output points.\n * @param interpolation Interpolation mode.\n *     Supported values: 'nearest', 'bilinear'. Default to 'nearest'.\n * @param fillMode Points outside the boundaries of the input are filled\n *     according to the given mode, one of 'constant', 'reflect', 'wrap',\n *     'nearest'. Default to 'constant'.\n *     'reflect': (d c b a | a b c d | d c b a ) The input is extended by\n *     reflecting about the edge of the last pixel.\n *     'constant': (k k k k | a b c d | k k k k) The input is extended by\n *     filling all values beyond the edge with the same constant value k.\n *     'wrap': (a b c d | a b c d | a b c d) The input is extended by\n *     wrapping around to the opposite edge.\n *     'nearest': (a a a a | a b c d | d d d d) The input is extended by\n *     the nearest pixel.\n * @param fillValue A float represents the value to be filled outside the\n *     boundaries when fillMode is 'constant'.\n * @param Output dimension after the transform, [height, width]. If undefined,\n *     output is the same size as input image.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction transform_(image, transforms, interpolation = 'nearest', fillMode = 'constant', fillValue = 0, outputShape) {\n    const $image = convertToTensor(image, 'image', 'transform', 'float32');\n    const $transforms = convertToTensor(transforms, 'transforms', 'transform', 'float32');\n    util.assert($image.rank === 4, () => 'Error in transform: image must be rank 4,' +\n        `but got rank ${$image.rank}.`);\n    util.assert($transforms.rank === 2 &&\n        ($transforms.shape[0] === $image.shape[0] ||\n            $transforms.shape[0] === 1) &&\n        $transforms.shape[1] === 8, () => `Error in transform: Input transform should be batch x 8 or 1 x 8`);\n    util.assert(outputShape == null || outputShape.length === 2, () => 'Error in transform: outputShape must be [height, width] or null, ' +\n        `but got ${outputShape}.`);\n    const inputs = { image: $image, transforms: $transforms };\n    const attrs = { interpolation, fillMode, fillValue, outputShape };\n    return ENGINE.runKernel(Transform, inputs, attrs);\n}\nexport const transform = op({ transform_ });\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAT,QAAuB,cAAvB;AACA,SAASC,SAAT,QAA0B,oBAA1B;AACA,SAASC,eAAT,QAAgC,uBAAhC;AACA,OAAO,KAAKC,IAAZ,MAAsB,YAAtB;AACA,SAASC,EAAT,QAAmB,cAAnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,UAAT,CAAoBC,KAApB,EAA2BC,UAA3B,EAAuCC,aAAa,GAAG,SAAvD,EAAkEC,QAAQ,GAAG,UAA7E,EAAyFC,SAAS,GAAG,CAArG,EAAwGC,WAAxG,EAAqH;EACjH,MAAMC,MAAM,GAAGV,eAAe,CAACI,KAAD,EAAQ,OAAR,EAAiB,WAAjB,EAA8B,SAA9B,CAA9B;EACA,MAAMO,WAAW,GAAGX,eAAe,CAACK,UAAD,EAAa,YAAb,EAA2B,WAA3B,EAAwC,SAAxC,CAAnC;EACAJ,IAAI,CAACW,MAAL,CAAYF,MAAM,CAACG,IAAP,KAAgB,CAA5B,EAA+B,MAAM,8CAChC,gBAAeH,MAAM,CAACG,IAAK,GADhC;EAEAZ,IAAI,CAACW,MAAL,CAAYD,WAAW,CAACE,IAAZ,KAAqB,CAArB,KACPF,WAAW,CAACG,KAAZ,CAAkB,CAAlB,MAAyBJ,MAAM,CAACI,KAAP,CAAa,CAAb,CAAzB,IACGH,WAAW,CAACG,KAAZ,CAAkB,CAAlB,MAAyB,CAFrB,KAGRH,WAAW,CAACG,KAAZ,CAAkB,CAAlB,MAAyB,CAH7B,EAGgC,MAAO,kEAHvC;EAIAb,IAAI,CAACW,MAAL,CAAYH,WAAW,IAAI,IAAf,IAAuBA,WAAW,CAACM,MAAZ,KAAuB,CAA1D,EAA6D,MAAM,sEAC9D,WAAUN,WAAY,GAD3B;EAEA,MAAMO,MAAM,GAAG;IAAEZ,KAAK,EAAEM,MAAT;IAAiBL,UAAU,EAAEM;EAA7B,CAAf;EACA,MAAMM,KAAK,GAAG;IAAEX,aAAF;IAAiBC,QAAjB;IAA2BC,SAA3B;IAAsCC;EAAtC,CAAd;EACA,OAAOX,MAAM,CAACoB,SAAP,CAAiBnB,SAAjB,EAA4BiB,MAA5B,EAAoCC,KAApC,CAAP;AACH;;AACD,OAAO,MAAME,SAAS,GAAGjB,EAAE,CAAC;EAAEC;AAAF,CAAD,CAApB"},"metadata":{},"sourceType":"module"}