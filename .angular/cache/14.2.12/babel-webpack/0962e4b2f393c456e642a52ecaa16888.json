{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { countParamsInWeights } from './variable_utils';\n/**\n * Print the summary of a LayersModel object.\n *\n * @param model tf.LayersModel instance.\n * @param lineLength Total length of printed lines. Set this to adapt to the\n *   display to different terminal or console sizes.\n * @param positions Relative or absolute positions of log elements in each\n *   line. Each number corresponds to right-most (i.e., ending) position of a\n *   column.\n *   If not provided, defaults to `[0.45, 0.85, 1]` for sequential-like\n *   models and `[0.33, 0.55, 0.67, 1]` for non-sequential like models.\n * @param printFn Print function to use.\n *   It will be called on each line of the summary. You can provide a custom\n *   function in order to capture the string summary. Defaults to `console.log`.\n */\n\nexport function printSummary(model, lineLength, positions, // tslint:disable-next-line:no-any\nprintFn = console.log) {\n  const sequentialLike = isModelSequentialLike(model); // Header names for different log elements.\n\n  const toDisplay = ['Layer (type)', 'Input Shape', 'Output shape', 'Param #'];\n\n  if (sequentialLike) {\n    lineLength = lineLength || 90;\n    positions = positions || [0.32, 0.61, 0.89, 1];\n  } else {\n    lineLength = lineLength || 115;\n    positions = positions || [0.24, 0.48, 0.70, 0.80, 1]; // Header names for different log elements.\n  }\n\n  if (positions[positions.length - 1] <= 1) {\n    // `positions` is relative. Convert it to absolute positioning.\n    positions = positions.map(p => Math.floor(lineLength * p));\n  }\n\n  let relevantNodes;\n\n  if (!sequentialLike) {\n    toDisplay.push('Receives inputs');\n    relevantNodes = [];\n\n    for (const depth in model.nodesByDepth) {\n      relevantNodes.push(...model.nodesByDepth[depth]);\n    }\n  }\n\n  printFn('_'.repeat(lineLength));\n  printRow(toDisplay, positions, printFn);\n  printFn('='.repeat(lineLength));\n  const layers = model.layers;\n\n  for (let i = 0; i < layers.length; ++i) {\n    if (sequentialLike) {\n      printLayerSummary(layers[i], positions, printFn);\n    } else {\n      printLayerSummaryWithConnections(layers[i], positions, relevantNodes, printFn);\n    }\n\n    printFn((i === layers.length - 1 ? '=' : '_').repeat(lineLength));\n  } // tslint:disable-next-line:no-any\n\n\n  model.checkTrainableWeightsConsistency();\n  const trainableCount = countTrainableParams(model);\n  const nonTrainableCount = countParamsInWeights(model.nonTrainableWeights);\n  printFn(`Total params: ${trainableCount + nonTrainableCount}`);\n  printFn(`Trainable params: ${trainableCount}`);\n  printFn(`Non-trainable params: ${nonTrainableCount}`);\n  printFn('_'.repeat(lineLength));\n}\n\nfunction countTrainableParams(model) {\n  let trainableCount; // tslint:disable:no-any\n\n  if (model.collectedTrainableWeights != null) {\n    trainableCount = countParamsInWeights(model.collectedTrainableWeights);\n  } else {\n    trainableCount = countParamsInWeights(model.trainableWeights);\n  } // tslint:enable:no-any\n\n\n  return trainableCount;\n}\n\nfunction isModelSequentialLike(model) {\n  let sequentialLike = true;\n  const nodesByDepth = [];\n  const nodes = [];\n\n  for (const depth in model.nodesByDepth) {\n    nodesByDepth.push(model.nodesByDepth[depth]);\n  }\n\n  for (const depthNodes of nodesByDepth) {\n    if (depthNodes.length > 1 || depthNodes.length === 1 && depthNodes[0].inboundLayers.length > 1) {\n      sequentialLike = false;\n      break;\n    }\n\n    nodes.push(...depthNodes);\n  }\n\n  if (sequentialLike) {\n    // Search for shared layers.\n    for (const layer of model.layers) {\n      let flag = false;\n\n      for (const node of layer.inboundNodes) {\n        if (nodes.indexOf(node) !== -1) {\n          if (flag) {\n            sequentialLike = false;\n            break;\n          } else {\n            flag = true;\n          }\n        }\n      }\n\n      if (!sequentialLike) {\n        break;\n      }\n    }\n  }\n\n  return sequentialLike;\n}\n\nfunction printRow(fields, positions, // tslint:disable-next-line:no-any\nprintFn = console.log) {\n  let line = '';\n\n  for (let i = 0; i < fields.length; ++i) {\n    if (i > 0) {\n      line = line.slice(0, line.length - 1) + ' ';\n    }\n\n    line += fields[i];\n    line = line.slice(0, positions[i]);\n    line += ' '.repeat(positions[i] - line.length);\n  }\n\n  printFn(line);\n}\n/**\n * Prints a summary for a single Layer, without connectivity information.\n *\n * @param layer: Layer instance to print.\n */\n\n\nfunction printLayerSummary(layer, positions, // tslint:disable-next-line:no-any\nprintFn) {\n  let outputShape;\n  let inputShape;\n\n  try {\n    inputShape = layer.inboundNodes.map(x => JSON.stringify(x.inputShapes)).join(',');\n  } catch (err) {\n    inputShape = 'multiple';\n  }\n\n  try {\n    outputShape = JSON.stringify(layer.outputShape);\n  } catch (err) {\n    outputShape = 'multiple';\n  }\n\n  const name = layer.name;\n  const className = layer.getClassName();\n  const fields = [`${name} (${className})`, inputShape, outputShape, layer.countParams().toString()];\n  printRow(fields, positions, printFn);\n}\n/**\n * Prints a summary for a single Layer, with connectivity information.\n */\n\n\nfunction printLayerSummaryWithConnections(layer, positions, relevantNodes, // tslint:disable-next-line:no-any\nprintFn) {\n  let outputShape;\n  let inputShape;\n\n  try {\n    inputShape = layer.inboundNodes.map(x => JSON.stringify(x.inputShapes)).join(',');\n  } catch (err) {\n    inputShape = 'multiple';\n  }\n\n  try {\n    outputShape = JSON.stringify(layer.outputShape);\n  } catch (err) {\n    outputShape = 'multiple';\n  }\n\n  const connections = [];\n\n  for (const node of layer.inboundNodes) {\n    if (relevantNodes != null && relevantNodes.length > 0 && relevantNodes.indexOf(node) === -1) {\n      continue;\n    }\n\n    for (let i = 0; i < node.inboundLayers.length; ++i) {\n      const inboundLayer = node.inboundLayers[i].name;\n      const inboundLayerIndex = node.nodeIndices[i];\n      const inboundTensorIndex = node.tensorIndices[i];\n      connections.push(`${inboundLayer}[${inboundLayerIndex}][${inboundTensorIndex}]`);\n    }\n  }\n\n  const name = layer.name;\n  const className = layer.getClassName();\n  const firstConnection = connections.length === 0 ? '' : connections[0];\n  const fields = [`${name} (${className})`, inputShape, outputShape, layer.countParams().toString(), firstConnection];\n  printRow(fields, positions, printFn);\n\n  for (let i = 1; i < connections.length; ++i) {\n    printRow(['', '', '', '', connections[i]], positions, printFn);\n  }\n}","map":{"version":3,"names":["countParamsInWeights","printSummary","model","lineLength","positions","printFn","console","log","sequentialLike","isModelSequentialLike","toDisplay","length","map","p","Math","floor","relevantNodes","push","depth","nodesByDepth","repeat","printRow","layers","i","printLayerSummary","printLayerSummaryWithConnections","checkTrainableWeightsConsistency","trainableCount","countTrainableParams","nonTrainableCount","nonTrainableWeights","collectedTrainableWeights","trainableWeights","nodes","depthNodes","inboundLayers","layer","flag","node","inboundNodes","indexOf","fields","line","slice","outputShape","inputShape","x","JSON","stringify","inputShapes","join","err","name","className","getClassName","countParams","toString","connections","inboundLayer","inboundLayerIndex","nodeIndices","inboundTensorIndex","tensorIndices","firstConnection"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-layers/dist/utils/layer_utils.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { countParamsInWeights } from './variable_utils';\n/**\n * Print the summary of a LayersModel object.\n *\n * @param model tf.LayersModel instance.\n * @param lineLength Total length of printed lines. Set this to adapt to the\n *   display to different terminal or console sizes.\n * @param positions Relative or absolute positions of log elements in each\n *   line. Each number corresponds to right-most (i.e., ending) position of a\n *   column.\n *   If not provided, defaults to `[0.45, 0.85, 1]` for sequential-like\n *   models and `[0.33, 0.55, 0.67, 1]` for non-sequential like models.\n * @param printFn Print function to use.\n *   It will be called on each line of the summary. You can provide a custom\n *   function in order to capture the string summary. Defaults to `console.log`.\n */\nexport function printSummary(model, lineLength, positions, \n// tslint:disable-next-line:no-any\nprintFn = console.log) {\n    const sequentialLike = isModelSequentialLike(model);\n    // Header names for different log elements.\n    const toDisplay = ['Layer (type)', 'Input Shape', 'Output shape', 'Param #'];\n    if (sequentialLike) {\n        lineLength = lineLength || 90;\n        positions = positions || [0.32, 0.61, 0.89, 1];\n    }\n    else {\n        lineLength = lineLength || 115;\n        positions = positions || [0.24, 0.48, 0.70, 0.80, 1];\n        // Header names for different log elements.\n    }\n    if (positions[positions.length - 1] <= 1) {\n        // `positions` is relative. Convert it to absolute positioning.\n        positions = positions.map(p => Math.floor(lineLength * p));\n    }\n    let relevantNodes;\n    if (!sequentialLike) {\n        toDisplay.push('Receives inputs');\n        relevantNodes = [];\n        for (const depth in model.nodesByDepth) {\n            relevantNodes.push(...model.nodesByDepth[depth]);\n        }\n    }\n    printFn('_'.repeat(lineLength));\n    printRow(toDisplay, positions, printFn);\n    printFn('='.repeat(lineLength));\n    const layers = model.layers;\n    for (let i = 0; i < layers.length; ++i) {\n        if (sequentialLike) {\n            printLayerSummary(layers[i], positions, printFn);\n        }\n        else {\n            printLayerSummaryWithConnections(layers[i], positions, relevantNodes, printFn);\n        }\n        printFn((i === layers.length - 1 ? '=' : '_').repeat(lineLength));\n    }\n    // tslint:disable-next-line:no-any\n    model.checkTrainableWeightsConsistency();\n    const trainableCount = countTrainableParams(model);\n    const nonTrainableCount = countParamsInWeights(model.nonTrainableWeights);\n    printFn(`Total params: ${trainableCount + nonTrainableCount}`);\n    printFn(`Trainable params: ${trainableCount}`);\n    printFn(`Non-trainable params: ${nonTrainableCount}`);\n    printFn('_'.repeat(lineLength));\n}\nfunction countTrainableParams(model) {\n    let trainableCount;\n    // tslint:disable:no-any\n    if (model.collectedTrainableWeights != null) {\n        trainableCount =\n            countParamsInWeights(model.collectedTrainableWeights);\n    }\n    else {\n        trainableCount = countParamsInWeights(model.trainableWeights);\n    }\n    // tslint:enable:no-any\n    return trainableCount;\n}\nfunction isModelSequentialLike(model) {\n    let sequentialLike = true;\n    const nodesByDepth = [];\n    const nodes = [];\n    for (const depth in model.nodesByDepth) {\n        nodesByDepth.push(model.nodesByDepth[depth]);\n    }\n    for (const depthNodes of nodesByDepth) {\n        if (depthNodes.length > 1 ||\n            depthNodes.length === 1 && depthNodes[0].inboundLayers.length > 1) {\n            sequentialLike = false;\n            break;\n        }\n        nodes.push(...depthNodes);\n    }\n    if (sequentialLike) {\n        // Search for shared layers.\n        for (const layer of model.layers) {\n            let flag = false;\n            for (const node of layer.inboundNodes) {\n                if (nodes.indexOf(node) !== -1) {\n                    if (flag) {\n                        sequentialLike = false;\n                        break;\n                    }\n                    else {\n                        flag = true;\n                    }\n                }\n            }\n            if (!sequentialLike) {\n                break;\n            }\n        }\n    }\n    return sequentialLike;\n}\nfunction printRow(fields, positions, \n// tslint:disable-next-line:no-any\nprintFn = console.log) {\n    let line = '';\n    for (let i = 0; i < fields.length; ++i) {\n        if (i > 0) {\n            line = line.slice(0, line.length - 1) + ' ';\n        }\n        line += fields[i];\n        line = line.slice(0, positions[i]);\n        line += ' '.repeat(positions[i] - line.length);\n    }\n    printFn(line);\n}\n/**\n * Prints a summary for a single Layer, without connectivity information.\n *\n * @param layer: Layer instance to print.\n */\nfunction printLayerSummary(layer, positions, \n// tslint:disable-next-line:no-any\nprintFn) {\n    let outputShape;\n    let inputShape;\n    try {\n        inputShape = (layer.inboundNodes.map(x => JSON.stringify(x.inputShapes))).join(',');\n    }\n    catch (err) {\n        inputShape = 'multiple';\n    }\n    try {\n        outputShape = JSON.stringify(layer.outputShape);\n    }\n    catch (err) {\n        outputShape = 'multiple';\n    }\n    const name = layer.name;\n    const className = layer.getClassName();\n    const fields = [`${name} (${className})`, inputShape,\n        outputShape, layer.countParams().toString()];\n    printRow(fields, positions, printFn);\n}\n/**\n * Prints a summary for a single Layer, with connectivity information.\n */\nfunction printLayerSummaryWithConnections(layer, positions, relevantNodes, \n// tslint:disable-next-line:no-any\nprintFn) {\n    let outputShape;\n    let inputShape;\n    try {\n        inputShape = (layer.inboundNodes.map(x => JSON.stringify(x.inputShapes))).join(',');\n    }\n    catch (err) {\n        inputShape = 'multiple';\n    }\n    try {\n        outputShape = JSON.stringify(layer.outputShape);\n    }\n    catch (err) {\n        outputShape = 'multiple';\n    }\n    const connections = [];\n    for (const node of layer.inboundNodes) {\n        if (relevantNodes != null && relevantNodes.length > 0 &&\n            relevantNodes.indexOf(node) === -1) {\n            continue;\n        }\n        for (let i = 0; i < node.inboundLayers.length; ++i) {\n            const inboundLayer = node.inboundLayers[i].name;\n            const inboundLayerIndex = node.nodeIndices[i];\n            const inboundTensorIndex = node.tensorIndices[i];\n            connections.push(`${inboundLayer}[${inboundLayerIndex}][${inboundTensorIndex}]`);\n        }\n    }\n    const name = layer.name;\n    const className = layer.getClassName();\n    const firstConnection = connections.length === 0 ? '' : connections[0];\n    const fields = [\n        `${name} (${className})`, inputShape,\n        outputShape, layer.countParams().toString(),\n        firstConnection\n    ];\n    printRow(fields, positions, printFn);\n    for (let i = 1; i < connections.length; ++i) {\n        printRow(['', '', '', '', connections[i]], positions, printFn);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}