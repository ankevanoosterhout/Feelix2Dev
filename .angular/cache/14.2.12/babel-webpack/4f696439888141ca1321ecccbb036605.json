{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\nvar _ref;\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { scalar } from '@tensorflow/tfjs-core';\nimport { TensorArray } from '../../executor/tensor_array';\nimport { fromTensor, reserve, scatter, split } from '../../executor/tensor_list';\nimport { cloneTensor, getParamValue, getTensor } from './utils';\nexport const executeOp = function executeOp(_x, _x2, _x3) {\n  return (_ref = _ref || _asyncToGenerator(function* (node, tensorMap, context) {\n    switch (node.op) {\n      case 'If':\n      case 'StatelessIf':\n        {\n          const thenFunc = getParamValue('thenBranch', node, tensorMap, context);\n          const elseFunc = getParamValue('elseBranch', node, tensorMap, context);\n          const cond = getParamValue('cond', node, tensorMap, context);\n          const args = getParamValue('args', node, tensorMap, context);\n          const condValue = yield cond.data();\n\n          if (condValue[0]) {\n            return context.functionMap[thenFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);\n          } else {\n            return context.functionMap[elseFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);\n          }\n        }\n\n      case 'While':\n      case 'StatelessWhile':\n        {\n          const bodyFunc = getParamValue('body', node, tensorMap, context);\n          const condFunc = getParamValue('cond', node, tensorMap, context);\n          const args = getParamValue('args', node, tensorMap, context); // Calculate the condition of the loop\n\n          const condResult = yield context.functionMap[condFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);\n          const argIds = args.map(tensor => tensor.id);\n          let condValue = yield condResult[0].data(); // Dispose the intermediate tensors for condition function\n\n          condResult.forEach(tensor => {\n            if (!tensor.kept && argIds.indexOf(tensor.id) === -1) {\n              tensor.dispose();\n            }\n          });\n          let result = args;\n\n          while (condValue[0]) {\n            // Record the previous result for intermediate tensor tracking\n            const origResult = result; // Execution the body of the loop\n\n            result = yield context.functionMap[bodyFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);\n            const resultIds = result.map(tensor => tensor.id); // Dispose the intermediate tensor for body function that is not global\n            // kept, not input/output of the body function\n\n            origResult.forEach(tensor => {\n              if (!tensor.kept && argIds.indexOf(tensor.id) === -1 && resultIds.indexOf(tensor.id) === -1) {\n                tensor.dispose();\n              }\n            }); // Recalcuate the condition of the loop using the latest results.\n\n            const condResult = yield context.functionMap[condFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);\n            condValue = yield condResult[0].data(); // Dispose the intermediate tensors for condition function\n\n            condResult.forEach(tensor => {\n              if (!tensor.kept && argIds.indexOf(tensor.id) === -1 && resultIds.indexOf(tensor.id) === -1) {\n                tensor.dispose();\n              }\n            });\n          }\n\n          return result;\n        }\n\n      case 'LoopCond':\n        {\n          const pred = getParamValue('pred', node, tensorMap, context);\n          return [cloneTensor(pred)];\n        }\n\n      case 'Switch':\n        {\n          const pred = getParamValue('pred', node, tensorMap, context);\n          let data = getParamValue('data', node, tensorMap, context);\n\n          if (!data.kept) {\n            data = cloneTensor(data);\n          } // Outputs nodes :0 => false, :1 => true\n\n\n          return (yield pred.data())[0] ? [undefined, data] : [data, undefined];\n        }\n\n      case 'Merge':\n        {\n          const inputName = node.inputNames.find(name => getTensor(name, tensorMap, context) !== undefined);\n\n          if (inputName) {\n            const data = getTensor(inputName, tensorMap, context);\n            return [cloneTensor(data)];\n          }\n\n          return undefined;\n        }\n\n      case 'Enter':\n        {\n          const frameId = getParamValue('frameName', node, tensorMap, context);\n          const data = getParamValue('tensor', node, tensorMap, context);\n          context.enterFrame(frameId);\n          return [cloneTensor(data)];\n        }\n\n      case 'Exit':\n        {\n          const data = getParamValue('tensor', node, tensorMap, context);\n          context.exitFrame();\n          return [cloneTensor(data)];\n        }\n\n      case 'NextIteration':\n        {\n          const data = getParamValue('tensor', node, tensorMap, context);\n          context.nextIteration();\n          return [cloneTensor(data)];\n        }\n\n      case 'TensorArrayV3':\n        {\n          const size = getParamValue('size', node, tensorMap, context);\n          const dtype = getParamValue('dtype', node, tensorMap, context);\n          const elementShape = getParamValue('elementShape', node, tensorMap, context);\n          const dynamicSize = getParamValue('dynamicSize', node, tensorMap, context);\n          const clearAfterRead = getParamValue('clearAfterRead', node, tensorMap, context);\n          const identicalElementShapes = getParamValue('identicalElementShapes', node, tensorMap, context);\n          const name = getParamValue('name', node, tensorMap, context);\n          const tensorArray = new TensorArray(name, dtype, size, elementShape, identicalElementShapes, dynamicSize, clearAfterRead);\n          context.addTensorArray(tensorArray);\n          return [tensorArray.idTensor, scalar(1.0)];\n        }\n\n      case 'TensorArrayWriteV3':\n        {\n          const id = getParamValue('tensorArrayId', node, tensorMap, context);\n          const index = getParamValue('index', node, tensorMap, context);\n          const writeTensor = getParamValue('tensor', node, tensorMap, context);\n          const writeTensorArray = context.getTensorArray(id.id);\n          writeTensorArray.write(index, writeTensor);\n          return [writeTensorArray.idTensor];\n        }\n\n      case 'TensorArrayReadV3':\n        {\n          const readId = getParamValue('tensorArrayId', node, tensorMap, context);\n          const readIndex = getParamValue('index', node, tensorMap, context);\n          const readTensorArray = context.getTensorArray(readId.id);\n          return [readTensorArray.read(readIndex)];\n        }\n\n      case 'TensorArrayGatherV3':\n        {\n          const gatherId = getParamValue('tensorArrayId', node, tensorMap, context);\n          const gatherIndices = getParamValue('indices', node, tensorMap, context);\n          const gatherDtype = getParamValue('dtype', node, tensorMap, context);\n          const gatherTensorArray = context.getTensorArray(gatherId.id);\n          return [gatherTensorArray.gather(gatherIndices, gatherDtype)];\n        }\n\n      case 'TensorArrayScatterV3':\n        {\n          const scatterId = getParamValue('tensorArrayId', node, tensorMap, context);\n          const scatterIndices = getParamValue('indices', node, tensorMap, context);\n          const scatterTensor = getParamValue('tensor', node, tensorMap, context);\n          const scatterTensorArray = context.getTensorArray(scatterId.id);\n          scatterTensorArray.scatter(scatterIndices, scatterTensor);\n          return [scatterTensorArray.idTensor];\n        }\n\n      case 'TensorArrayConcatV3':\n        {\n          const concatId = getParamValue('tensorArrayId', node, tensorMap, context);\n          const concatTensorArray = context.getTensorArray(concatId.id);\n          const concatDtype = getParamValue('dtype', node, tensorMap, context);\n          return [concatTensorArray.concat(concatDtype)];\n        }\n\n      case 'TensorArraySplitV3':\n        {\n          const splitId = getParamValue('tensorArrayId', node, tensorMap, context);\n          const splitTensor = getParamValue('tensor', node, tensorMap, context);\n          const lengths = getParamValue('lengths', node, tensorMap, context);\n          const splitTensorArray = context.getTensorArray(splitId.id);\n          splitTensorArray.split(lengths, splitTensor);\n          return [splitTensorArray.idTensor];\n        }\n\n      case 'TensorArraySizeV3':\n        {\n          const sizeId = getParamValue('tensorArrayId', node, tensorMap, context);\n          const sizeTensorArray = context.getTensorArray(sizeId.id);\n          return [scalar(sizeTensorArray.size(), 'int32')];\n        }\n\n      case 'TensorArrayCloseV3':\n        {\n          const closeId = getParamValue('tensorArrayId', node, tensorMap, context);\n          const closeTensorArray = context.getTensorArray(closeId.id);\n          closeTensorArray.clearAndClose();\n          return [closeTensorArray.idTensor];\n        }\n\n      case 'TensorListSetItem':\n        {\n          const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n          const index = getParamValue('index', node, tensorMap, context);\n          const writeTensor = getParamValue('tensor', node, tensorMap, context);\n          const tensorList = context.getTensorList(idTensor.id);\n          tensorList.setItem(index, writeTensor);\n          return [tensorList.idTensor];\n        }\n\n      case 'TensorListGetItem':\n        {\n          const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n          const readIndex = getParamValue('index', node, tensorMap, context);\n          const elementShape = getParamValue('elementShape', node, tensorMap, context);\n          const elementDType = getParamValue('elementDType', node, tensorMap, context);\n          const tensorList = context.getTensorList(idTensor.id);\n          return [tensorList.getItem(readIndex, elementShape, elementDType)];\n        }\n\n      case 'TensorListScatterV2':\n      case 'TensorListScatter':\n        {\n          const scatterIndices = getParamValue('indices', node, tensorMap, context);\n          const scatterTensor = getParamValue('tensor', node, tensorMap, context);\n          const elementShape = getParamValue('elementShape', node, tensorMap, context);\n          const numElements = getParamValue('numElements', node, tensorMap, context);\n          const tensorList = scatter(scatterTensor, scatterIndices, elementShape, numElements);\n          context.addTensorList(tensorList);\n          return [tensorList.idTensor];\n        }\n\n      case 'TensorListReserve':\n      case 'EmptyTensorList':\n        {\n          const elementShape = getParamValue('elementShape', node, tensorMap, context);\n          const elementDtype = getParamValue('elementDType', node, tensorMap, context);\n          let numElementsParam;\n\n          if (node.op === 'TensorListReserve') {\n            numElementsParam = 'numElements';\n          } else {\n            numElementsParam = 'maxNumElements';\n          }\n\n          const numElements = getParamValue(numElementsParam, node, tensorMap, context);\n          const maxNumElements = node.op === 'TensorListReserve' ? -1 : numElements;\n          const tensorList = reserve(elementShape, elementDtype, numElements, maxNumElements);\n          context.addTensorList(tensorList);\n          return [tensorList.idTensor];\n        }\n\n      case 'TensorListGather':\n        {\n          const gatherId = getParamValue('tensorListId', node, tensorMap, context);\n          const gatherIndices = getParamValue('indices', node, tensorMap, context);\n          const elementShape = getParamValue('elementShape', node, tensorMap, context);\n          const elementDtype = getParamValue('elementDType', node, tensorMap, context);\n          const tensorList = context.getTensorList(gatherId.id);\n          return [tensorList.gather(gatherIndices, elementDtype, elementShape)];\n        }\n\n      case 'TensorListStack':\n        {\n          const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n          const elementShape = getParamValue('elementShape', node, tensorMap, context);\n          const elementDtype = getParamValue('elementDType', node, tensorMap, context);\n          const numElements = getParamValue('numElements', node, tensorMap, context);\n          const tensorList = context.getTensorList(idTensor.id);\n          return [tensorList.stack(elementShape, elementDtype, numElements)];\n        }\n\n      case 'TensorListFromTensor':\n        {\n          const tensor = getParamValue('tensor', node, tensorMap, context);\n          const elementShape = getParamValue('elementShape', node, tensorMap, context);\n          const elementDtype = getParamValue('elementDType', node, tensorMap, context);\n          const tensorList = fromTensor(tensor, elementShape, elementDtype);\n          context.addTensorList(tensorList);\n          return [tensorList.idTensor];\n        }\n\n      case 'TensorListConcat':\n      case 'TensorListConcatV2':\n        {\n          const concatId = getParamValue('tensorListId', node, tensorMap, context);\n          const tensorList = context.getTensorList(concatId.id);\n          const concatDtype = getParamValue('dtype', node, tensorMap, context);\n          const elementShape = getParamValue('elementShape', node, tensorMap, context);\n          return [tensorList.concat(concatDtype, elementShape)];\n        }\n\n      case 'TensorListPushBack':\n        {\n          const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n          const writeTensor = getParamValue('tensor', node, tensorMap, context);\n          const tensorList = context.getTensorList(idTensor.id);\n          tensorList.pushBack(writeTensor);\n          return [tensorList.idTensor];\n        }\n\n      case 'TensorListPopBack':\n        {\n          const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n          const elementShape = getParamValue('elementShape', node, tensorMap, context);\n          const elementDType = getParamValue('elementDType', node, tensorMap, context);\n          const tensorList = context.getTensorList(idTensor.id);\n          return [tensorList.popBack(elementShape, elementDType)];\n        }\n\n      case 'TensorListSplit':\n        {\n          const splitTensor = getParamValue('tensor', node, tensorMap, context);\n          const elementShape = getParamValue('elementShape', node, tensorMap, context);\n          const lengths = getParamValue('lengths', node, tensorMap, context);\n          const tensorList = split(splitTensor, lengths, elementShape);\n          context.addTensorList(tensorList);\n          return [tensorList.idTensor];\n        }\n\n      case 'TensorListLength':\n        {\n          const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n          const tensorList = context.getTensorList(idTensor.id);\n          return [scalar(tensorList.size(), 'int32')];\n        }\n\n      case 'TensorListResize':\n        {\n          const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n          const size = getParamValue('size', node, tensorMap, context);\n          const srcTensorList = context.getTensorList(idTensor.id);\n          const destTensorList = srcTensorList.resize(size);\n          context.addTensorList(destTensorList);\n          return [destTensorList.idTensor];\n        }\n\n      default:\n        throw TypeError(`Node type ${node.op} is not implemented`);\n    }\n  })).apply(this, arguments);\n};\nexport const CATEGORY = 'control';","map":{"version":3,"names":["scalar","TensorArray","fromTensor","reserve","scatter","split","cloneTensor","getParamValue","getTensor","executeOp","node","tensorMap","context","op","thenFunc","elseFunc","cond","args","condValue","data","functionMap","executeFunctionAsync","tensorArrayMap","tensorListMap","bodyFunc","condFunc","condResult","argIds","map","tensor","id","forEach","kept","indexOf","dispose","result","origResult","resultIds","pred","undefined","inputName","inputNames","find","name","frameId","enterFrame","exitFrame","nextIteration","size","dtype","elementShape","dynamicSize","clearAfterRead","identicalElementShapes","tensorArray","addTensorArray","idTensor","index","writeTensor","writeTensorArray","getTensorArray","write","readId","readIndex","readTensorArray","read","gatherId","gatherIndices","gatherDtype","gatherTensorArray","gather","scatterId","scatterIndices","scatterTensor","scatterTensorArray","concatId","concatTensorArray","concatDtype","concat","splitId","splitTensor","lengths","splitTensorArray","sizeId","sizeTensorArray","closeId","closeTensorArray","clearAndClose","tensorList","getTensorList","setItem","elementDType","getItem","numElements","addTensorList","elementDtype","numElementsParam","maxNumElements","stack","pushBack","popBack","srcTensorList","destTensorList","resize","TypeError","CATEGORY"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-converter/dist/operations/executors/control_executor.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { scalar } from '@tensorflow/tfjs-core';\nimport { TensorArray } from '../../executor/tensor_array';\nimport { fromTensor, reserve, scatter, split } from '../../executor/tensor_list';\nimport { cloneTensor, getParamValue, getTensor } from './utils';\nexport const executeOp = async (node, tensorMap, context) => {\n    switch (node.op) {\n        case 'If':\n        case 'StatelessIf': {\n            const thenFunc = getParamValue('thenBranch', node, tensorMap, context);\n            const elseFunc = getParamValue('elseBranch', node, tensorMap, context);\n            const cond = getParamValue('cond', node, tensorMap, context);\n            const args = getParamValue('args', node, tensorMap, context);\n            const condValue = await cond.data();\n            if (condValue[0]) {\n                return context.functionMap[thenFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);\n            }\n            else {\n                return context.functionMap[elseFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);\n            }\n        }\n        case 'While':\n        case 'StatelessWhile': {\n            const bodyFunc = getParamValue('body', node, tensorMap, context);\n            const condFunc = getParamValue('cond', node, tensorMap, context);\n            const args = getParamValue('args', node, tensorMap, context);\n            // Calculate the condition of the loop\n            const condResult = (await context.functionMap[condFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap));\n            const argIds = args.map(tensor => tensor.id);\n            let condValue = await condResult[0].data();\n            // Dispose the intermediate tensors for condition function\n            condResult.forEach(tensor => {\n                if (!tensor.kept && argIds.indexOf(tensor.id) === -1) {\n                    tensor.dispose();\n                }\n            });\n            let result = args;\n            while (condValue[0]) {\n                // Record the previous result for intermediate tensor tracking\n                const origResult = result;\n                // Execution the body of the loop\n                result = await context.functionMap[bodyFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);\n                const resultIds = result.map(tensor => tensor.id);\n                // Dispose the intermediate tensor for body function that is not global\n                // kept, not input/output of the body function\n                origResult.forEach(tensor => {\n                    if (!tensor.kept && argIds.indexOf(tensor.id) === -1 &&\n                        resultIds.indexOf(tensor.id) === -1) {\n                        tensor.dispose();\n                    }\n                });\n                // Recalcuate the condition of the loop using the latest results.\n                const condResult = (await context.functionMap[condFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap));\n                condValue = await condResult[0].data();\n                // Dispose the intermediate tensors for condition function\n                condResult.forEach(tensor => {\n                    if (!tensor.kept && argIds.indexOf(tensor.id) === -1 &&\n                        resultIds.indexOf(tensor.id) === -1) {\n                        tensor.dispose();\n                    }\n                });\n            }\n            return result;\n        }\n        case 'LoopCond': {\n            const pred = getParamValue('pred', node, tensorMap, context);\n            return [cloneTensor(pred)];\n        }\n        case 'Switch': {\n            const pred = getParamValue('pred', node, tensorMap, context);\n            let data = getParamValue('data', node, tensorMap, context);\n            if (!data.kept) {\n                data = cloneTensor(data);\n            }\n            // Outputs nodes :0 => false, :1 => true\n            return (await pred.data())[0] ? [undefined, data] : [data, undefined];\n        }\n        case 'Merge': {\n            const inputName = node.inputNames.find(name => getTensor(name, tensorMap, context) !== undefined);\n            if (inputName) {\n                const data = getTensor(inputName, tensorMap, context);\n                return [cloneTensor(data)];\n            }\n            return undefined;\n        }\n        case 'Enter': {\n            const frameId = getParamValue('frameName', node, tensorMap, context);\n            const data = getParamValue('tensor', node, tensorMap, context);\n            context.enterFrame(frameId);\n            return [cloneTensor(data)];\n        }\n        case 'Exit': {\n            const data = getParamValue('tensor', node, tensorMap, context);\n            context.exitFrame();\n            return [cloneTensor(data)];\n        }\n        case 'NextIteration': {\n            const data = getParamValue('tensor', node, tensorMap, context);\n            context.nextIteration();\n            return [cloneTensor(data)];\n        }\n        case 'TensorArrayV3': {\n            const size = getParamValue('size', node, tensorMap, context);\n            const dtype = getParamValue('dtype', node, tensorMap, context);\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\n            const dynamicSize = getParamValue('dynamicSize', node, tensorMap, context);\n            const clearAfterRead = getParamValue('clearAfterRead', node, tensorMap, context);\n            const identicalElementShapes = getParamValue('identicalElementShapes', node, tensorMap, context);\n            const name = getParamValue('name', node, tensorMap, context);\n            const tensorArray = new TensorArray(name, dtype, size, elementShape, identicalElementShapes, dynamicSize, clearAfterRead);\n            context.addTensorArray(tensorArray);\n            return [tensorArray.idTensor, scalar(1.0)];\n        }\n        case 'TensorArrayWriteV3': {\n            const id = getParamValue('tensorArrayId', node, tensorMap, context);\n            const index = getParamValue('index', node, tensorMap, context);\n            const writeTensor = getParamValue('tensor', node, tensorMap, context);\n            const writeTensorArray = context.getTensorArray(id.id);\n            writeTensorArray.write(index, writeTensor);\n            return [writeTensorArray.idTensor];\n        }\n        case 'TensorArrayReadV3': {\n            const readId = getParamValue('tensorArrayId', node, tensorMap, context);\n            const readIndex = getParamValue('index', node, tensorMap, context);\n            const readTensorArray = context.getTensorArray(readId.id);\n            return [readTensorArray.read(readIndex)];\n        }\n        case 'TensorArrayGatherV3': {\n            const gatherId = getParamValue('tensorArrayId', node, tensorMap, context);\n            const gatherIndices = getParamValue('indices', node, tensorMap, context);\n            const gatherDtype = getParamValue('dtype', node, tensorMap, context);\n            const gatherTensorArray = context.getTensorArray(gatherId.id);\n            return [gatherTensorArray.gather(gatherIndices, gatherDtype)];\n        }\n        case 'TensorArrayScatterV3': {\n            const scatterId = getParamValue('tensorArrayId', node, tensorMap, context);\n            const scatterIndices = getParamValue('indices', node, tensorMap, context);\n            const scatterTensor = getParamValue('tensor', node, tensorMap, context);\n            const scatterTensorArray = context.getTensorArray(scatterId.id);\n            scatterTensorArray.scatter(scatterIndices, scatterTensor);\n            return [scatterTensorArray.idTensor];\n        }\n        case 'TensorArrayConcatV3': {\n            const concatId = getParamValue('tensorArrayId', node, tensorMap, context);\n            const concatTensorArray = context.getTensorArray(concatId.id);\n            const concatDtype = getParamValue('dtype', node, tensorMap, context);\n            return [concatTensorArray.concat(concatDtype)];\n        }\n        case 'TensorArraySplitV3': {\n            const splitId = getParamValue('tensorArrayId', node, tensorMap, context);\n            const splitTensor = getParamValue('tensor', node, tensorMap, context);\n            const lengths = getParamValue('lengths', node, tensorMap, context);\n            const splitTensorArray = context.getTensorArray(splitId.id);\n            splitTensorArray.split(lengths, splitTensor);\n            return [splitTensorArray.idTensor];\n        }\n        case 'TensorArraySizeV3': {\n            const sizeId = getParamValue('tensorArrayId', node, tensorMap, context);\n            const sizeTensorArray = context.getTensorArray(sizeId.id);\n            return [scalar(sizeTensorArray.size(), 'int32')];\n        }\n        case 'TensorArrayCloseV3': {\n            const closeId = getParamValue('tensorArrayId', node, tensorMap, context);\n            const closeTensorArray = context.getTensorArray(closeId.id);\n            closeTensorArray.clearAndClose();\n            return [closeTensorArray.idTensor];\n        }\n        case 'TensorListSetItem': {\n            const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n            const index = getParamValue('index', node, tensorMap, context);\n            const writeTensor = getParamValue('tensor', node, tensorMap, context);\n            const tensorList = context.getTensorList(idTensor.id);\n            tensorList.setItem(index, writeTensor);\n            return [tensorList.idTensor];\n        }\n        case 'TensorListGetItem': {\n            const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n            const readIndex = getParamValue('index', node, tensorMap, context);\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\n            const elementDType = getParamValue('elementDType', node, tensorMap, context);\n            const tensorList = context.getTensorList(idTensor.id);\n            return [tensorList.getItem(readIndex, elementShape, elementDType)];\n        }\n        case 'TensorListScatterV2':\n        case 'TensorListScatter': {\n            const scatterIndices = getParamValue('indices', node, tensorMap, context);\n            const scatterTensor = getParamValue('tensor', node, tensorMap, context);\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\n            const numElements = getParamValue('numElements', node, tensorMap, context);\n            const tensorList = scatter(scatterTensor, scatterIndices, elementShape, numElements);\n            context.addTensorList(tensorList);\n            return [tensorList.idTensor];\n        }\n        case 'TensorListReserve':\n        case 'EmptyTensorList': {\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\n            const elementDtype = getParamValue('elementDType', node, tensorMap, context);\n            let numElementsParam;\n            if (node.op === 'TensorListReserve') {\n                numElementsParam = 'numElements';\n            }\n            else {\n                numElementsParam = 'maxNumElements';\n            }\n            const numElements = getParamValue(numElementsParam, node, tensorMap, context);\n            const maxNumElements = node.op === 'TensorListReserve' ? -1 : numElements;\n            const tensorList = reserve(elementShape, elementDtype, numElements, maxNumElements);\n            context.addTensorList(tensorList);\n            return [tensorList.idTensor];\n        }\n        case 'TensorListGather': {\n            const gatherId = getParamValue('tensorListId', node, tensorMap, context);\n            const gatherIndices = getParamValue('indices', node, tensorMap, context);\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\n            const elementDtype = getParamValue('elementDType', node, tensorMap, context);\n            const tensorList = context.getTensorList(gatherId.id);\n            return [tensorList.gather(gatherIndices, elementDtype, elementShape)];\n        }\n        case 'TensorListStack': {\n            const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\n            const elementDtype = getParamValue('elementDType', node, tensorMap, context);\n            const numElements = getParamValue('numElements', node, tensorMap, context);\n            const tensorList = context.getTensorList(idTensor.id);\n            return [tensorList.stack(elementShape, elementDtype, numElements)];\n        }\n        case 'TensorListFromTensor': {\n            const tensor = getParamValue('tensor', node, tensorMap, context);\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\n            const elementDtype = getParamValue('elementDType', node, tensorMap, context);\n            const tensorList = fromTensor(tensor, elementShape, elementDtype);\n            context.addTensorList(tensorList);\n            return [tensorList.idTensor];\n        }\n        case 'TensorListConcat':\n        case 'TensorListConcatV2': {\n            const concatId = getParamValue('tensorListId', node, tensorMap, context);\n            const tensorList = context.getTensorList(concatId.id);\n            const concatDtype = getParamValue('dtype', node, tensorMap, context);\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\n            return [tensorList.concat(concatDtype, elementShape)];\n        }\n        case 'TensorListPushBack': {\n            const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n            const writeTensor = getParamValue('tensor', node, tensorMap, context);\n            const tensorList = context.getTensorList(idTensor.id);\n            tensorList.pushBack(writeTensor);\n            return [tensorList.idTensor];\n        }\n        case 'TensorListPopBack': {\n            const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\n            const elementDType = getParamValue('elementDType', node, tensorMap, context);\n            const tensorList = context.getTensorList(idTensor.id);\n            return [tensorList.popBack(elementShape, elementDType)];\n        }\n        case 'TensorListSplit': {\n            const splitTensor = getParamValue('tensor', node, tensorMap, context);\n            const elementShape = getParamValue('elementShape', node, tensorMap, context);\n            const lengths = getParamValue('lengths', node, tensorMap, context);\n            const tensorList = split(splitTensor, lengths, elementShape);\n            context.addTensorList(tensorList);\n            return [tensorList.idTensor];\n        }\n        case 'TensorListLength': {\n            const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n            const tensorList = context.getTensorList(idTensor.id);\n            return [scalar(tensorList.size(), 'int32')];\n        }\n        case 'TensorListResize': {\n            const idTensor = getParamValue('tensorListId', node, tensorMap, context);\n            const size = getParamValue('size', node, tensorMap, context);\n            const srcTensorList = context.getTensorList(idTensor.id);\n            const destTensorList = srcTensorList.resize(size);\n            context.addTensorList(destTensorList);\n            return [destTensorList.idTensor];\n        }\n        default:\n            throw TypeError(`Node type ${node.op} is not implemented`);\n    }\n};\nexport const CATEGORY = 'control';\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}