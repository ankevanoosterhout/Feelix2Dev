{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nimport { add } from '../kernels/Add';\nimport { complex } from '../kernels/Complex';\nimport { concat } from '../kernels/Concat';\nimport { identity } from '../kernels/Identity';\nimport { imag } from '../kernels/Imag';\nimport { multiply } from '../kernels/Multiply';\nimport { real } from '../kernels/Real';\nimport { realDivConfig } from '../kernels/RealDiv';\nimport { slice } from '../kernels/Slice';\nimport { sub } from '../kernels/Sub';\n/**\n * Calculate FFT of inner most elements of batch tensor.\n */\n\nexport function fftBatch(input, inverse, cpuBackend) {\n  const inputShape = input.shape;\n  const batch = inputShape[0];\n  const innerDim = inputShape[1];\n  const inputVals = cpuBackend.data.get(input.dataId);\n  const real2D = inputVals.complexTensorInfos.real;\n  const imag2D = inputVals.complexTensorInfos.imag; // Collects real and imaginary values separately.\n\n  const resultShape = [batch, innerDim];\n  const resultSize = util.sizeFromShape(resultShape);\n  const resultReal = util.getTypedArrayFromDType('float32', resultSize);\n  const resultImag = util.getTypedArrayFromDType('float32', resultSize);\n\n  for (let b = 0; b < batch; b++) {\n    // TODO: Support slice ops for complex type.\n    const r = slice({\n      inputs: {\n        x: real2D\n      },\n      backend: cpuBackend,\n      attrs: {\n        begin: [b, 0],\n        size: [1, innerDim]\n      }\n    });\n    const i = slice({\n      inputs: {\n        x: imag2D\n      },\n      backend: cpuBackend,\n      attrs: {\n        begin: [b, 0],\n        size: [1, innerDim]\n      }\n    });\n    const input = complex({\n      inputs: {\n        real: r,\n        imag: i\n      },\n      backend: cpuBackend\n    }); // Run FFT by batch element.\n\n    const {\n      real,\n      imag\n    } = fftImpl(input, inverse, cpuBackend);\n    const res = backend_util.mergeRealAndImagArrays(real, imag);\n\n    for (let d = 0; d < innerDim; d++) {\n      const c = backend_util.getComplexWithIndex(res, d);\n      resultReal[b * innerDim + d] = c.real;\n      resultImag[b * innerDim + d] = c.imag;\n    }\n\n    cpuBackend.disposeIntermediateTensorInfo(r);\n    cpuBackend.disposeIntermediateTensorInfo(i);\n    cpuBackend.disposeIntermediateTensorInfo(input);\n  }\n\n  const $realInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', resultReal);\n  const $imagInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', resultImag);\n  const result = complex({\n    inputs: {\n      real: $realInfo,\n      imag: $imagInfo\n    },\n    backend: cpuBackend\n  });\n  cpuBackend.disposeIntermediateTensorInfo($realInfo);\n  cpuBackend.disposeIntermediateTensorInfo($imagInfo);\n  return result;\n}\nexport function fftImpl(input, inverse, cpuBackend) {\n  const inputSize = util.sizeFromShape(input.shape);\n  const inputVals = cpuBackend.data.get(input.dataId);\n  const realVals = cpuBackend.data.get(inputVals.complexTensorInfos.real.dataId).values;\n  const imagVals = cpuBackend.data.get(inputVals.complexTensorInfos.imag.dataId).values;\n\n  if (isExponentOf2(inputSize)) {\n    const result = fftRadix2(realVals, imagVals, inputSize, inverse, cpuBackend);\n    const resultShape = [input.shape[0], input.shape[1]];\n\n    if (inverse) {\n      const realInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', result.real);\n      const imagInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', result.imag);\n      const sizeInfo = cpuBackend.makeTensorInfo([], 'float32', util.createScalarValue(inputSize, 'float32'));\n      const sizeInfoCopy = identity({\n        inputs: {\n          x: sizeInfo\n        },\n        backend: cpuBackend\n      });\n      const divRealInfo = realDivConfig.kernelFunc({\n        inputs: {\n          a: realInfo,\n          b: sizeInfo\n        },\n        backend: cpuBackend\n      });\n      const divImagInfo = realDivConfig.kernelFunc({\n        inputs: {\n          a: imagInfo,\n          b: sizeInfoCopy\n        },\n        backend: cpuBackend\n      });\n      const divRealVals = cpuBackend.data.get(divRealInfo.dataId).values;\n      const divImagVals = cpuBackend.data.get(divImagInfo.dataId).values;\n      cpuBackend.disposeIntermediateTensorInfo(realInfo);\n      cpuBackend.disposeIntermediateTensorInfo(imagInfo);\n      cpuBackend.disposeIntermediateTensorInfo(sizeInfo);\n      cpuBackend.disposeIntermediateTensorInfo(sizeInfoCopy);\n      cpuBackend.disposeIntermediateTensorInfo(divRealInfo);\n      cpuBackend.disposeIntermediateTensorInfo(divImagInfo);\n      return {\n        real: divRealVals,\n        imag: divImagVals\n      };\n    }\n\n    return result;\n  } else {\n    const data = backend_util.mergeRealAndImagArrays(realVals, imagVals);\n    const rawOutput = fourierTransformByMatmul(data, inputSize, inverse);\n    return backend_util.splitRealAndImagArrays(rawOutput);\n  }\n}\n\nfunction isExponentOf2(size) {\n  return (size & size - 1) === 0;\n} // FFT using Cooley-Tukey algorithm on radix 2 dimensional input.\n\n\nfunction fftRadix2(realVals, imagVals, size, inverse, cpuBackend) {\n  if (size === 1) {\n    return {\n      real: realVals,\n      imag: imagVals\n    };\n  }\n\n  const data = backend_util.mergeRealAndImagArrays(realVals, imagVals);\n  const half = size / 2;\n  const evenComplex = backend_util.complexWithEvenIndex(data);\n  const evenRealVals = evenComplex.real;\n  const evenImagVals = evenComplex.imag;\n  const evenShape = [evenRealVals.length];\n  const evenRealInfo = cpuBackend.makeTensorInfo(evenShape, 'float32', evenRealVals);\n  const evenImagInfo = cpuBackend.makeTensorInfo(evenShape, 'float32', evenImagVals);\n  const evenTensorInfo = complex({\n    inputs: {\n      real: evenRealInfo,\n      imag: evenImagInfo\n    },\n    backend: cpuBackend\n  });\n  const oddComplex = backend_util.complexWithOddIndex(data);\n  const oddRealVals = oddComplex.real;\n  const oddImagVals = oddComplex.imag;\n  const oddShape = [oddRealVals.length];\n  const oddRealInfo = cpuBackend.makeTensorInfo(oddShape, 'float32', oddRealVals);\n  const oddImagInfo = cpuBackend.makeTensorInfo(oddShape, 'float32', oddImagVals);\n  const oddTensorInfo = complex({\n    inputs: {\n      real: oddRealInfo,\n      imag: oddImagInfo\n    },\n    backend: cpuBackend\n  }); // Recursive call for half part of original input.\n\n  const $evenComplex = fftRadix2(evenRealVals, evenImagVals, half, inverse, cpuBackend);\n  const $evenRealVals = $evenComplex.real;\n  const $evenImagVals = $evenComplex.imag;\n  const $evenShape = [$evenRealVals.length];\n  const $evenRealInfo = cpuBackend.makeTensorInfo($evenShape, 'float32', $evenRealVals);\n  const $evenImagInfo = cpuBackend.makeTensorInfo($evenShape, 'float32', $evenImagVals);\n  const $evenTensorInfo = complex({\n    inputs: {\n      real: $evenRealInfo,\n      imag: $evenImagInfo\n    },\n    backend: cpuBackend\n  });\n  const $oddComplex = fftRadix2(oddRealVals, oddImagVals, half, inverse, cpuBackend);\n  const $oddRealVals = $oddComplex.real;\n  const $oddImagVals = $oddComplex.imag;\n  const $oddShape = [$oddRealVals.length];\n  const $oddRealInfo = cpuBackend.makeTensorInfo($oddShape, 'float32', $oddRealVals);\n  const $oddImagInfo = cpuBackend.makeTensorInfo($oddShape, 'float32', $oddImagVals);\n  const $oddTensorInfo = complex({\n    inputs: {\n      real: $oddRealInfo,\n      imag: $oddImagInfo\n    },\n    backend: cpuBackend\n  });\n  const e = backend_util.exponents(size, inverse);\n  const eShape = [e.real.length];\n  const eRealInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.real);\n  const eImagInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.imag);\n  const complexInfo = complex({\n    inputs: {\n      real: eRealInfo,\n      imag: eImagInfo\n    },\n    backend: cpuBackend\n  });\n  const exponentInfo = multiply({\n    inputs: {\n      a: complexInfo,\n      b: $oddTensorInfo\n    },\n    backend: cpuBackend\n  });\n  const addPart = add({\n    inputs: {\n      a: $evenTensorInfo,\n      b: exponentInfo\n    },\n    backend: cpuBackend\n  });\n  const subPart = sub({\n    inputs: {\n      a: $evenTensorInfo,\n      b: exponentInfo\n    },\n    backend: cpuBackend\n  });\n  const addPartReal = real({\n    inputs: {\n      input: addPart\n    },\n    backend: cpuBackend\n  });\n  const subPartReal = real({\n    inputs: {\n      input: subPart\n    },\n    backend: cpuBackend\n  });\n  const addPartImag = imag({\n    inputs: {\n      input: addPart\n    },\n    backend: cpuBackend\n  });\n  const subPartImag = imag({\n    inputs: {\n      input: subPart\n    },\n    backend: cpuBackend\n  });\n  const $real = concat({\n    inputs: [addPartReal, subPartReal],\n    backend: cpuBackend,\n    attrs: {\n      axis: 0\n    }\n  });\n  const $imag = concat({\n    inputs: [addPartImag, subPartImag],\n    backend: cpuBackend,\n    attrs: {\n      axis: 0\n    }\n  });\n  const $realVals = cpuBackend.data.get($real.dataId).values;\n  const $imagVals = cpuBackend.data.get($imag.dataId).values;\n  cpuBackend.disposeIntermediateTensorInfo(evenRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo(evenImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo(evenTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo(oddRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo(oddImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo(oddTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo($evenRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo($evenImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo($evenTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo($oddRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo($oddImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo($oddTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo(eRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo(eImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo(complexInfo);\n  cpuBackend.disposeIntermediateTensorInfo(exponentInfo);\n  cpuBackend.disposeIntermediateTensorInfo(addPart);\n  cpuBackend.disposeIntermediateTensorInfo(subPart);\n  cpuBackend.disposeIntermediateTensorInfo(addPartReal);\n  cpuBackend.disposeIntermediateTensorInfo(addPartImag);\n  cpuBackend.disposeIntermediateTensorInfo(subPartReal);\n  cpuBackend.disposeIntermediateTensorInfo(subPartImag);\n  cpuBackend.disposeIntermediateTensorInfo($real);\n  cpuBackend.disposeIntermediateTensorInfo($imag);\n  return {\n    real: $realVals,\n    imag: $imagVals\n  };\n} // Calculate fourier transform by multplying sinusoid matrix.\n\n\nfunction fourierTransformByMatmul(data, size, inverse) {\n  const ret = new Float32Array(size * 2); // TODO: Use matmul instead once it supports complex64 type.\n\n  for (let r = 0; r < size; r++) {\n    let real = 0.0;\n    let imag = 0.0;\n\n    for (let c = 0; c < size; c++) {\n      const e = backend_util.exponent(r * c, size, inverse);\n      const term = backend_util.getComplexWithIndex(data, c);\n      real += term.real * e.real - term.imag * e.imag;\n      imag += term.real * e.imag + term.imag * e.real;\n    }\n\n    if (inverse) {\n      real /= size;\n      imag /= size;\n    }\n\n    backend_util.assignToTypedArray(ret, real, imag, r);\n  }\n\n  return ret;\n}","map":{"version":3,"names":["backend_util","util","add","complex","concat","identity","imag","multiply","real","realDivConfig","slice","sub","fftBatch","input","inverse","cpuBackend","inputShape","shape","batch","innerDim","inputVals","data","get","dataId","real2D","complexTensorInfos","imag2D","resultShape","resultSize","sizeFromShape","resultReal","getTypedArrayFromDType","resultImag","b","r","inputs","x","backend","attrs","begin","size","i","fftImpl","res","mergeRealAndImagArrays","d","c","getComplexWithIndex","disposeIntermediateTensorInfo","$realInfo","makeTensorInfo","$imagInfo","result","inputSize","realVals","values","imagVals","isExponentOf2","fftRadix2","realInfo","imagInfo","sizeInfo","createScalarValue","sizeInfoCopy","divRealInfo","kernelFunc","a","divImagInfo","divRealVals","divImagVals","rawOutput","fourierTransformByMatmul","splitRealAndImagArrays","half","evenComplex","complexWithEvenIndex","evenRealVals","evenImagVals","evenShape","length","evenRealInfo","evenImagInfo","evenTensorInfo","oddComplex","complexWithOddIndex","oddRealVals","oddImagVals","oddShape","oddRealInfo","oddImagInfo","oddTensorInfo","$evenComplex","$evenRealVals","$evenImagVals","$evenShape","$evenRealInfo","$evenImagInfo","$evenTensorInfo","$oddComplex","$oddRealVals","$oddImagVals","$oddShape","$oddRealInfo","$oddImagInfo","$oddTensorInfo","e","exponents","eShape","eRealInfo","eImagInfo","complexInfo","exponentInfo","addPart","subPart","addPartReal","subPartReal","addPartImag","subPartImag","$real","axis","$imag","$realVals","$imagVals","ret","Float32Array","exponent","term","assignToTypedArray"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/fft_utils.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nimport { add } from '../kernels/Add';\nimport { complex } from '../kernels/Complex';\nimport { concat } from '../kernels/Concat';\nimport { identity } from '../kernels/Identity';\nimport { imag } from '../kernels/Imag';\nimport { multiply } from '../kernels/Multiply';\nimport { real } from '../kernels/Real';\nimport { realDivConfig } from '../kernels/RealDiv';\nimport { slice } from '../kernels/Slice';\nimport { sub } from '../kernels/Sub';\n/**\n * Calculate FFT of inner most elements of batch tensor.\n */\nexport function fftBatch(input, inverse, cpuBackend) {\n    const inputShape = input.shape;\n    const batch = inputShape[0];\n    const innerDim = inputShape[1];\n    const inputVals = cpuBackend.data.get(input.dataId);\n    const real2D = inputVals.complexTensorInfos.real;\n    const imag2D = inputVals.complexTensorInfos.imag;\n    // Collects real and imaginary values separately.\n    const resultShape = [batch, innerDim];\n    const resultSize = util.sizeFromShape(resultShape);\n    const resultReal = util.getTypedArrayFromDType('float32', resultSize);\n    const resultImag = util.getTypedArrayFromDType('float32', resultSize);\n    for (let b = 0; b < batch; b++) {\n        // TODO: Support slice ops for complex type.\n        const r = slice({\n            inputs: { x: real2D },\n            backend: cpuBackend,\n            attrs: { begin: [b, 0], size: [1, innerDim] }\n        });\n        const i = slice({\n            inputs: { x: imag2D },\n            backend: cpuBackend,\n            attrs: { begin: [b, 0], size: [1, innerDim] }\n        });\n        const input = complex({ inputs: { real: r, imag: i }, backend: cpuBackend });\n        // Run FFT by batch element.\n        const { real, imag } = fftImpl(input, inverse, cpuBackend);\n        const res = backend_util.mergeRealAndImagArrays(real, imag);\n        for (let d = 0; d < innerDim; d++) {\n            const c = backend_util.getComplexWithIndex(res, d);\n            resultReal[b * innerDim + d] = c.real;\n            resultImag[b * innerDim + d] = c.imag;\n        }\n        cpuBackend.disposeIntermediateTensorInfo(r);\n        cpuBackend.disposeIntermediateTensorInfo(i);\n        cpuBackend.disposeIntermediateTensorInfo(input);\n    }\n    const $realInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', resultReal);\n    const $imagInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', resultImag);\n    const result = complex({ inputs: { real: $realInfo, imag: $imagInfo }, backend: cpuBackend });\n    cpuBackend.disposeIntermediateTensorInfo($realInfo);\n    cpuBackend.disposeIntermediateTensorInfo($imagInfo);\n    return result;\n}\nexport function fftImpl(input, inverse, cpuBackend) {\n    const inputSize = util.sizeFromShape(input.shape);\n    const inputVals = cpuBackend.data.get(input.dataId);\n    const realVals = cpuBackend.data.get(inputVals.complexTensorInfos.real.dataId).values;\n    const imagVals = cpuBackend.data.get(inputVals.complexTensorInfos.imag.dataId).values;\n    if (isExponentOf2(inputSize)) {\n        const result = fftRadix2(realVals, imagVals, inputSize, inverse, cpuBackend);\n        const resultShape = [input.shape[0], input.shape[1]];\n        if (inverse) {\n            const realInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', result.real);\n            const imagInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', result.imag);\n            const sizeInfo = cpuBackend.makeTensorInfo([], 'float32', util.createScalarValue(inputSize, 'float32'));\n            const sizeInfoCopy = identity({ inputs: { x: sizeInfo }, backend: cpuBackend });\n            const divRealInfo = realDivConfig.kernelFunc({ inputs: { a: realInfo, b: sizeInfo }, backend: cpuBackend });\n            const divImagInfo = realDivConfig.kernelFunc({ inputs: { a: imagInfo, b: sizeInfoCopy }, backend: cpuBackend });\n            const divRealVals = cpuBackend.data.get(divRealInfo.dataId).values;\n            const divImagVals = cpuBackend.data.get(divImagInfo.dataId).values;\n            cpuBackend.disposeIntermediateTensorInfo(realInfo);\n            cpuBackend.disposeIntermediateTensorInfo(imagInfo);\n            cpuBackend.disposeIntermediateTensorInfo(sizeInfo);\n            cpuBackend.disposeIntermediateTensorInfo(sizeInfoCopy);\n            cpuBackend.disposeIntermediateTensorInfo(divRealInfo);\n            cpuBackend.disposeIntermediateTensorInfo(divImagInfo);\n            return { real: divRealVals, imag: divImagVals };\n        }\n        return result;\n    }\n    else {\n        const data = backend_util.mergeRealAndImagArrays(realVals, imagVals);\n        const rawOutput = fourierTransformByMatmul(data, inputSize, inverse);\n        return backend_util.splitRealAndImagArrays(rawOutput);\n    }\n}\nfunction isExponentOf2(size) {\n    return (size & size - 1) === 0;\n}\n// FFT using Cooley-Tukey algorithm on radix 2 dimensional input.\nfunction fftRadix2(realVals, imagVals, size, inverse, cpuBackend) {\n    if (size === 1) {\n        return { real: realVals, imag: imagVals };\n    }\n    const data = backend_util.mergeRealAndImagArrays(realVals, imagVals);\n    const half = size / 2;\n    const evenComplex = backend_util.complexWithEvenIndex(data);\n    const evenRealVals = evenComplex.real;\n    const evenImagVals = evenComplex.imag;\n    const evenShape = [evenRealVals.length];\n    const evenRealInfo = cpuBackend.makeTensorInfo(evenShape, 'float32', evenRealVals);\n    const evenImagInfo = cpuBackend.makeTensorInfo(evenShape, 'float32', evenImagVals);\n    const evenTensorInfo = complex({ inputs: { real: evenRealInfo, imag: evenImagInfo }, backend: cpuBackend });\n    const oddComplex = backend_util.complexWithOddIndex(data);\n    const oddRealVals = oddComplex.real;\n    const oddImagVals = oddComplex.imag;\n    const oddShape = [oddRealVals.length];\n    const oddRealInfo = cpuBackend.makeTensorInfo(oddShape, 'float32', oddRealVals);\n    const oddImagInfo = cpuBackend.makeTensorInfo(oddShape, 'float32', oddImagVals);\n    const oddTensorInfo = complex({ inputs: { real: oddRealInfo, imag: oddImagInfo }, backend: cpuBackend });\n    // Recursive call for half part of original input.\n    const $evenComplex = fftRadix2(evenRealVals, evenImagVals, half, inverse, cpuBackend);\n    const $evenRealVals = $evenComplex.real;\n    const $evenImagVals = $evenComplex.imag;\n    const $evenShape = [$evenRealVals.length];\n    const $evenRealInfo = cpuBackend.makeTensorInfo($evenShape, 'float32', $evenRealVals);\n    const $evenImagInfo = cpuBackend.makeTensorInfo($evenShape, 'float32', $evenImagVals);\n    const $evenTensorInfo = complex({\n        inputs: { real: $evenRealInfo, imag: $evenImagInfo },\n        backend: cpuBackend\n    });\n    const $oddComplex = fftRadix2(oddRealVals, oddImagVals, half, inverse, cpuBackend);\n    const $oddRealVals = $oddComplex.real;\n    const $oddImagVals = $oddComplex.imag;\n    const $oddShape = [$oddRealVals.length];\n    const $oddRealInfo = cpuBackend.makeTensorInfo($oddShape, 'float32', $oddRealVals);\n    const $oddImagInfo = cpuBackend.makeTensorInfo($oddShape, 'float32', $oddImagVals);\n    const $oddTensorInfo = complex({ inputs: { real: $oddRealInfo, imag: $oddImagInfo }, backend: cpuBackend });\n    const e = backend_util.exponents(size, inverse);\n    const eShape = [e.real.length];\n    const eRealInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.real);\n    const eImagInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.imag);\n    const complexInfo = complex({ inputs: { real: eRealInfo, imag: eImagInfo }, backend: cpuBackend });\n    const exponentInfo = multiply({ inputs: { a: complexInfo, b: $oddTensorInfo }, backend: cpuBackend });\n    const addPart = add({\n        inputs: { a: $evenTensorInfo, b: exponentInfo },\n        backend: cpuBackend\n    });\n    const subPart = sub({\n        inputs: { a: $evenTensorInfo, b: exponentInfo },\n        backend: cpuBackend\n    });\n    const addPartReal = real({ inputs: { input: addPart }, backend: cpuBackend });\n    const subPartReal = real({ inputs: { input: subPart }, backend: cpuBackend });\n    const addPartImag = imag({ inputs: { input: addPart }, backend: cpuBackend });\n    const subPartImag = imag({ inputs: { input: subPart }, backend: cpuBackend });\n    const $real = concat({\n        inputs: [addPartReal, subPartReal],\n        backend: cpuBackend,\n        attrs: { axis: 0 }\n    });\n    const $imag = concat({\n        inputs: [addPartImag, subPartImag],\n        backend: cpuBackend,\n        attrs: { axis: 0 }\n    });\n    const $realVals = cpuBackend.data.get($real.dataId).values;\n    const $imagVals = cpuBackend.data.get($imag.dataId).values;\n    cpuBackend.disposeIntermediateTensorInfo(evenRealInfo);\n    cpuBackend.disposeIntermediateTensorInfo(evenImagInfo);\n    cpuBackend.disposeIntermediateTensorInfo(evenTensorInfo);\n    cpuBackend.disposeIntermediateTensorInfo(oddRealInfo);\n    cpuBackend.disposeIntermediateTensorInfo(oddImagInfo);\n    cpuBackend.disposeIntermediateTensorInfo(oddTensorInfo);\n    cpuBackend.disposeIntermediateTensorInfo($evenRealInfo);\n    cpuBackend.disposeIntermediateTensorInfo($evenImagInfo);\n    cpuBackend.disposeIntermediateTensorInfo($evenTensorInfo);\n    cpuBackend.disposeIntermediateTensorInfo($oddRealInfo);\n    cpuBackend.disposeIntermediateTensorInfo($oddImagInfo);\n    cpuBackend.disposeIntermediateTensorInfo($oddTensorInfo);\n    cpuBackend.disposeIntermediateTensorInfo(eRealInfo);\n    cpuBackend.disposeIntermediateTensorInfo(eImagInfo);\n    cpuBackend.disposeIntermediateTensorInfo(complexInfo);\n    cpuBackend.disposeIntermediateTensorInfo(exponentInfo);\n    cpuBackend.disposeIntermediateTensorInfo(addPart);\n    cpuBackend.disposeIntermediateTensorInfo(subPart);\n    cpuBackend.disposeIntermediateTensorInfo(addPartReal);\n    cpuBackend.disposeIntermediateTensorInfo(addPartImag);\n    cpuBackend.disposeIntermediateTensorInfo(subPartReal);\n    cpuBackend.disposeIntermediateTensorInfo(subPartImag);\n    cpuBackend.disposeIntermediateTensorInfo($real);\n    cpuBackend.disposeIntermediateTensorInfo($imag);\n    return { real: $realVals, imag: $imagVals };\n}\n// Calculate fourier transform by multplying sinusoid matrix.\nfunction fourierTransformByMatmul(data, size, inverse) {\n    const ret = new Float32Array(size * 2);\n    // TODO: Use matmul instead once it supports complex64 type.\n    for (let r = 0; r < size; r++) {\n        let real = 0.0;\n        let imag = 0.0;\n        for (let c = 0; c < size; c++) {\n            const e = backend_util.exponent(r * c, size, inverse);\n            const term = backend_util.getComplexWithIndex(data, c);\n            real += term.real * e.real - term.imag * e.imag;\n            imag += term.real * e.imag + term.imag * e.real;\n        }\n        if (inverse) {\n            real /= size;\n            imag /= size;\n        }\n        backend_util.assignToTypedArray(ret, real, imag, r);\n    }\n    return ret;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}