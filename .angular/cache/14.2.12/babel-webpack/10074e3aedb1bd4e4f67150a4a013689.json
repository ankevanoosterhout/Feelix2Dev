{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\nvar _deepMapAndAwaitAll;\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\n/**\n * Apply a mapping function to a nested structure in a recursive manner.\n *\n * The result of the mapping is an object with the same nested structure (i.e.,\n * of arrays and dicts) as the input, except that some subtrees are replaced,\n * according to the results of the mapping function.\n *\n * Mappings are memoized.  Thus, if the nested structure contains the same\n * object in multiple positions, the output will contain the same mapped object\n * in those positions.  Cycles are not supported, however.\n *\n * @param input: The object to which to apply the mapping function.\n * @param mapFn: A function that expects a single node of the object tree, and\n *   returns a `DeepMapResult`.  The `DeepMapResult` either provides a\n *   replacement value for that node (i.e., replacing the subtree), or indicates\n *   that the node should be processed recursively.\n */\n\nexport function deepMap(input, mapFn) {\n  return deepMapInternal(input, mapFn);\n}\n/**\n * @param seen: A Map of known object mappings (i.e., memoized results of\n *   `mapFn()`)\n * @param containedIn: An set containing objects on the reference path currently\n *   being processed (used to detect cycles).\n */\n\nfunction deepMapInternal(input, mapFn, seen = new Map(), containedIn = new Set()) {\n  if (input == null) {\n    return null;\n  }\n\n  if (typeof Blob === 'function' && input instanceof Blob) {\n    return input.slice();\n  }\n\n  if (containedIn.has(input)) {\n    throw new Error('Circular references are not supported.');\n  }\n\n  if (seen.has(input)) {\n    return seen.get(input);\n  }\n\n  const result = mapFn(input);\n\n  if (result.recurse && result.value !== null) {\n    throw new Error('A deep map function may not return both a value and recurse=true.');\n  }\n\n  if (!result.recurse) {\n    seen.set(input, result.value);\n    return result.value;\n  } else if (isIterable(input)) {\n    // tslint:disable-next-line:no-any\n    const mappedIterable = Array.isArray(input) ? [] : {};\n    containedIn.add(input);\n\n    for (const k in input) {\n      const child = input[k];\n      const childResult = deepMapInternal(child, mapFn, seen, containedIn);\n      mappedIterable[k] = childResult;\n    }\n\n    containedIn.delete(input);\n\n    if (input.__proto__) {\n      mappedIterable.__proto__ = input.__proto__;\n    }\n\n    return mappedIterable;\n  } else {\n    throw new Error(`Can't recurse into non-iterable type: ${input}`);\n  }\n} // TODO(soergel, kangyizhang) Reconsider naming of deepZip() to avoid confusion\n// with zip()\n\n/**\n * Zip nested structures together in a recursive manner.\n *\n * This has the effect of transposing or pivoting data, e.g. converting it from\n * a row-major representation to a column-major representation.\n *\n * For example, `deepZip([{a: 1, b: 2}, {a: 3, b: 4}])` returns\n * `{a: [1, 3], b: [2, 4]}`.\n *\n * The inputs should all have the same nested structure (i.e., of arrays and\n * dicts).  The result is a single object with the same nested structure, where\n * the leaves are arrays collecting the values of the inputs at that location\n * (or, optionally, the result of a custom function applied to those arrays).\n *\n * @param inputs: An array of the objects to zip together.\n * @param zipFn: (optional) A function that expects an array of elements at a\n *   single node of the object tree, and returns a `DeepMapResult`.  The\n *   `DeepMapResult` either provides a result value for that node (i.e.,\n *   representing the subtree), or indicates that the node should be processed\n *   recursively.  The default zipFn recurses as far as possible and places\n *   arrays at the leaves.\n */\n\n\nexport function deepZip(inputs, zipFn = zipToList) {\n  return deepZipInternal(inputs, zipFn);\n}\n/**\n * @param containedIn: An set containing objects on the reference path currently\n *   being processed (used to detect cycles).\n */\n\nfunction deepZipInternal(inputs, zipFn, containedIn = new Set()) {\n  // The recursion follows the structure of input 0; it's assumed that all the\n  // other inputs have the same structure.\n  const input = inputs[0];\n\n  if (containedIn.has(input)) {\n    throw new Error('Circular references are not supported.');\n  }\n\n  const result = zipFn(inputs);\n\n  if (result.recurse && result.value !== null) {\n    throw new Error('A deep zip function may not return both a value and recurse=true.');\n  }\n\n  if (!result.recurse) {\n    return result.value;\n  } else if (isIterable(input)) {\n    // tslint:disable-next-line:no-any\n    const mappedIterable = Array.isArray(input) ? [] : {};\n    containedIn.add(input);\n\n    for (const k in input) {\n      const children = inputs.map(x => x[k]);\n      const childResult = deepZipInternal(children, zipFn, containedIn);\n      mappedIterable[k] = childResult;\n    }\n\n    containedIn.delete(input);\n    return mappedIterable;\n  } else {\n    throw new Error(`Can't recurse into non-iterable type: ${input}`);\n  }\n} // tslint:disable-next-line:no-any\n\n\nexport function zipToList(x) {\n  if (x === null) {\n    return null;\n  } // TODO(soergel): validate array type?\n\n\n  if (isIterable(x[0])) {\n    return {\n      value: null,\n      recurse: true\n    };\n  } else {\n    return {\n      value: x,\n      recurse: false\n    };\n  }\n}\n/**\n * Apply an async mapping function to a nested structure in a recursive manner.\n *\n * This first creates a nested structure of Promises, and then awaits all of\n * those, resulting in a single Promise for a resolved nested structure.\n *\n * The result of the mapping is an object with the same nested structure (i.e.,\n * of arrays and dicts) as the input, except that some subtrees are replaced,\n * according to the results of the mapping function.\n *\n * Mappings are memoized.  Thus, if the nested structure contains the same\n * object in multiple positions, the output will contain the same mapped object\n * in those positions.  Cycles are not supported, however.\n *\n * @param input: The object to which to apply the mapping function.\n * @param mapFn: A function that expects a single node of the object tree, and\n *   returns a `DeepMapAsyncResult`.  The `DeepMapAsyncResult` either provides\n *   a `Promise` for a replacement value for that node (i.e., replacing the\n *   subtree), or indicates that the node should be processed recursively.  Note\n *   that the decision whether or not to recurse must be made immediately; only\n *   the mapped value may be promised.\n */\n\nexport function deepMapAndAwaitAll(_x, _x2) {\n  return (_deepMapAndAwaitAll = _deepMapAndAwaitAll || _asyncToGenerator(function* (input, mapFn) {\n    const seen = new Map(); // First do a normal deepMap, collecting Promises in 'seen' as a side effect.\n\n    deepMapInternal(input, mapFn, seen); // Replace the Promises in 'seen' in place.\n    // Note TypeScript provides no async map iteration, and regular map iteration\n    // is broken too, so sadly we have to do Array.from() to make it work.\n    // (There's no advantage to Promise.all(), and that would be tricky anyway.)\n\n    for (const key of Array.from(seen.keys())) {\n      const value = seen.get(key);\n\n      if (tf.util.isPromise(value)) {\n        const mappedValue = yield value;\n        seen.set(key, mappedValue);\n      }\n    } // Normal deepMap again, this time filling in the resolved values.\n    // It's unfortunate that we have to do two passes.\n    // TODO(soergel): test performance and think harder about a fast solution.\n\n\n    const result = deepMapInternal(input, mapFn, seen);\n    return result;\n  })).apply(this, arguments);\n}\n/**\n * Determine whether the argument is iterable.\n *\n * @returns true if the argument is an array or any non-Tensor object.\n */\n// tslint:disable-next-line:no-any\n\nexport function isIterable(obj) {\n  let isTextDecoder = false;\n\n  if (tf.env().get('IS_BROWSER')) {\n    isTextDecoder = obj instanceof TextDecoder;\n  } else {\n    // tslint:disable-next-line:no-require-imports\n    const {\n      StringDecoder\n    } = require('string_decoder');\n\n    isTextDecoder = obj instanceof StringDecoder;\n  }\n\n  return obj != null && !ArrayBuffer.isView(obj) && (Array.isArray(obj) || typeof obj === 'object' && !(obj instanceof tf.Tensor) && !(obj instanceof Promise) && !isTextDecoder);\n}\n/**\n * Determine whether the argument can be converted to Tensor.\n *\n * Tensors, primitives, arrays, and TypedArrays all qualify; anything else does\n * not.\n *\n * @returns true if the argument can be converted to Tensor.\n */\n// tslint:disable-next-line:no-any\n\nexport function canTensorify(obj) {\n  return obj == null || isPrimitive(obj) || Array.isArray(obj) || typeof obj === 'object' && obj instanceof tf.Tensor || tf.util.isTypedArray(obj);\n}\n/**\n * Returns true if the given `value` is a primitive type. Otherwise returns\n * false. This is equivalant to node util.isPrimitive\n */\n\nfunction isPrimitive(value) {\n  return value === null || typeof value !== 'object' && typeof value !== 'function';\n}","map":{"version":3,"names":["tf","deepMap","input","mapFn","deepMapInternal","seen","Map","containedIn","Set","Blob","slice","has","Error","get","result","recurse","value","set","isIterable","mappedIterable","Array","isArray","add","k","child","childResult","delete","__proto__","deepZip","inputs","zipFn","zipToList","deepZipInternal","children","map","x","deepMapAndAwaitAll","key","from","keys","util","isPromise","mappedValue","obj","isTextDecoder","env","TextDecoder","StringDecoder","require","ArrayBuffer","isView","Tensor","Promise","canTensorify","isPrimitive","isTypedArray"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-data/dist/util/deep_map.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\n/**\n * Apply a mapping function to a nested structure in a recursive manner.\n *\n * The result of the mapping is an object with the same nested structure (i.e.,\n * of arrays and dicts) as the input, except that some subtrees are replaced,\n * according to the results of the mapping function.\n *\n * Mappings are memoized.  Thus, if the nested structure contains the same\n * object in multiple positions, the output will contain the same mapped object\n * in those positions.  Cycles are not supported, however.\n *\n * @param input: The object to which to apply the mapping function.\n * @param mapFn: A function that expects a single node of the object tree, and\n *   returns a `DeepMapResult`.  The `DeepMapResult` either provides a\n *   replacement value for that node (i.e., replacing the subtree), or indicates\n *   that the node should be processed recursively.\n */\nexport function deepMap(input, mapFn) {\n    return deepMapInternal(input, mapFn);\n}\n/**\n * @param seen: A Map of known object mappings (i.e., memoized results of\n *   `mapFn()`)\n * @param containedIn: An set containing objects on the reference path currently\n *   being processed (used to detect cycles).\n */\nfunction deepMapInternal(input, mapFn, seen = new Map(), containedIn = new Set()) {\n    if (input == null) {\n        return null;\n    }\n    if (typeof Blob === 'function' && input instanceof Blob) {\n        return input.slice();\n    }\n    if (containedIn.has(input)) {\n        throw new Error('Circular references are not supported.');\n    }\n    if (seen.has(input)) {\n        return seen.get(input);\n    }\n    const result = mapFn(input);\n    if (result.recurse && result.value !== null) {\n        throw new Error('A deep map function may not return both a value and recurse=true.');\n    }\n    if (!result.recurse) {\n        seen.set(input, result.value);\n        return result.value;\n    }\n    else if (isIterable(input)) {\n        // tslint:disable-next-line:no-any\n        const mappedIterable = Array.isArray(input) ? [] : {};\n        containedIn.add(input);\n        for (const k in input) {\n            const child = input[k];\n            const childResult = deepMapInternal(child, mapFn, seen, containedIn);\n            mappedIterable[k] = childResult;\n        }\n        containedIn.delete(input);\n        if (input.__proto__) {\n            mappedIterable.__proto__ = input.__proto__;\n        }\n        return mappedIterable;\n    }\n    else {\n        throw new Error(`Can't recurse into non-iterable type: ${input}`);\n    }\n}\n// TODO(soergel, kangyizhang) Reconsider naming of deepZip() to avoid confusion\n// with zip()\n/**\n * Zip nested structures together in a recursive manner.\n *\n * This has the effect of transposing or pivoting data, e.g. converting it from\n * a row-major representation to a column-major representation.\n *\n * For example, `deepZip([{a: 1, b: 2}, {a: 3, b: 4}])` returns\n * `{a: [1, 3], b: [2, 4]}`.\n *\n * The inputs should all have the same nested structure (i.e., of arrays and\n * dicts).  The result is a single object with the same nested structure, where\n * the leaves are arrays collecting the values of the inputs at that location\n * (or, optionally, the result of a custom function applied to those arrays).\n *\n * @param inputs: An array of the objects to zip together.\n * @param zipFn: (optional) A function that expects an array of elements at a\n *   single node of the object tree, and returns a `DeepMapResult`.  The\n *   `DeepMapResult` either provides a result value for that node (i.e.,\n *   representing the subtree), or indicates that the node should be processed\n *   recursively.  The default zipFn recurses as far as possible and places\n *   arrays at the leaves.\n */\nexport function deepZip(inputs, zipFn = zipToList) {\n    return deepZipInternal(inputs, zipFn);\n}\n/**\n * @param containedIn: An set containing objects on the reference path currently\n *   being processed (used to detect cycles).\n */\nfunction deepZipInternal(inputs, zipFn, containedIn = new Set()) {\n    // The recursion follows the structure of input 0; it's assumed that all the\n    // other inputs have the same structure.\n    const input = inputs[0];\n    if (containedIn.has(input)) {\n        throw new Error('Circular references are not supported.');\n    }\n    const result = zipFn(inputs);\n    if (result.recurse && result.value !== null) {\n        throw new Error('A deep zip function may not return both a value and recurse=true.');\n    }\n    if (!result.recurse) {\n        return result.value;\n    }\n    else if (isIterable(input)) {\n        // tslint:disable-next-line:no-any\n        const mappedIterable = Array.isArray(input) ? [] : {};\n        containedIn.add(input);\n        for (const k in input) {\n            const children = inputs.map(x => x[k]);\n            const childResult = deepZipInternal(children, zipFn, containedIn);\n            mappedIterable[k] = childResult;\n        }\n        containedIn.delete(input);\n        return mappedIterable;\n    }\n    else {\n        throw new Error(`Can't recurse into non-iterable type: ${input}`);\n    }\n}\n// tslint:disable-next-line:no-any\nexport function zipToList(x) {\n    if (x === null) {\n        return null;\n    }\n    // TODO(soergel): validate array type?\n    if (isIterable(x[0])) {\n        return { value: null, recurse: true };\n    }\n    else {\n        return { value: x, recurse: false };\n    }\n}\n/**\n * Apply an async mapping function to a nested structure in a recursive manner.\n *\n * This first creates a nested structure of Promises, and then awaits all of\n * those, resulting in a single Promise for a resolved nested structure.\n *\n * The result of the mapping is an object with the same nested structure (i.e.,\n * of arrays and dicts) as the input, except that some subtrees are replaced,\n * according to the results of the mapping function.\n *\n * Mappings are memoized.  Thus, if the nested structure contains the same\n * object in multiple positions, the output will contain the same mapped object\n * in those positions.  Cycles are not supported, however.\n *\n * @param input: The object to which to apply the mapping function.\n * @param mapFn: A function that expects a single node of the object tree, and\n *   returns a `DeepMapAsyncResult`.  The `DeepMapAsyncResult` either provides\n *   a `Promise` for a replacement value for that node (i.e., replacing the\n *   subtree), or indicates that the node should be processed recursively.  Note\n *   that the decision whether or not to recurse must be made immediately; only\n *   the mapped value may be promised.\n */\nexport async function deepMapAndAwaitAll(input, mapFn) {\n    const seen = new Map();\n    // First do a normal deepMap, collecting Promises in 'seen' as a side effect.\n    deepMapInternal(input, mapFn, seen);\n    // Replace the Promises in 'seen' in place.\n    // Note TypeScript provides no async map iteration, and regular map iteration\n    // is broken too, so sadly we have to do Array.from() to make it work.\n    // (There's no advantage to Promise.all(), and that would be tricky anyway.)\n    for (const key of Array.from(seen.keys())) {\n        const value = seen.get(key);\n        if (tf.util.isPromise(value)) {\n            const mappedValue = await value;\n            seen.set(key, mappedValue);\n        }\n    }\n    // Normal deepMap again, this time filling in the resolved values.\n    // It's unfortunate that we have to do two passes.\n    // TODO(soergel): test performance and think harder about a fast solution.\n    const result = deepMapInternal(input, mapFn, seen);\n    return result;\n}\n/**\n * Determine whether the argument is iterable.\n *\n * @returns true if the argument is an array or any non-Tensor object.\n */\n// tslint:disable-next-line:no-any\nexport function isIterable(obj) {\n    let isTextDecoder = false;\n    if (tf.env().get('IS_BROWSER')) {\n        isTextDecoder = obj instanceof TextDecoder;\n    }\n    else {\n        // tslint:disable-next-line:no-require-imports\n        const { StringDecoder } = require('string_decoder');\n        isTextDecoder = obj instanceof StringDecoder;\n    }\n    return obj != null && (!ArrayBuffer.isView(obj)) &&\n        (Array.isArray(obj) ||\n            (typeof obj === 'object' && !(obj instanceof tf.Tensor) &&\n                !(obj instanceof Promise) && !isTextDecoder));\n}\n/**\n * Determine whether the argument can be converted to Tensor.\n *\n * Tensors, primitives, arrays, and TypedArrays all qualify; anything else does\n * not.\n *\n * @returns true if the argument can be converted to Tensor.\n */\n// tslint:disable-next-line:no-any\nexport function canTensorify(obj) {\n    return obj == null || isPrimitive(obj) || Array.isArray(obj) ||\n        (typeof obj === 'object' && (obj instanceof tf.Tensor)) ||\n        tf.util.isTypedArray(obj);\n}\n/**\n * Returns true if the given `value` is a primitive type. Otherwise returns\n * false. This is equivalant to node util.isPrimitive\n */\nfunction isPrimitive(value) {\n    return (value === null ||\n        (typeof value !== 'object' && typeof value !== 'function'));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}