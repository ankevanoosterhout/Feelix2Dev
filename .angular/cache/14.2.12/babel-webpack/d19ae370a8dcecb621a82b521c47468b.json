{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport * as generic_utils from '../utils/generic_utils'; // tslint:enable\n\n/**\n * Test whether a value in an array is the name of a LayersModel or Layer.\n * @param key The key name that the value is found under. Note that the key\n *   may not be at the level immediately above the value, if the value is in a\n *   nested array.\n * @param index Index of the value in the Array that it is found in.\n * @param value The value object.\n * @returns A boolean indicating whether value is a name.\n */\n\nfunction isArrayItemInputOrOutputName(key, index, value) {\n  return (key === 'inboundNodes' || key === 'outputLayers' || key === 'inputLayers') && index === 0 && typeof value === 'string';\n}\n/**\n * Convert a Pythonic config object to TypeScript config object.\n * @param pythonicConfig The config object to convert.\n * @param key Optional key name of the object being converted.\n * @returns Result of the conversion.\n */\n\n\nexport function convertPythonicToTs(pythonicConfig, key) {\n  if (pythonicConfig === null) {\n    return null;\n  } else if (typeof pythonicConfig === 'string') {\n    return generic_utils.toCamelCase(pythonicConfig);\n  } else if (typeof pythonicConfig === 'number' || typeof pythonicConfig === 'boolean') {\n    return pythonicConfig;\n  } else if (pythonicConfig instanceof Array) {\n    const tsArray = [];\n    const arrayLength = pythonicConfig.length;\n\n    for (let i = 0; i < arrayLength; ++i) {\n      const item = pythonicConfig[i];\n\n      if (isArrayItemInputOrOutputName(key, i, item)) {\n        tsArray.push(item);\n      } else {\n        tsArray.push(convertPythonicToTs(item, key));\n      }\n    }\n\n    return tsArray;\n  } else {\n    const tsDict = {};\n\n    for (const pythonicKey of Object.keys(pythonicConfig)) {\n      const pythonicValue = pythonicConfig[pythonicKey];\n\n      if (pythonicKey === 'name' && typeof pythonicValue === 'string') {\n        // Special case the 'name' key with a string value. Name values, such as\n        // the names of LayersModel and Layer instances, should not undergo the\n        // camel-case conversion.\n        tsDict[pythonicKey] = pythonicValue;\n      } else {\n        const tsKey = generic_utils.toCamelCase(pythonicKey);\n        tsDict[tsKey] = convertPythonicToTs(pythonicValue, tsKey);\n      }\n    }\n\n    return tsDict;\n  }\n}\n/**\n * Convert a TypeScript config object to Python config object.\n * @param tsConfig The config object to convert.\n * @param key Optional key name of the object being converted.\n * @returns Result of the conversion.\n */\n\nexport function convertTsToPythonic(tsConfig, key) {\n  if (tsConfig === null || tsConfig === undefined) {\n    return null;\n  } else if (typeof tsConfig === 'string') {\n    return generic_utils.toSnakeCase(tsConfig);\n  } else if (typeof tsConfig === 'number' || typeof tsConfig === 'boolean') {\n    return tsConfig;\n  } else if (tsConfig instanceof Array) {\n    const pyArray = [];\n    const arrayLength = tsConfig.length;\n\n    for (let i = 0; i < arrayLength; ++i) {\n      const item = tsConfig[i];\n\n      if (isArrayItemInputOrOutputName(key, i, item)) {\n        pyArray.push(item);\n      } else {\n        pyArray.push(convertTsToPythonic(item, key));\n      }\n    }\n\n    return pyArray;\n  } else {\n    const pyDict = {};\n\n    for (const tsKey of Object.keys(tsConfig)) {\n      const tsValue = tsConfig[tsKey];\n      const pyKey = generic_utils.toSnakeCase(tsKey);\n\n      if ((tsKey === 'name' || tsKey === 'className') && typeof tsValue === 'string') {\n        // Special case the 'name' key with a string value. Name values, such as\n        // the names of LayersModel and Layer instances, should not undergo the\n        // snake-case conversion.\n        pyDict[pyKey] = tsValue;\n      } else {\n        pyDict[pyKey] = convertTsToPythonic(tsValue, tsKey);\n      }\n    }\n\n    return pyDict;\n  }\n}","map":{"version":3,"names":["generic_utils","isArrayItemInputOrOutputName","key","index","value","convertPythonicToTs","pythonicConfig","toCamelCase","Array","tsArray","arrayLength","length","i","item","push","tsDict","pythonicKey","Object","keys","pythonicValue","tsKey","convertTsToPythonic","tsConfig","undefined","toSnakeCase","pyArray","pyDict","tsValue","pyKey"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-layers/dist/utils/serialization_utils.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport * as generic_utils from '../utils/generic_utils';\n// tslint:enable\n/**\n * Test whether a value in an array is the name of a LayersModel or Layer.\n * @param key The key name that the value is found under. Note that the key\n *   may not be at the level immediately above the value, if the value is in a\n *   nested array.\n * @param index Index of the value in the Array that it is found in.\n * @param value The value object.\n * @returns A boolean indicating whether value is a name.\n */\nfunction isArrayItemInputOrOutputName(key, index, value) {\n    return (key === 'inboundNodes' || key === 'outputLayers' ||\n        key === 'inputLayers') &&\n        index === 0 && typeof value === 'string';\n}\n/**\n * Convert a Pythonic config object to TypeScript config object.\n * @param pythonicConfig The config object to convert.\n * @param key Optional key name of the object being converted.\n * @returns Result of the conversion.\n */\nexport function convertPythonicToTs(pythonicConfig, key) {\n    if (pythonicConfig === null) {\n        return null;\n    }\n    else if (typeof pythonicConfig === 'string') {\n        return generic_utils.toCamelCase(pythonicConfig);\n    }\n    else if ((typeof pythonicConfig === 'number') ||\n        (typeof pythonicConfig === 'boolean')) {\n        return pythonicConfig;\n    }\n    else if (pythonicConfig instanceof Array) {\n        const tsArray = [];\n        const arrayLength = pythonicConfig.length;\n        for (let i = 0; i < arrayLength; ++i) {\n            const item = pythonicConfig[i];\n            if (isArrayItemInputOrOutputName(key, i, item)) {\n                tsArray.push(item);\n            }\n            else {\n                tsArray.push(convertPythonicToTs(item, key));\n            }\n        }\n        return tsArray;\n    }\n    else {\n        const tsDict = {};\n        for (const pythonicKey of Object.keys(pythonicConfig)) {\n            const pythonicValue = pythonicConfig[pythonicKey];\n            if (pythonicKey === 'name' && typeof pythonicValue === 'string') {\n                // Special case the 'name' key with a string value. Name values, such as\n                // the names of LayersModel and Layer instances, should not undergo the\n                // camel-case conversion.\n                tsDict[pythonicKey] = pythonicValue;\n            }\n            else {\n                const tsKey = generic_utils.toCamelCase(pythonicKey);\n                tsDict[tsKey] = convertPythonicToTs(pythonicValue, tsKey);\n            }\n        }\n        return tsDict;\n    }\n}\n/**\n * Convert a TypeScript config object to Python config object.\n * @param tsConfig The config object to convert.\n * @param key Optional key name of the object being converted.\n * @returns Result of the conversion.\n */\nexport function convertTsToPythonic(tsConfig, key) {\n    if (tsConfig === null || tsConfig === undefined) {\n        return null;\n    }\n    else if (typeof tsConfig === 'string') {\n        return generic_utils.toSnakeCase(tsConfig);\n    }\n    else if ((typeof tsConfig === 'number') || (typeof tsConfig === 'boolean')) {\n        return tsConfig;\n    }\n    else if (tsConfig instanceof Array) {\n        const pyArray = [];\n        const arrayLength = tsConfig.length;\n        for (let i = 0; i < arrayLength; ++i) {\n            const item = tsConfig[i];\n            if (isArrayItemInputOrOutputName(key, i, item)) {\n                pyArray.push(item);\n            }\n            else {\n                pyArray.push(convertTsToPythonic(item, key));\n            }\n        }\n        return pyArray;\n    }\n    else {\n        const pyDict = {};\n        for (const tsKey of Object.keys(tsConfig)) {\n            const tsValue = tsConfig[tsKey];\n            const pyKey = generic_utils.toSnakeCase(tsKey);\n            if ((tsKey === 'name' || tsKey === 'className') &&\n                typeof tsValue === 'string') {\n                // Special case the 'name' key with a string value. Name values, such as\n                // the names of LayersModel and Layer instances, should not undergo the\n                // snake-case conversion.\n                pyDict[pyKey] = tsValue;\n            }\n            else {\n                pyDict[pyKey] = convertTsToPythonic(tsValue, tsKey);\n            }\n        }\n        return pyDict;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}