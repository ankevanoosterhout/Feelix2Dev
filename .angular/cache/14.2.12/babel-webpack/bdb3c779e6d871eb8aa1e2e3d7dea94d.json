{"ast":null,"code":"import { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { conv2d } from './conv2d';\nimport * as conv_util from './conv_util';\nimport { op } from './operation';\nimport { reshape } from './reshape';\n/**\n * Computes a 1D convolution over the input x.\n *\n * @param x The input tensor, of rank 3 or rank 2, of shape\n *     `[batch, width, inChannels]`. If rank 2, batch of 1 is assumed.\n * @param filter The filter, rank 3, of shape\n *     `[filterWidth, inDepth, outDepth]`.\n * @param stride The number of entries by which the filter is moved right at\n *     each step.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dataFormat An optional string from \"NWC\", \"NCW\". Defaults to \"NWC\",\n *     the data is stored in the order of [batch, in_width, in_channels]. Only\n *     \"NWC\" is currently supported.\n * @param dilation The dilation rate in which we sample input values in\n *     atrous convolution. Defaults to `1`. If it is greater than 1, then\n *     stride must be `1`.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n *\n * @doc {heading: 'Operations', subheading: 'Convolution'}\n */\n\nfunction conv1d_(x, filter, stride, pad, dataFormat = 'NWC', dilation = 1, dimRoundingMode) {\n  const $x = convertToTensor(x, 'x', 'conv1d');\n  const $filter = convertToTensor(filter, 'filter', 'conv1d');\n  let x3D = $x;\n  let reshapedTo3D = false;\n\n  if ($x.rank === 2) {\n    reshapedTo3D = true;\n    x3D = reshape($x, [1, $x.shape[0], $x.shape[1]]);\n  }\n\n  util.assert(x3D.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${x3D.rank}.`);\n  util.assert($filter.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ` + `${$filter.rank}.`);\n  conv_util.checkPadOnDimRoundingMode('conv1d', pad, dimRoundingMode);\n  util.assert(x3D.shape[2] === $filter.shape[1], () => `Error in conv1d: depth of input (${x3D.shape[2]}) must match ` + `input depth for filter ${$filter.shape[1]}.`);\n  util.assert(conv_util.eitherStridesOrDilationsAreOne(stride, dilation), () => 'Error in conv1D: Either stride or dilation must be 1. ' + `Got stride ${stride} and dilation '${dilation}'`);\n  util.assert(dataFormat === 'NWC', () => `Error in conv1d: got dataFormat of ${dataFormat} but only NWC is currently supported.`);\n  const filter4D = reshape($filter, [1, $filter.shape[0], $filter.shape[1], $filter.shape[2]]);\n  const input4D = reshape(x3D, [x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]]);\n  const strides = [1, stride];\n  const dilations = [1, dilation];\n  const conv2dDataFormat = 'NHWC';\n  const res = conv2d(input4D, filter4D, strides, pad, conv2dDataFormat, dilations, dimRoundingMode);\n\n  if (reshapedTo3D) {\n    return reshape(res, [res.shape[2], res.shape[3]]);\n  }\n\n  return reshape(res, [res.shape[0], res.shape[2], res.shape[3]]);\n}\n\nexport const conv1d = op({\n  conv1d_\n});","map":{"version":3,"names":["convertToTensor","util","conv2d","conv_util","op","reshape","conv1d_","x","filter","stride","pad","dataFormat","dilation","dimRoundingMode","$x","$filter","x3D","reshapedTo3D","rank","shape","assert","checkPadOnDimRoundingMode","eitherStridesOrDilationsAreOne","filter4D","input4D","strides","dilations","conv2dDataFormat","res","conv1d"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-core/dist/ops/conv1d.js"],"sourcesContent":["import { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { conv2d } from './conv2d';\nimport * as conv_util from './conv_util';\nimport { op } from './operation';\nimport { reshape } from './reshape';\n/**\n * Computes a 1D convolution over the input x.\n *\n * @param x The input tensor, of rank 3 or rank 2, of shape\n *     `[batch, width, inChannels]`. If rank 2, batch of 1 is assumed.\n * @param filter The filter, rank 3, of shape\n *     `[filterWidth, inDepth, outDepth]`.\n * @param stride The number of entries by which the filter is moved right at\n *     each step.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dataFormat An optional string from \"NWC\", \"NCW\". Defaults to \"NWC\",\n *     the data is stored in the order of [batch, in_width, in_channels]. Only\n *     \"NWC\" is currently supported.\n * @param dilation The dilation rate in which we sample input values in\n *     atrous convolution. Defaults to `1`. If it is greater than 1, then\n *     stride must be `1`.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n *\n * @doc {heading: 'Operations', subheading: 'Convolution'}\n */\nfunction conv1d_(x, filter, stride, pad, dataFormat = 'NWC', dilation = 1, dimRoundingMode) {\n    const $x = convertToTensor(x, 'x', 'conv1d');\n    const $filter = convertToTensor(filter, 'filter', 'conv1d');\n    let x3D = $x;\n    let reshapedTo3D = false;\n    if ($x.rank === 2) {\n        reshapedTo3D = true;\n        x3D = reshape($x, [1, $x.shape[0], $x.shape[1]]);\n    }\n    util.assert(x3D.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${x3D.rank}.`);\n    util.assert($filter.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ` +\n        `${$filter.rank}.`);\n    conv_util.checkPadOnDimRoundingMode('conv1d', pad, dimRoundingMode);\n    util.assert(x3D.shape[2] === $filter.shape[1], () => `Error in conv1d: depth of input (${x3D.shape[2]}) must match ` +\n        `input depth for filter ${$filter.shape[1]}.`);\n    util.assert(conv_util.eitherStridesOrDilationsAreOne(stride, dilation), () => 'Error in conv1D: Either stride or dilation must be 1. ' +\n        `Got stride ${stride} and dilation '${dilation}'`);\n    util.assert(dataFormat === 'NWC', () => `Error in conv1d: got dataFormat of ${dataFormat} but only NWC is currently supported.`);\n    const filter4D = reshape($filter, [1, $filter.shape[0], $filter.shape[1], $filter.shape[2]]);\n    const input4D = reshape(x3D, [x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]]);\n    const strides = [1, stride];\n    const dilations = [1, dilation];\n    const conv2dDataFormat = 'NHWC';\n    const res = conv2d(input4D, filter4D, strides, pad, conv2dDataFormat, dilations, dimRoundingMode);\n    if (reshapedTo3D) {\n        return reshape(res, [res.shape[2], res.shape[3]]);\n    }\n    return reshape(res, [res.shape[0], res.shape[2], res.shape[3]]);\n}\nexport const conv1d = op({ conv1d_ });\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}