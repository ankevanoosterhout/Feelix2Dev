{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { BroadcastArgs } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Return the shape of s0 op s1 with broadcast.\n *\n * compute r0, the broadcasted shape as a tensor.\n * s0, s1 and r0 are all integer vectors.\n *\n * This function returns the shape of the result of an operation between\n * two tensors of size s0 and s1 performed with broadcast.\n *\n * @param s0 A tensor representing a shape\n * @param s1 A tensor representing a shape\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\n\nfunction broadcastArgs_(s0, s1) {\n  const shape1Input = convertToTensor(s0, 's0', 'broadcastArgs', 'int32');\n  const shape2Input = convertToTensor(s1, 's1', 'broadcastArgs', 'int32');\n\n  if (shape1Input.rank !== 1) {\n    throw new Error('broadcastArgs(): first input must be a vector (rank=1). ' + `Has rank ${shape1Input.rank}`);\n  }\n\n  if (shape2Input.rank !== 1) {\n    throw new Error('broadcastArgs(): second input must be a vector (rank=1). ' + `Has rank ${shape2Input.rank}`);\n  }\n\n  const inputs = {\n    s0: shape1Input,\n    s1: shape2Input\n  };\n  return ENGINE.runKernel(BroadcastArgs, inputs);\n}\n\nexport const broadcastArgs = op({\n  broadcastArgs_\n});","map":{"version":3,"names":["ENGINE","BroadcastArgs","convertToTensor","op","broadcastArgs_","s0","s1","shape1Input","shape2Input","rank","Error","inputs","runKernel","broadcastArgs"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-core/dist/ops/broadcast_args.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { BroadcastArgs } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Return the shape of s0 op s1 with broadcast.\n *\n * compute r0, the broadcasted shape as a tensor.\n * s0, s1 and r0 are all integer vectors.\n *\n * This function returns the shape of the result of an operation between\n * two tensors of size s0 and s1 performed with broadcast.\n *\n * @param s0 A tensor representing a shape\n * @param s1 A tensor representing a shape\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nfunction broadcastArgs_(s0, s1) {\n    const shape1Input = convertToTensor(s0, 's0', 'broadcastArgs', 'int32');\n    const shape2Input = convertToTensor(s1, 's1', 'broadcastArgs', 'int32');\n    if (shape1Input.rank !== 1) {\n        throw new Error('broadcastArgs(): first input must be a vector (rank=1). ' +\n            `Has rank ${shape1Input.rank}`);\n    }\n    if (shape2Input.rank !== 1) {\n        throw new Error('broadcastArgs(): second input must be a vector (rank=1). ' +\n            `Has rank ${shape2Input.rank}`);\n    }\n    const inputs = { s0: shape1Input, s1: shape2Input };\n    return ENGINE.runKernel(BroadcastArgs, inputs);\n}\nexport const broadcastArgs = op({ broadcastArgs_ });\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAT,QAAuB,WAAvB;AACA,SAASC,aAAT,QAA8B,iBAA9B;AACA,SAASC,eAAT,QAAgC,oBAAhC;AACA,SAASC,EAAT,QAAmB,aAAnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,cAAT,CAAwBC,EAAxB,EAA4BC,EAA5B,EAAgC;EAC5B,MAAMC,WAAW,GAAGL,eAAe,CAACG,EAAD,EAAK,IAAL,EAAW,eAAX,EAA4B,OAA5B,CAAnC;EACA,MAAMG,WAAW,GAAGN,eAAe,CAACI,EAAD,EAAK,IAAL,EAAW,eAAX,EAA4B,OAA5B,CAAnC;;EACA,IAAIC,WAAW,CAACE,IAAZ,KAAqB,CAAzB,EAA4B;IACxB,MAAM,IAAIC,KAAJ,CAAU,6DACX,YAAWH,WAAW,CAACE,IAAK,EAD3B,CAAN;EAEH;;EACD,IAAID,WAAW,CAACC,IAAZ,KAAqB,CAAzB,EAA4B;IACxB,MAAM,IAAIC,KAAJ,CAAU,8DACX,YAAWF,WAAW,CAACC,IAAK,EAD3B,CAAN;EAEH;;EACD,MAAME,MAAM,GAAG;IAAEN,EAAE,EAAEE,WAAN;IAAmBD,EAAE,EAAEE;EAAvB,CAAf;EACA,OAAOR,MAAM,CAACY,SAAP,CAAiBX,aAAjB,EAAgCU,MAAhC,CAAP;AACH;;AACD,OAAO,MAAME,aAAa,GAAGV,EAAE,CAAC;EAAEC;AAAF,CAAD,CAAxB"},"metadata":{},"sourceType":"module"}