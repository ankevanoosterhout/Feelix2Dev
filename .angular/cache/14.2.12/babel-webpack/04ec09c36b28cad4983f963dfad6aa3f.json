{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, TopK, util } from '@tensorflow/tfjs-core';\nimport { topKImplCPU } from '../kernel_utils/shared';\nimport { MergeProgram, SwapProgram } from '../top_k_gpu';\nimport { fill } from './Fill';\nimport { gatherV2 } from './GatherV2';\nimport { reshape } from './Reshape';\nimport { slice } from './Slice';\n\nfunction disposeIntermediateTensorInfoOrNull(backend, tensorInfo) {\n  if (tensorInfo !== null) {\n    backend.disposeIntermediateTensorInfo(tensorInfo);\n  }\n}\n\nfunction roundUpToPow2(num) {\n  let pow2 = 1;\n\n  while (pow2 < num) {\n    pow2 *= 2;\n  }\n\n  return pow2;\n} // Based on Algorithm 2 of Bitonic Top K, ref:\n// https://anilshanbhag.in/static/papers/gputopk_sigmod18.pdf\n\n\nexport function topK(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x\n  } = inputs;\n  const {\n    k,\n    sorted\n  } = attrs; // Empirically determined constant used to determine last dim threshold for\n  // handing off execution to the CPU.\n\n  const TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD = env().getNumber('TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD'); // Empirically determined constant used to determine k threshold for handing\n  // off execution to the CPU.\n\n  const TOPK_K_CPU_HANDOFF_THRESHOLD = env().getNumber('TOPK_K_CPU_HANDOFF_THRESHOLD');\n  const xShape = x.shape;\n  const lastDim = xShape[xShape.length - 1];\n\n  if (backend.shouldExecuteOnCPU([x]) || lastDim < TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD || k > TOPK_K_CPU_HANDOFF_THRESHOLD) {\n    const xVals = backend.readSync(x.dataId);\n    const [allTopKVals, allTopKIndices] = topKImplCPU(xVals, xShape, x.dtype, k, sorted);\n    return [backend.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values), backend.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)];\n  }\n\n  if (k === 0) {\n    xShape[xShape.length - 1] = 0;\n    return [backend.makeTensorInfo(xShape, x.dtype, []), backend.makeTensorInfo(xShape, 'int32', [])];\n  }\n\n  if (lastDim === 1\n  /* firstPass */\n  ) {\n    return [x, fill({\n      attrs: {\n        shape: xShape,\n        dtype: 'int32',\n        value: 0\n      },\n      backend\n    })];\n  } // Eagerly unpack x input since it is passed in to all the shaders which\n  // require unpacked inputs.\n\n\n  const xtexData = backend.texData.get(x.dataId);\n  const xIsPacked = xtexData !== null && xtexData.isPacked;\n  const xUnPacked = xIsPacked ? backend.unpackTensor(x) : x; // Reshape into a 2d tensor [batch, lastDim] and compute topk along lastDim.\n\n  const xSize = util.sizeFromShape(xShape);\n  const batch = xSize / lastDim;\n  const x2D = reshape({\n    inputs: {\n      x: xUnPacked\n    },\n    attrs: {\n      shape: [batch, lastDim]\n    },\n    backend\n  });\n\n  if (xIsPacked) {\n    disposeIntermediateTensorInfoOrNull(backend, xUnPacked);\n  }\n\n  const kPow2 = roundUpToPow2(k);\n  const lastDimPow2 = roundUpToPow2(lastDim); // Only the indices containing the top K are kept at every step to reduce\n  // number of outputs in the GPU algorithms, so once the final set of indices\n  // is computed then gather is used to grab the corresponding values\n  // from the original input.\n\n  let indices = null; // GPU algorithm always takes in an indices input but this input is not used\n  // on the first run of a GPU algorithm, therefore if indices is null we simply\n  // pass in x2D instead of it but the value will not actually be used\n\n  const getInputs = () => indices === null ? [x2D, x2D] : [x2D, indices];\n\n  const runSwap = (dir, inc, shape) => {\n    const inputs = getInputs();\n    const program = new SwapProgram(shape);\n    const fistPass = indices === null ? 1 : 0;\n    const customValues = [[lastDim], [fistPass], [Number.NEGATIVE_INFINITY], [dir], [inc]];\n    const prevIndices = indices;\n    indices = backend.runWebGLProgram(program, inputs, 'int32', customValues);\n    disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n  }; // Step 1: local sort\n\n\n  for (let len = 1; len < kPow2; len *= 2) {\n    const dir = len * 2;\n\n    for (let inc = len; inc >= 1; inc /= 2) {\n      runSwap(dir, inc, [batch, lastDimPow2]);\n    }\n  } // Step 2: merge\n\n\n  for (let indicesSize = lastDimPow2; indicesSize > kPow2; indicesSize /= 2) {\n    const inputs = getInputs();\n    const mergeProgram = new MergeProgram([batch, indicesSize / 2]);\n    const firstPass = indices === null ? 1 : 0;\n    const customValues = [[lastDim], [firstPass], [kPow2]];\n    const prevIndices = indices;\n    indices = backend.runWebGLProgram(mergeProgram, inputs, 'int32', customValues);\n    disposeIntermediateTensorInfoOrNull(backend, prevIndices); // Step 3: rebuild\n\n    const len = kPow2 / 2;\n    const dir = len * 2;\n\n    for (let inc = len; inc >= 1; inc /= 2) {\n      runSwap(dir, inc, indices.shape);\n    }\n  } // Keep only the requested top K results instead of kPow2\n\n\n  let prevIndices = indices;\n  indices = slice({\n    inputs: {\n      x: indices\n    },\n    backend,\n    attrs: {\n      begin: 0,\n      size: [batch, k]\n    }\n  });\n  disposeIntermediateTensorInfoOrNull(backend, prevIndices); // Gather values on last dimension\n\n  let values = gatherV2({\n    inputs: {\n      x: x2D,\n      indices\n    },\n    backend,\n    attrs: {\n      axis: 1,\n      batchDims: 1\n    }\n  });\n  disposeIntermediateTensorInfoOrNull(backend, x2D); // Reshape back to the original input shape, except that the last\n  // dimension is k.\n\n  const newShape = xShape.slice(0, -1);\n  newShape.push(k);\n  prevIndices = indices;\n  indices = reshape({\n    inputs: {\n      x: indices\n    },\n    attrs: {\n      shape: newShape\n    },\n    backend\n  });\n  disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n  const prevValues = values;\n  values = reshape({\n    inputs: {\n      x: values\n    },\n    attrs: {\n      shape: newShape\n    },\n    backend\n  });\n  disposeIntermediateTensorInfoOrNull(backend, prevValues);\n  return [values, indices];\n}\nexport const topKConfig = {\n  kernelName: TopK,\n  backendName: 'webgl',\n  kernelFunc: topK\n};","map":{"version":3,"names":["env","TopK","util","topKImplCPU","MergeProgram","SwapProgram","fill","gatherV2","reshape","slice","disposeIntermediateTensorInfoOrNull","backend","tensorInfo","disposeIntermediateTensorInfo","roundUpToPow2","num","pow2","topK","args","inputs","attrs","x","k","sorted","TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD","getNumber","TOPK_K_CPU_HANDOFF_THRESHOLD","xShape","shape","lastDim","length","shouldExecuteOnCPU","xVals","readSync","dataId","allTopKVals","allTopKIndices","dtype","makeTensorInfo","values","value","xtexData","texData","get","xIsPacked","isPacked","xUnPacked","unpackTensor","xSize","sizeFromShape","batch","x2D","kPow2","lastDimPow2","indices","getInputs","runSwap","dir","inc","program","fistPass","customValues","Number","NEGATIVE_INFINITY","prevIndices","runWebGLProgram","len","indicesSize","mergeProgram","firstPass","begin","size","axis","batchDims","newShape","push","prevValues","topKConfig","kernelName","backendName","kernelFunc"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/TopK.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, TopK, util } from '@tensorflow/tfjs-core';\nimport { topKImplCPU } from '../kernel_utils/shared';\nimport { MergeProgram, SwapProgram } from '../top_k_gpu';\nimport { fill } from './Fill';\nimport { gatherV2 } from './GatherV2';\nimport { reshape } from './Reshape';\nimport { slice } from './Slice';\nfunction disposeIntermediateTensorInfoOrNull(backend, tensorInfo) {\n    if (tensorInfo !== null) {\n        backend.disposeIntermediateTensorInfo(tensorInfo);\n    }\n}\nfunction roundUpToPow2(num) {\n    let pow2 = 1;\n    while (pow2 < num) {\n        pow2 *= 2;\n    }\n    return pow2;\n}\n// Based on Algorithm 2 of Bitonic Top K, ref:\n// https://anilshanbhag.in/static/papers/gputopk_sigmod18.pdf\nexport function topK(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { k, sorted } = attrs;\n    // Empirically determined constant used to determine last dim threshold for\n    // handing off execution to the CPU.\n    const TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD = env().getNumber('TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD');\n    // Empirically determined constant used to determine k threshold for handing\n    // off execution to the CPU.\n    const TOPK_K_CPU_HANDOFF_THRESHOLD = env().getNumber('TOPK_K_CPU_HANDOFF_THRESHOLD');\n    const xShape = x.shape;\n    const lastDim = xShape[xShape.length - 1];\n    if (backend.shouldExecuteOnCPU([x]) ||\n        lastDim < TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD ||\n        k > TOPK_K_CPU_HANDOFF_THRESHOLD) {\n        const xVals = backend.readSync(x.dataId);\n        const [allTopKVals, allTopKIndices] = topKImplCPU(xVals, xShape, x.dtype, k, sorted);\n        return [\n            backend.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),\n            backend.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)\n        ];\n    }\n    if (k === 0) {\n        xShape[xShape.length - 1] = 0;\n        return [\n            backend.makeTensorInfo(xShape, x.dtype, []),\n            backend.makeTensorInfo(xShape, 'int32', [])\n        ];\n    }\n    if (lastDim === 1 /* firstPass */) {\n        return [\n            x, fill({ attrs: { shape: xShape, dtype: 'int32', value: 0 }, backend })\n        ];\n    }\n    // Eagerly unpack x input since it is passed in to all the shaders which\n    // require unpacked inputs.\n    const xtexData = backend.texData.get(x.dataId);\n    const xIsPacked = xtexData !== null && xtexData.isPacked;\n    const xUnPacked = xIsPacked ? backend.unpackTensor(x) : x;\n    // Reshape into a 2d tensor [batch, lastDim] and compute topk along lastDim.\n    const xSize = util.sizeFromShape(xShape);\n    const batch = xSize / lastDim;\n    const x2D = reshape({ inputs: { x: xUnPacked }, attrs: { shape: [batch, lastDim] }, backend });\n    if (xIsPacked) {\n        disposeIntermediateTensorInfoOrNull(backend, xUnPacked);\n    }\n    const kPow2 = roundUpToPow2(k);\n    const lastDimPow2 = roundUpToPow2(lastDim);\n    // Only the indices containing the top K are kept at every step to reduce\n    // number of outputs in the GPU algorithms, so once the final set of indices\n    // is computed then gather is used to grab the corresponding values\n    // from the original input.\n    let indices = null;\n    // GPU algorithm always takes in an indices input but this input is not used\n    // on the first run of a GPU algorithm, therefore if indices is null we simply\n    // pass in x2D instead of it but the value will not actually be used\n    const getInputs = () => indices === null ? [x2D, x2D] : [x2D, indices];\n    const runSwap = (dir, inc, shape) => {\n        const inputs = getInputs();\n        const program = new SwapProgram(shape);\n        const fistPass = indices === null ? 1 : 0;\n        const customValues = [[lastDim], [fistPass], [Number.NEGATIVE_INFINITY], [dir], [inc]];\n        const prevIndices = indices;\n        indices = backend.runWebGLProgram(program, inputs, 'int32', customValues);\n        disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n    };\n    // Step 1: local sort\n    for (let len = 1; len < kPow2; len *= 2) {\n        const dir = len * 2;\n        for (let inc = len; inc >= 1; inc /= 2) {\n            runSwap(dir, inc, [batch, lastDimPow2]);\n        }\n    }\n    // Step 2: merge\n    for (let indicesSize = lastDimPow2; indicesSize > kPow2; indicesSize /= 2) {\n        const inputs = getInputs();\n        const mergeProgram = new MergeProgram([batch, indicesSize / 2]);\n        const firstPass = indices === null ? 1 : 0;\n        const customValues = [[lastDim], [firstPass], [kPow2]];\n        const prevIndices = indices;\n        indices =\n            backend.runWebGLProgram(mergeProgram, inputs, 'int32', customValues);\n        disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n        // Step 3: rebuild\n        const len = kPow2 / 2;\n        const dir = len * 2;\n        for (let inc = len; inc >= 1; inc /= 2) {\n            runSwap(dir, inc, indices.shape);\n        }\n    }\n    // Keep only the requested top K results instead of kPow2\n    let prevIndices = indices;\n    indices = slice({ inputs: { x: indices }, backend, attrs: { begin: 0, size: [batch, k] } });\n    disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n    // Gather values on last dimension\n    let values = gatherV2({ inputs: { x: x2D, indices }, backend, attrs: { axis: 1, batchDims: 1 } });\n    disposeIntermediateTensorInfoOrNull(backend, x2D);\n    // Reshape back to the original input shape, except that the last\n    // dimension is k.\n    const newShape = xShape.slice(0, -1);\n    newShape.push(k);\n    prevIndices = indices;\n    indices = reshape({ inputs: { x: indices }, attrs: { shape: newShape }, backend });\n    disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n    const prevValues = values;\n    values = reshape({ inputs: { x: values }, attrs: { shape: newShape }, backend });\n    disposeIntermediateTensorInfoOrNull(backend, prevValues);\n    return [values, indices];\n}\nexport const topKConfig = {\n    kernelName: TopK,\n    backendName: 'webgl',\n    kernelFunc: topK\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}