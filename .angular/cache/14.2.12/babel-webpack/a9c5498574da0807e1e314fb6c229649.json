{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Tile } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { clone } from './clone';\nimport { op } from './operation';\nimport { reshape } from './reshape';\n/**\n * Broadcast an array to a compatible shape NumPy-style.\n *\n * The tensor's shape is compared to the broadcast shape from end to beginning.\n * Ones are prepended to the tensor's shape until it has the same length as\n * the broadcast shape. If input.shape[i]==shape[i], the (i+1)-th axis is\n * already broadcast-compatible. If input.shape[i]==1 and shape[i]==N, then\n * the input tensor is tiled N times along that axis (using tf.tile).\n *\n * @param input The tensor that is to be broadcasted.\n * @param shape The input is to be broadcast to this shape.\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\n\nfunction broadcastTo_(x, shape) {\n  let input = convertToTensor(x, 'broadcastTo', 'x');\n  const xShape = input.shape;\n\n  if (shape.some(d => !(d > 0) || d % 1 !== 0)) {\n    throw new Error(`broadcastTo(): Invalid broadcast shape [${shape}].`);\n  }\n\n  if (shape.length < input.rank) {\n    throw new Error(`broadcastTo(): shape.length=${shape.length} < input.rank=${input.rank}.`);\n  }\n\n  if (shape.length > input.rank) {\n    const newShape = input.shape.slice();\n\n    while (newShape.length < shape.length) {\n      newShape.unshift(1);\n    }\n\n    input = reshape(input, newShape);\n  }\n\n  const inputShape = input.shape;\n  const reps = Array.from(shape);\n\n  for (let i = shape.length - 1; i >= 0; i--) {\n    if (inputShape[i] === shape[i]) {\n      reps[i] = 1;\n    } else if (input.shape[i] !== 1) {\n      throw new Error(`broadcastTo(): [${xShape}] cannot be broadcast to [${shape}].`);\n    }\n  }\n\n  const axes = reps.map((n, i) => n > 1 ? i : -1).filter(i => i >= 0);\n\n  if (axes.length === 0) {\n    return clone(input);\n  } // TODO call broadcastTo kernel directly once backends implement broadcstTo\n\n\n  const inputs = {\n    x: input\n  };\n  const attrs = {\n    reps\n  };\n  return ENGINE.runKernel(Tile, inputs, attrs);\n}\n\nexport const broadcastTo = op({\n  broadcastTo_\n});","map":{"version":3,"names":["ENGINE","Tile","convertToTensor","clone","op","reshape","broadcastTo_","x","shape","input","xShape","some","d","Error","length","rank","newShape","slice","unshift","inputShape","reps","Array","from","i","axes","map","n","filter","inputs","attrs","runKernel","broadcastTo"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-core/dist/ops/broadcast_to.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Tile } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { clone } from './clone';\nimport { op } from './operation';\nimport { reshape } from './reshape';\n/**\n * Broadcast an array to a compatible shape NumPy-style.\n *\n * The tensor's shape is compared to the broadcast shape from end to beginning.\n * Ones are prepended to the tensor's shape until it has the same length as\n * the broadcast shape. If input.shape[i]==shape[i], the (i+1)-th axis is\n * already broadcast-compatible. If input.shape[i]==1 and shape[i]==N, then\n * the input tensor is tiled N times along that axis (using tf.tile).\n *\n * @param input The tensor that is to be broadcasted.\n * @param shape The input is to be broadcast to this shape.\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nfunction broadcastTo_(x, shape) {\n    let input = convertToTensor(x, 'broadcastTo', 'x');\n    const xShape = input.shape;\n    if (shape.some(d => !(d > 0) || d % 1 !== 0)) {\n        throw new Error(`broadcastTo(): Invalid broadcast shape [${shape}].`);\n    }\n    if (shape.length < input.rank) {\n        throw new Error(`broadcastTo(): shape.length=${shape.length} < input.rank=${input.rank}.`);\n    }\n    if (shape.length > input.rank) {\n        const newShape = input.shape.slice();\n        while (newShape.length < shape.length) {\n            newShape.unshift(1);\n        }\n        input = reshape(input, newShape);\n    }\n    const inputShape = input.shape;\n    const reps = Array.from(shape);\n    for (let i = shape.length - 1; i >= 0; i--) {\n        if (inputShape[i] === shape[i]) {\n            reps[i] = 1;\n        }\n        else if (input.shape[i] !== 1) {\n            throw new Error(`broadcastTo(): [${xShape}] cannot be broadcast to [${shape}].`);\n        }\n    }\n    const axes = reps.map((n, i) => n > 1 ? i : -1).filter(i => i >= 0);\n    if (axes.length === 0) {\n        return clone(input);\n    }\n    // TODO call broadcastTo kernel directly once backends implement broadcstTo\n    const inputs = { x: input };\n    const attrs = { reps };\n    return ENGINE.runKernel(Tile, inputs, attrs);\n}\nexport const broadcastTo = op({ broadcastTo_ });\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAT,QAAuB,WAAvB;AACA,SAASC,IAAT,QAAqB,iBAArB;AACA,SAASC,eAAT,QAAgC,oBAAhC;AACA,SAASC,KAAT,QAAsB,SAAtB;AACA,SAASC,EAAT,QAAmB,aAAnB;AACA,SAASC,OAAT,QAAwB,WAAxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,YAAT,CAAsBC,CAAtB,EAAyBC,KAAzB,EAAgC;EAC5B,IAAIC,KAAK,GAAGP,eAAe,CAACK,CAAD,EAAI,aAAJ,EAAmB,GAAnB,CAA3B;EACA,MAAMG,MAAM,GAAGD,KAAK,CAACD,KAArB;;EACA,IAAIA,KAAK,CAACG,IAAN,CAAWC,CAAC,IAAI,EAAEA,CAAC,GAAG,CAAN,KAAYA,CAAC,GAAG,CAAJ,KAAU,CAAtC,CAAJ,EAA8C;IAC1C,MAAM,IAAIC,KAAJ,CAAW,2CAA0CL,KAAM,IAA3D,CAAN;EACH;;EACD,IAAIA,KAAK,CAACM,MAAN,GAAeL,KAAK,CAACM,IAAzB,EAA+B;IAC3B,MAAM,IAAIF,KAAJ,CAAW,+BAA8BL,KAAK,CAACM,MAAO,iBAAgBL,KAAK,CAACM,IAAK,GAAjF,CAAN;EACH;;EACD,IAAIP,KAAK,CAACM,MAAN,GAAeL,KAAK,CAACM,IAAzB,EAA+B;IAC3B,MAAMC,QAAQ,GAAGP,KAAK,CAACD,KAAN,CAAYS,KAAZ,EAAjB;;IACA,OAAOD,QAAQ,CAACF,MAAT,GAAkBN,KAAK,CAACM,MAA/B,EAAuC;MACnCE,QAAQ,CAACE,OAAT,CAAiB,CAAjB;IACH;;IACDT,KAAK,GAAGJ,OAAO,CAACI,KAAD,EAAQO,QAAR,CAAf;EACH;;EACD,MAAMG,UAAU,GAAGV,KAAK,CAACD,KAAzB;EACA,MAAMY,IAAI,GAAGC,KAAK,CAACC,IAAN,CAAWd,KAAX,CAAb;;EACA,KAAK,IAAIe,CAAC,GAAGf,KAAK,CAACM,MAAN,GAAe,CAA5B,EAA+BS,CAAC,IAAI,CAApC,EAAuCA,CAAC,EAAxC,EAA4C;IACxC,IAAIJ,UAAU,CAACI,CAAD,CAAV,KAAkBf,KAAK,CAACe,CAAD,CAA3B,EAAgC;MAC5BH,IAAI,CAACG,CAAD,CAAJ,GAAU,CAAV;IACH,CAFD,MAGK,IAAId,KAAK,CAACD,KAAN,CAAYe,CAAZ,MAAmB,CAAvB,EAA0B;MAC3B,MAAM,IAAIV,KAAJ,CAAW,mBAAkBH,MAAO,6BAA4BF,KAAM,IAAtE,CAAN;IACH;EACJ;;EACD,MAAMgB,IAAI,GAAGJ,IAAI,CAACK,GAAL,CAAS,CAACC,CAAD,EAAIH,CAAJ,KAAUG,CAAC,GAAG,CAAJ,GAAQH,CAAR,GAAY,CAAC,CAAhC,EAAmCI,MAAnC,CAA0CJ,CAAC,IAAIA,CAAC,IAAI,CAApD,CAAb;;EACA,IAAIC,IAAI,CAACV,MAAL,KAAgB,CAApB,EAAuB;IACnB,OAAOX,KAAK,CAACM,KAAD,CAAZ;EACH,CA7B2B,CA8B5B;;;EACA,MAAMmB,MAAM,GAAG;IAAErB,CAAC,EAAEE;EAAL,CAAf;EACA,MAAMoB,KAAK,GAAG;IAAET;EAAF,CAAd;EACA,OAAOpB,MAAM,CAAC8B,SAAP,CAAiB7B,IAAjB,EAAuB2B,MAAvB,EAA+BC,KAA/B,CAAP;AACH;;AACD,OAAO,MAAME,WAAW,GAAG3B,EAAE,CAAC;EAAEE;AAAF,CAAD,CAAtB"},"metadata":{},"sourceType":"module"}