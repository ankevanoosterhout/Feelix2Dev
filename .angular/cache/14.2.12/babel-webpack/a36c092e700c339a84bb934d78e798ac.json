{"ast":null,"code":"import { SOLVE_STATUS } from '../core/ChainSolver.js';\nimport { serialize } from './serialize.js';\nimport { generateSharedBuffer, applyToBuffer, copyFrameToBuffer, copyBufferToFrame, JOINT_STRIDE } from './utils.js';\nimport { findRoots } from '../core/utils/findRoots.js';\nconst useSharedArrayBuffers = typeof SharedArrayBuffer !== 'undefined';\nexport class WorkerSolver {\n  constructor(roots = []) {\n    this.roots = Array.isArray(roots) ? [...roots] : [roots];\n    this.status = [];\n    this.running = false;\n    this.frames = null;\n    this.buffer = null;\n    this.floatBuffer = null;\n    this.byteBuffer = null;\n    this.jointsToUpdate = null;\n    this.jointsToIndexMap = null;\n    this.scheduledStateUpdate = false;\n    const worker = new Worker(new URL('./workerSolver.worker.js'), {\n      type: 'module'\n    });\n    let scheduled = false;\n\n    worker.onmessage = ({\n      data: e\n    }) => {\n      if (e.type === 'updateSolve') {\n        // If the solve is completed then schedule a copy onto our joints to avoid\n        // copying multiple times per frame.\n        if (!scheduled) {\n          scheduled = true;\n          Promise.resolve().then(() => {\n            // Only copy the DoF values of the joints that are to move.\n            let byteBuffer, floatBuffer;\n\n            if (useSharedArrayBuffers) {\n              byteBuffer = this.byteBuffer;\n              floatBuffer = this.floatBuffer;\n            } else {\n              byteBuffer = new Uint8Array(e.data.buffer);\n              floatBuffer = new Float32Array(e.data.buffer);\n            }\n\n            const {\n              jointsToIndexMap,\n              jointsToUpdate\n            } = this;\n\n            for (let i = 0, l = jointsToUpdate.length; i < l; i++) {\n              const joint = jointsToUpdate[i];\n              const index = jointsToIndexMap.get(joint);\n              copyBufferToFrame(joint, floatBuffer, byteBuffer, index * JOINT_STRIDE, true, false);\n            }\n\n            scheduled = false;\n          });\n        }\n\n        const status = e.data.status;\n        this.status = status;\n\n        if (status !== SOLVE_STATUS.TIMEOUT) {\n          this.running = false;\n        }\n      }\n    };\n\n    this.worker = worker;\n    this.updateStructure();\n  } // Update the structure of the graph in the worker. Must be called every time the graph structure\n  // changes or a degree of freedom changes. Or if the main thread must change the DoF values.\n\n\n  updateStructure() {\n    // TODO: do we need to track versions of the structure now if we use\n    // normal array buffers so we don't respond to an outdated update event?\n    const {\n      worker\n    } = this;\n    const roots = findRoots(this.roots); // Get all frames in the graph\n\n    const framesSet = new Set();\n    roots.forEach(root => root.traverse(c => {\n      framesSet.add(c);\n    })); // Seralize the frames and generate a buffer\n\n    const frames = Array.from(framesSet);\n    const serialized = serialize(frames);\n    const buffer = generateSharedBuffer(frames, useSharedArrayBuffers);\n    const floatBuffer = new Float32Array(buffer);\n    const byteBuffer = new Uint8Array(buffer); // Filter all the frames down to joints that should be updated from\n    // the worker.\n\n    const jointsToUpdate = [];\n    const jointsToIndexMap = new Map();\n\n    for (let i = 0, l = frames.length; i < l; i++) {\n      const frame = frames[i];\n\n      if (frame.isJoint && frame.dof.length > 0) {\n        jointsToUpdate.push(frame);\n        jointsToIndexMap.set(frame, i);\n      }\n    }\n\n    if (useSharedArrayBuffers) {\n      this.buffer = buffer;\n      this.floatBuffer = floatBuffer;\n      this.byteBuffer = byteBuffer;\n    } else {\n      this.buffer = buffer.slice();\n      this.floatBuffer = new Float32Array(this.buffer);\n      this.byteBuffer = new Uint8Array(this.buffer);\n    }\n\n    this.frames = frames;\n    this.jointsToUpdate = jointsToUpdate;\n    this.jointsToIndexMap = jointsToIndexMap;\n\n    if (useSharedArrayBuffers) {\n      worker.postMessage({\n        type: 'updateStructure',\n        data: {\n          serialized,\n          buffer\n        }\n      });\n    } else {\n      worker.postMessage({\n        type: 'updateStructure',\n        data: {\n          serialized,\n          buffer\n        }\n      }, [buffer]);\n    }\n  } // Update the solver settings via a settings object.\n\n\n  updateSolverSettings(settings) {\n    this.worker.postMessage({\n      type: 'updateSolverSettings',\n      data: settings\n    });\n  } // Copy the non DoF values over to shared buffer for use in the worker\n\n\n  updateFrameState(...updateJoints) {\n    const {\n      frames,\n      floatBuffer,\n      byteBuffer\n    } = this;\n\n    if (updateJoints.length === 0) {\n      applyToBuffer(frames, floatBuffer, byteBuffer, false, true);\n    } else {\n      for (let i = 0, l = updateJoints.length; i < l; i++) {\n        const frame = updateJoints[i];\n        const index = frames.indexOf(frame);\n        copyFrameToBuffer(frame, floatBuffer, byteBuffer, JOINT_STRIDE * index, false, true);\n      }\n    }\n\n    if (!useSharedArrayBuffers && !this.scheduledStateUpdate) {\n      this.scheduledStateUpdate = true;\n      Promise.resolve().then(() => {\n        this.scheduledStateUpdate = false;\n        const buffer = this.buffer.slice();\n        this.worker.postMessage({\n          type: 'updateFrameState',\n          data: {\n            buffer\n          }\n        }, [buffer]);\n      });\n    }\n  } // Start the solve loop if it's not running\n\n\n  solve() {\n    this.worker.postMessage({\n      type: 'startSolve'\n    });\n    this.running = true;\n  } // Stop the solve loop\n\n\n  stop() {\n    this.worker.postMessage({\n      type: 'stopSolve'\n    });\n    this.running = false;\n  } // Stop and dispose the worker\n\n\n  dispose() {\n    this.stop();\n    this.worker.terminate();\n    this.worker = null;\n  }\n\n}","map":{"version":3,"names":["SOLVE_STATUS","serialize","generateSharedBuffer","applyToBuffer","copyFrameToBuffer","copyBufferToFrame","JOINT_STRIDE","findRoots","useSharedArrayBuffers","SharedArrayBuffer","WorkerSolver","constructor","roots","Array","isArray","status","running","frames","buffer","floatBuffer","byteBuffer","jointsToUpdate","jointsToIndexMap","scheduledStateUpdate","worker","Worker","URL","type","scheduled","onmessage","data","e","Promise","resolve","then","Uint8Array","Float32Array","i","l","length","joint","index","get","TIMEOUT","updateStructure","framesSet","Set","forEach","root","traverse","c","add","from","serialized","Map","frame","isJoint","dof","push","set","slice","postMessage","updateSolverSettings","settings","updateFrameState","updateJoints","indexOf","solve","stop","dispose","terminate"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/closed-chain-ik/src/worker/WorkerSolver.js"],"sourcesContent":["import { SOLVE_STATUS } from '../core/ChainSolver.js';\r\nimport { serialize } from './serialize.js';\r\nimport {\r\n\tgenerateSharedBuffer,\r\n\tapplyToBuffer,\r\n\tcopyFrameToBuffer,\r\n\tcopyBufferToFrame,\r\n\tJOINT_STRIDE,\r\n} from './utils.js';\r\nimport { findRoots } from '../core/utils/findRoots.js';\r\n\r\nconst useSharedArrayBuffers = ( typeof SharedArrayBuffer ) !== 'undefined';\r\n\r\nexport class WorkerSolver {\r\n\r\n\tconstructor( roots = [] ) {\r\n\r\n\t\tthis.roots = Array.isArray( roots ) ? [ ...roots ] : [ roots ];\r\n\t\tthis.status = [];\r\n\t\tthis.running = false;\r\n\r\n\t\tthis.frames = null;\r\n\t\tthis.buffer = null;\r\n\t\tthis.floatBuffer = null;\r\n\t\tthis.byteBuffer = null;\r\n\t\tthis.jointsToUpdate = null;\r\n\t\tthis.jointsToIndexMap = null;\r\n\t\tthis.scheduledStateUpdate = false;\r\n\r\n\t\tconst worker = new Worker( new URL( './workerSolver.worker.js' ), { type: 'module' } );\r\n\t\tlet scheduled = false;\r\n\t\tworker.onmessage = ( { data: e } ) => {\r\n\r\n\t\t\tif ( e.type === 'updateSolve' ) {\r\n\r\n\t\t\t\t// If the solve is completed then schedule a copy onto our joints to avoid\r\n\t\t\t\t// copying multiple times per frame.\r\n\t\t\t\tif ( ! scheduled ) {\r\n\r\n\t\t\t\t\tscheduled = true;\r\n\t\t\t\t\tPromise.resolve().then( () => {\r\n\r\n\t\t\t\t\t\t// Only copy the DoF values of the joints that are to move.\r\n\t\t\t\t\t\tlet byteBuffer, floatBuffer;\r\n\t\t\t\t\t\tif ( useSharedArrayBuffers ) {\r\n\r\n\t\t\t\t\t\t\tbyteBuffer = this.byteBuffer;\r\n\t\t\t\t\t\t\tfloatBuffer = this.floatBuffer;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tbyteBuffer = new Uint8Array( e.data.buffer );\r\n\t\t\t\t\t\t\tfloatBuffer = new Float32Array( e.data.buffer );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tconst { jointsToIndexMap, jointsToUpdate } = this;\r\n\t\t\t\t\t\tfor ( let i = 0, l = jointsToUpdate.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tconst joint = jointsToUpdate[ i ];\r\n\t\t\t\t\t\t\tconst index = jointsToIndexMap.get( joint );\r\n\r\n\t\t\t\t\t\t\tcopyBufferToFrame( joint, floatBuffer, byteBuffer, index * JOINT_STRIDE, true, false );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tscheduled = false;\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst status = e.data.status;\r\n\t\t\t\tthis.status = status;\r\n\t\t\t\tif ( status !== SOLVE_STATUS.TIMEOUT ) {\r\n\r\n\t\t\t\t\tthis.running = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tthis.worker = worker;\r\n\t\tthis.updateStructure();\r\n\r\n\t}\r\n\r\n\t// Update the structure of the graph in the worker. Must be called every time the graph structure\r\n\t// changes or a degree of freedom changes. Or if the main thread must change the DoF values.\r\n\tupdateStructure() {\r\n\r\n\t\t// TODO: do we need to track versions of the structure now if we use\r\n\t\t// normal array buffers so we don't respond to an outdated update event?\r\n\r\n\t\tconst { worker } = this;\r\n\r\n\t\tconst roots = findRoots( this.roots );\r\n\r\n\t\t// Get all frames in the graph\r\n\t\tconst framesSet = new Set();\r\n\t\troots.forEach( root => root.traverse( c => {\r\n\r\n\t\t\tframesSet.add( c );\r\n\r\n\t\t} ) );\r\n\r\n\t\t// Seralize the frames and generate a buffer\r\n\t\tconst frames = Array.from( framesSet );\r\n\t\tconst serialized = serialize( frames );\r\n\r\n\t\tconst buffer = generateSharedBuffer( frames, useSharedArrayBuffers );\r\n\t\tconst floatBuffer = new Float32Array( buffer );\r\n\t\tconst byteBuffer = new Uint8Array( buffer );\r\n\r\n\t\t// Filter all the frames down to joints that should be updated from\r\n\t\t// the worker.\r\n\t\tconst jointsToUpdate = [];\r\n\t\tconst jointsToIndexMap = new Map();\r\n\t\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst frame = frames[ i ];\r\n\t\t\tif ( frame.isJoint && frame.dof.length > 0 ) {\r\n\r\n\t\t\t\tjointsToUpdate.push( frame );\r\n\t\t\t\tjointsToIndexMap.set( frame, i );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( useSharedArrayBuffers ) {\r\n\r\n\t\t\tthis.buffer = buffer;\r\n\t\t\tthis.floatBuffer = floatBuffer;\r\n\t\t\tthis.byteBuffer = byteBuffer;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.buffer = buffer.slice();\r\n\t\t\tthis.floatBuffer = new Float32Array( this.buffer );\r\n\t\t\tthis.byteBuffer = new Uint8Array( this.buffer );\r\n\r\n\t\t}\r\n\r\n\t\tthis.frames = frames;\r\n\t\tthis.jointsToUpdate = jointsToUpdate;\r\n\t\tthis.jointsToIndexMap = jointsToIndexMap;\r\n\r\n\t\tif ( useSharedArrayBuffers ) {\r\n\r\n\t\t\tworker.postMessage( {\r\n\t\t\t\ttype: 'updateStructure',\r\n\t\t\t\tdata: {\r\n\t\t\t\t\tserialized,\r\n\t\t\t\t\tbuffer,\r\n\t\t\t\t},\r\n\t\t\t} );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tworker.postMessage( {\r\n\t\t\t\ttype: 'updateStructure',\r\n\t\t\t\tdata: {\r\n\t\t\t\t\tserialized,\r\n\t\t\t\t\tbuffer,\r\n\t\t\t\t},\r\n\t\t\t}, [ buffer ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Update the solver settings via a settings object.\r\n\tupdateSolverSettings( settings ) {\r\n\r\n\t\tthis.worker.postMessage( {\r\n\t\t\ttype: 'updateSolverSettings',\r\n\t\t\tdata: settings,\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t// Copy the non DoF values over to shared buffer for use in the worker\r\n\tupdateFrameState( ...updateJoints ) {\r\n\r\n\t\tconst { frames, floatBuffer, byteBuffer } = this;\r\n\t\tif ( updateJoints.length === 0 ) {\r\n\r\n\t\t\tapplyToBuffer( frames, floatBuffer, byteBuffer, false, true );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( let i = 0, l = updateJoints.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst frame = updateJoints[ i ];\r\n\t\t\t\tconst index = frames.indexOf( frame );\r\n\r\n\t\t\t\tcopyFrameToBuffer( frame, floatBuffer, byteBuffer, JOINT_STRIDE * index, false, true );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! useSharedArrayBuffers && ! this.scheduledStateUpdate ) {\r\n\r\n\t\t\tthis.scheduledStateUpdate = true;\r\n\t\t\tPromise.resolve().then( () => {\r\n\r\n\t\t\t\tthis.scheduledStateUpdate = false;\r\n\t\t\t\tconst buffer = this.buffer.slice();\r\n\t\t\t\tthis.worker.postMessage( {\r\n\t\t\t\t\ttype: 'updateFrameState',\r\n\t\t\t\t\tdata: {\r\n\t\t\t\t\t\tbuffer,\r\n\t\t\t\t\t},\r\n\t\t\t\t}, [ buffer ] );\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Start the solve loop if it's not running\r\n\tsolve() {\r\n\r\n\t\tthis.worker.postMessage( {\r\n\t\t\ttype: 'startSolve',\r\n\t\t} );\r\n\t\tthis.running = true;\r\n\r\n\t}\r\n\r\n\t// Stop the solve loop\r\n\tstop() {\r\n\r\n\t\tthis.worker.postMessage( {\r\n\t\t\ttype: 'stopSolve',\r\n\t\t} );\r\n\t\tthis.running = false;\r\n\r\n\t}\r\n\r\n\t// Stop and dispose the worker\r\n\tdispose() {\r\n\r\n\t\tthis.stop();\r\n\t\tthis.worker.terminate();\r\n\t\tthis.worker = null;\r\n\r\n\t}\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}