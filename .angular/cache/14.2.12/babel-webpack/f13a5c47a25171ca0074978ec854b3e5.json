{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Tile } from '../kernel_names';\nimport { add } from '../ops/add';\nimport { slice } from '../ops/slice';\nimport { zerosLike } from '../ops/zeros_like';\nexport const tileGradConfig = {\n  kernelName: Tile,\n  inputsToSave: ['x'],\n  gradFunc: (dy, saved, attrs) => {\n    const [x] = saved;\n    const {\n      reps\n    } = attrs;\n\n    const derX = () => {\n      let xGrad = zerosLike(x); // TODO(cais): Maybe reduce memory footprint by avoiding repeated\n      // slicing.\n\n      if (x.rank === 1) {\n        for (let i = 0; i < reps[0]; ++i) {\n          xGrad = add(xGrad, slice(dy, [i * x.shape[0]], [x.shape[0]]));\n        }\n      } else if (x.rank === 2) {\n        for (let i = 0; i < reps[0]; ++i) {\n          for (let j = 0; j < reps[1]; ++j) {\n            xGrad = add(xGrad, slice(dy, [i * x.shape[0], j * x.shape[1]], [x.shape[0], x.shape[1]]));\n          }\n        }\n      } else if (x.rank === 3) {\n        for (let i = 0; i < reps[0]; ++i) {\n          for (let j = 0; j < reps[1]; ++j) {\n            for (let k = 0; k < reps[2]; ++k) {\n              xGrad = add(xGrad, slice(dy, [i * x.shape[0], j * x.shape[1], k * x.shape[2]], [x.shape[0], x.shape[1], x.shape[2]]));\n            }\n          }\n        }\n      } else if (x.rank === 4) {\n        for (let i = 0; i < reps[0]; ++i) {\n          for (let j = 0; j < reps[1]; ++j) {\n            for (let k = 0; k < reps[2]; ++k) {\n              for (let l = 0; l < reps[3]; ++l) {\n                xGrad = add(xGrad, slice(dy, [i * x.shape[0], j * x.shape[1], k * x.shape[2], l * x.shape[3]], [x.shape[0], x.shape[1], x.shape[2], x.shape[3]]));\n              }\n            }\n          }\n        }\n      } else {\n        throw new Error(`Gradient for tile operation is not implemented for rank-` + `${x.rank} tensors yet.`);\n      }\n\n      return xGrad;\n    };\n\n    return {\n      x: derX\n    };\n  }\n};","map":{"version":3,"names":["Tile","add","slice","zerosLike","tileGradConfig","kernelName","inputsToSave","gradFunc","dy","saved","attrs","x","reps","derX","xGrad","rank","i","shape","j","k","l","Error"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-core/dist/gradients/Tile_grad.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Tile } from '../kernel_names';\nimport { add } from '../ops/add';\nimport { slice } from '../ops/slice';\nimport { zerosLike } from '../ops/zeros_like';\nexport const tileGradConfig = {\n    kernelName: Tile,\n    inputsToSave: ['x'],\n    gradFunc: (dy, saved, attrs) => {\n        const [x] = saved;\n        const { reps } = attrs;\n        const derX = () => {\n            let xGrad = zerosLike(x);\n            // TODO(cais): Maybe reduce memory footprint by avoiding repeated\n            // slicing.\n            if (x.rank === 1) {\n                for (let i = 0; i < reps[0]; ++i) {\n                    xGrad = add(xGrad, slice(dy, [i * x.shape[0]], [x.shape[0]]));\n                }\n            }\n            else if (x.rank === 2) {\n                for (let i = 0; i < reps[0]; ++i) {\n                    for (let j = 0; j < reps[1]; ++j) {\n                        xGrad = add(xGrad, slice(dy, [i * x.shape[0], j * x.shape[1]], [\n                            x.shape[0], x.shape[1]\n                        ]));\n                    }\n                }\n            }\n            else if (x.rank === 3) {\n                for (let i = 0; i < reps[0]; ++i) {\n                    for (let j = 0; j < reps[1]; ++j) {\n                        for (let k = 0; k < reps[2]; ++k) {\n                            xGrad =\n                                add(xGrad, slice(dy, [i * x.shape[0], j * x.shape[1], k * x.shape[2]], [x.shape[0], x.shape[1], x.shape[2]]));\n                        }\n                    }\n                }\n            }\n            else if (x.rank === 4) {\n                for (let i = 0; i < reps[0]; ++i) {\n                    for (let j = 0; j < reps[1]; ++j) {\n                        for (let k = 0; k < reps[2]; ++k) {\n                            for (let l = 0; l < reps[3]; ++l) {\n                                xGrad =\n                                    add(xGrad, slice(dy, [\n                                        i * x.shape[0], j * x.shape[1], k * x.shape[2],\n                                        l * x.shape[3]\n                                    ], [x.shape[0], x.shape[1], x.shape[2], x.shape[3]]));\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                throw new Error(`Gradient for tile operation is not implemented for rank-` +\n                    `${x.rank} tensors yet.`);\n            }\n            return xGrad;\n        };\n        return { x: derX };\n    },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}