{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class SliceProgram {\n  constructor(destSize) {\n    this.variableNames = ['source'];\n    this.outputShape = destSize;\n    this.rank = destSize.length;\n    const dtype = getCoordsDataType(this.rank);\n    this.customUniforms = [{\n      name: 'start',\n      arrayIndex: this.rank,\n      type: 'int'\n    }];\n    const sourceCoords = getCoords(this.rank);\n    let body;\n    const coordSum = destSize.map((_, i) => {\n      return `sourceLoc.${coords[i]} = start[${i}] + coords.${coords[i]};`;\n    });\n    body = `\n        ${dtype} sourceLoc;\n        ${dtype} coords = getOutputCoords();\n        ${coordSum.join('\\n')}\n      `;\n    this.userCode = `\n      void main() {\n        ${body}\n        setOutput(getSource(${sourceCoords}));\n      }\n    `;\n  }\n\n}\nconst coords = ['x', 'y', 'z', 'w', 'u', 'v'];\n\nfunction getCoords(rank) {\n  if (rank === 1) {\n    return 'sourceLoc';\n  } else if (rank <= 6) {\n    return coords.slice(0, rank).map(x => 'sourceLoc.' + x).join(',');\n  } else {\n    throw Error(`Slicing for rank ${rank} is not yet supported`);\n  }\n}","map":{"version":3,"names":["getCoordsDataType","SliceProgram","constructor","destSize","variableNames","outputShape","rank","length","dtype","customUniforms","name","arrayIndex","type","sourceCoords","getCoords","body","coordSum","map","_","i","coords","join","userCode","slice","x","Error"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-webgl/dist/slice_gpu.js"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class SliceProgram {\n    constructor(destSize) {\n        this.variableNames = ['source'];\n        this.outputShape = destSize;\n        this.rank = destSize.length;\n        const dtype = getCoordsDataType(this.rank);\n        this.customUniforms = [{ name: 'start', arrayIndex: this.rank, type: 'int' }];\n        const sourceCoords = getCoords(this.rank);\n        let body;\n        const coordSum = destSize.map((_, i) => {\n            return `sourceLoc.${coords[i]} = start[${i}] + coords.${coords[i]};`;\n        });\n        body = `\n        ${dtype} sourceLoc;\n        ${dtype} coords = getOutputCoords();\n        ${coordSum.join('\\n')}\n      `;\n        this.userCode = `\n      void main() {\n        ${body}\n        setOutput(getSource(${sourceCoords}));\n      }\n    `;\n    }\n}\nconst coords = ['x', 'y', 'z', 'w', 'u', 'v'];\nfunction getCoords(rank) {\n    if (rank === 1) {\n        return 'sourceLoc';\n    }\n    else if (rank <= 6) {\n        return coords.slice(0, rank).map(x => 'sourceLoc.' + x).join(',');\n    }\n    else {\n        throw Error(`Slicing for rank ${rank} is not yet supported`);\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,iBAAT,QAAkC,mBAAlC;AACA,OAAO,MAAMC,YAAN,CAAmB;EACtBC,WAAW,CAACC,QAAD,EAAW;IAClB,KAAKC,aAAL,GAAqB,CAAC,QAAD,CAArB;IACA,KAAKC,WAAL,GAAmBF,QAAnB;IACA,KAAKG,IAAL,GAAYH,QAAQ,CAACI,MAArB;IACA,MAAMC,KAAK,GAAGR,iBAAiB,CAAC,KAAKM,IAAN,CAA/B;IACA,KAAKG,cAAL,GAAsB,CAAC;MAAEC,IAAI,EAAE,OAAR;MAAiBC,UAAU,EAAE,KAAKL,IAAlC;MAAwCM,IAAI,EAAE;IAA9C,CAAD,CAAtB;IACA,MAAMC,YAAY,GAAGC,SAAS,CAAC,KAAKR,IAAN,CAA9B;IACA,IAAIS,IAAJ;IACA,MAAMC,QAAQ,GAAGb,QAAQ,CAACc,GAAT,CAAa,CAACC,CAAD,EAAIC,CAAJ,KAAU;MACpC,OAAQ,aAAYC,MAAM,CAACD,CAAD,CAAI,YAAWA,CAAE,cAAaC,MAAM,CAACD,CAAD,CAAI,GAAlE;IACH,CAFgB,CAAjB;IAGAJ,IAAI,GAAI;AAChB,UAAUP,KAAM;AAChB,UAAUA,KAAM;AAChB,UAAUQ,QAAQ,CAACK,IAAT,CAAc,IAAd,CAAoB;AAC9B,OAJQ;IAKA,KAAKC,QAAL,GAAiB;AACzB;AACA,UAAUP,IAAK;AACf,8BAA8BF,YAAa;AAC3C;AACA,KALQ;EAMH;;AAvBqB;AAyB1B,MAAMO,MAAM,GAAG,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,GAA1B,CAAf;;AACA,SAASN,SAAT,CAAmBR,IAAnB,EAAyB;EACrB,IAAIA,IAAI,KAAK,CAAb,EAAgB;IACZ,OAAO,WAAP;EACH,CAFD,MAGK,IAAIA,IAAI,IAAI,CAAZ,EAAe;IAChB,OAAOc,MAAM,CAACG,KAAP,CAAa,CAAb,EAAgBjB,IAAhB,EAAsBW,GAAtB,CAA0BO,CAAC,IAAI,eAAeA,CAA9C,EAAiDH,IAAjD,CAAsD,GAAtD,CAAP;EACH,CAFI,MAGA;IACD,MAAMI,KAAK,CAAE,oBAAmBnB,IAAK,uBAA1B,CAAX;EACH;AACJ"},"metadata":{},"sourceType":"module"}