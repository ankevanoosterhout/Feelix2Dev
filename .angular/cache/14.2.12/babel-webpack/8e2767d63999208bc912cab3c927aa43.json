{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { tidy, util } from '@tensorflow/tfjs-core'; // tslint:disable-next-line: no-imports-from-dist\n\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { getParamValue } from './utils';\nexport const executeOp = (node, tensorMap, context, ops = tfOps) => {\n  switch (node.op) {\n    case 'ConcatV2':\n    case 'Concat':\n      {\n        const n = getParamValue('n', node, tensorMap, context);\n        const axis = getParamValue('axis', node, tensorMap, context);\n        let inputs = getParamValue('tensors', node, tensorMap, context);\n        inputs = inputs.slice(0, n);\n        return [ops.concat(inputs, axis)];\n      }\n\n    case 'Gather':\n      {\n        const input = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [ops.gather(input, ops.cast(indices, 'int32'), 0)];\n      }\n\n    case 'GatherV2':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const batchDims = getParamValue('batchDims', node, tensorMap, context);\n        const input = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [ops.gather(input, ops.cast(indices, 'int32'), axis, batchDims)];\n      }\n\n    case 'Reverse':\n      {\n        const dims = getParamValue('dims', node, tensorMap, context);\n        const axis = [];\n\n        for (let i = 0; i < dims.length; i++) {\n          if (dims[i]) {\n            axis.push(i);\n          }\n        }\n\n        const input = getParamValue('x', node, tensorMap, context);\n        return [ops.reverse(input, axis)];\n      }\n\n    case 'ReverseV2':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const input = getParamValue('x', node, tensorMap, context);\n        return [ops.reverse(input, axis)];\n      }\n\n    case 'Slice':\n      {\n        // tslint:disable-next-line:no-any\n        const begin = getParamValue('begin', node, tensorMap, context); // tslint:disable-next-line:no-any\n\n        const size = getParamValue('size', node, tensorMap, context);\n        return [ops.slice(getParamValue('x', node, tensorMap, context), begin, size)];\n      }\n\n    case 'StridedSlice':\n      {\n        const begin = getParamValue('begin', node, tensorMap, context);\n        const end = getParamValue('end', node, tensorMap, context);\n        const strides = getParamValue('strides', node, tensorMap, context);\n        const beginMask = getParamValue('beginMask', node, tensorMap, context);\n        const endMask = getParamValue('endMask', node, tensorMap, context);\n        const ellipsisMask = getParamValue('ellipsisMask', node, tensorMap, context);\n        const newAxisMask = getParamValue('newAxisMask', node, tensorMap, context);\n        const shrinkAxisMask = getParamValue('shrinkAxisMask', node, tensorMap, context);\n        const tensor = getParamValue('x', node, tensorMap, context);\n        return [ops.stridedSlice(tensor, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];\n      }\n\n    case 'Pack':\n      {\n        return tidy(() => {\n          const axis = getParamValue('axis', node, tensorMap, context);\n          const tensors = getParamValue('tensors', node, tensorMap, context); // Reshape the tensors to the first tensor's shape if they don't\n          // match.\n\n          const shape = tensors[0].shape;\n          const squeezedShape = ops.squeeze(tensors[0]).shape;\n          const mapped = tensors.map(tensor => {\n            const sameShape = util.arraysEqual(tensor.shape, shape);\n\n            if (!sameShape && !util.arraysEqual(ops.squeeze(tensor).shape, squeezedShape)) {\n              throw new Error('the input tensors shape does not match');\n            }\n\n            return sameShape ? tensor : ops.reshape(tensor, shape);\n          });\n          return [ops.stack(mapped, axis)];\n        });\n      }\n\n    case 'Unpack':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const tensor = getParamValue('tensor', node, tensorMap, context);\n        return ops.unstack(tensor, axis);\n      }\n\n    case 'Tile':\n      {\n        const reps = getParamValue('reps', node, tensorMap, context);\n        return [ops.tile(getParamValue('x', node, tensorMap, context), reps)];\n      }\n\n    case 'Split':\n    case 'SplitV':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const numOrSizeSplits = getParamValue('numOrSizeSplits', node, tensorMap, context);\n        const tensor = getParamValue('x', node, tensorMap, context);\n        return ops.split(tensor, numOrSizeSplits, axis);\n      }\n\n    case 'ScatterNd':\n      {\n        const indices = getParamValue('indices', node, tensorMap, context);\n        const values = getParamValue('values', node, tensorMap, context);\n        const shape = getParamValue('shape', node, tensorMap, context);\n        return [ops.scatterND(indices, values, shape)];\n      }\n\n    case 'GatherNd':\n      {\n        const x = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [ops.gatherND(x, indices)];\n      }\n\n    case 'SparseToDense':\n      {\n        const indices = getParamValue('sparseIndices', node, tensorMap, context);\n        const shape = getParamValue('outputShape', node, tensorMap, context);\n        const sparseValues = getParamValue('sparseValues', node, tensorMap, context);\n        const defaultValue = getParamValue('defaultValue', node, tensorMap, context);\n        return [ops.sparseToDense(indices, sparseValues, shape, sparseValues.dtype === defaultValue.dtype ? defaultValue : ops.cast(defaultValue, sparseValues.dtype))];\n      }\n\n    default:\n      throw TypeError(`Node type ${node.op} is not implemented`);\n  }\n};\nexport const CATEGORY = 'slice_join';","map":{"version":3,"names":["tidy","util","tfOps","getParamValue","executeOp","node","tensorMap","context","ops","op","n","axis","inputs","slice","concat","input","indices","gather","cast","batchDims","dims","i","length","push","reverse","begin","size","end","strides","beginMask","endMask","ellipsisMask","newAxisMask","shrinkAxisMask","tensor","stridedSlice","tensors","shape","squeezedShape","squeeze","mapped","map","sameShape","arraysEqual","Error","reshape","stack","unstack","reps","tile","numOrSizeSplits","split","values","scatterND","x","gatherND","sparseValues","defaultValue","sparseToDense","dtype","TypeError","CATEGORY"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-converter/dist/operations/executors/slice_join_executor.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { tidy, util } from '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { getParamValue } from './utils';\nexport const executeOp = (node, tensorMap, context, ops = tfOps) => {\n    switch (node.op) {\n        case 'ConcatV2':\n        case 'Concat': {\n            const n = getParamValue('n', node, tensorMap, context);\n            const axis = getParamValue('axis', node, tensorMap, context);\n            let inputs = getParamValue('tensors', node, tensorMap, context);\n            inputs = inputs.slice(0, n);\n            return [ops.concat(inputs, axis)];\n        }\n        case 'Gather': {\n            const input = getParamValue('x', node, tensorMap, context);\n            const indices = getParamValue('indices', node, tensorMap, context);\n            return [ops.gather(input, ops.cast(indices, 'int32'), 0)];\n        }\n        case 'GatherV2': {\n            const axis = getParamValue('axis', node, tensorMap, context);\n            const batchDims = getParamValue('batchDims', node, tensorMap, context);\n            const input = getParamValue('x', node, tensorMap, context);\n            const indices = getParamValue('indices', node, tensorMap, context);\n            return [ops.gather(input, ops.cast(indices, 'int32'), axis, batchDims)];\n        }\n        case 'Reverse': {\n            const dims = getParamValue('dims', node, tensorMap, context);\n            const axis = [];\n            for (let i = 0; i < dims.length; i++) {\n                if (dims[i]) {\n                    axis.push(i);\n                }\n            }\n            const input = getParamValue('x', node, tensorMap, context);\n            return [ops.reverse(input, axis)];\n        }\n        case 'ReverseV2': {\n            const axis = getParamValue('axis', node, tensorMap, context);\n            const input = getParamValue('x', node, tensorMap, context);\n            return [ops.reverse(input, axis)];\n        }\n        case 'Slice': {\n            // tslint:disable-next-line:no-any\n            const begin = getParamValue('begin', node, tensorMap, context);\n            // tslint:disable-next-line:no-any\n            const size = getParamValue('size', node, tensorMap, context);\n            return [ops.slice(getParamValue('x', node, tensorMap, context), begin, size)];\n        }\n        case 'StridedSlice': {\n            const begin = getParamValue('begin', node, tensorMap, context);\n            const end = getParamValue('end', node, tensorMap, context);\n            const strides = getParamValue('strides', node, tensorMap, context);\n            const beginMask = getParamValue('beginMask', node, tensorMap, context);\n            const endMask = getParamValue('endMask', node, tensorMap, context);\n            const ellipsisMask = getParamValue('ellipsisMask', node, tensorMap, context);\n            const newAxisMask = getParamValue('newAxisMask', node, tensorMap, context);\n            const shrinkAxisMask = getParamValue('shrinkAxisMask', node, tensorMap, context);\n            const tensor = getParamValue('x', node, tensorMap, context);\n            return [ops.stridedSlice(tensor, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];\n        }\n        case 'Pack': {\n            return tidy(() => {\n                const axis = getParamValue('axis', node, tensorMap, context);\n                const tensors = getParamValue('tensors', node, tensorMap, context);\n                // Reshape the tensors to the first tensor's shape if they don't\n                // match.\n                const shape = tensors[0].shape;\n                const squeezedShape = ops.squeeze(tensors[0]).shape;\n                const mapped = tensors.map(tensor => {\n                    const sameShape = util.arraysEqual(tensor.shape, shape);\n                    if (!sameShape &&\n                        !util.arraysEqual(ops.squeeze(tensor).shape, squeezedShape)) {\n                        throw new Error('the input tensors shape does not match');\n                    }\n                    return sameShape ? tensor : ops.reshape(tensor, shape);\n                });\n                return [ops.stack(mapped, axis)];\n            });\n        }\n        case 'Unpack': {\n            const axis = getParamValue('axis', node, tensorMap, context);\n            const tensor = getParamValue('tensor', node, tensorMap, context);\n            return ops.unstack(tensor, axis);\n        }\n        case 'Tile': {\n            const reps = getParamValue('reps', node, tensorMap, context);\n            return [ops.tile(getParamValue('x', node, tensorMap, context), reps)];\n        }\n        case 'Split':\n        case 'SplitV': {\n            const axis = getParamValue('axis', node, tensorMap, context);\n            const numOrSizeSplits = getParamValue('numOrSizeSplits', node, tensorMap, context);\n            const tensor = getParamValue('x', node, tensorMap, context);\n            return ops.split(tensor, numOrSizeSplits, axis);\n        }\n        case 'ScatterNd': {\n            const indices = getParamValue('indices', node, tensorMap, context);\n            const values = getParamValue('values', node, tensorMap, context);\n            const shape = getParamValue('shape', node, tensorMap, context);\n            return [ops.scatterND(indices, values, shape)];\n        }\n        case 'GatherNd': {\n            const x = getParamValue('x', node, tensorMap, context);\n            const indices = getParamValue('indices', node, tensorMap, context);\n            return [ops.gatherND(x, indices)];\n        }\n        case 'SparseToDense': {\n            const indices = getParamValue('sparseIndices', node, tensorMap, context);\n            const shape = getParamValue('outputShape', node, tensorMap, context);\n            const sparseValues = getParamValue('sparseValues', node, tensorMap, context);\n            const defaultValue = getParamValue('defaultValue', node, tensorMap, context);\n            return [ops.sparseToDense(indices, sparseValues, shape, sparseValues.dtype === defaultValue.dtype ?\n                    defaultValue :\n                    ops.cast(defaultValue, sparseValues.dtype))];\n        }\n        default:\n            throw TypeError(`Node type ${node.op} is not implemented`);\n    }\n};\nexport const CATEGORY = 'slice_join';\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}