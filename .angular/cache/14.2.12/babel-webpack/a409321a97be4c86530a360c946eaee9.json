{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nexport function sparseSegmentReductionImpl(input, inputShape, inputDType, indices, segmentIds, isMean = false, defaultValue = 0) {\n  const numIndices = indices.length; // Flatten the array to two dimensions\n\n  const inputFlat = [inputShape[0], input.length / inputShape[0]];\n  const numCol = inputFlat[1]; // Note that the current implementation assumes that segmentIds values are\n  // sorted.\n\n  const lastSegmentIdPlusOne = numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;\n  const outputRows = lastSegmentIdPlusOne;\n\n  if (outputRows < 0) {\n    throw new Error(backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());\n  }\n\n  const outputShape = inputShape.slice();\n  outputShape[0] = outputRows;\n  const outputLength = outputShape.reduce((product, value) => product * value, 1); // Output array is initialized with the value 0 by default.\n\n  const output = util.getArrayFromDType(inputDType, outputLength); // Note that we do not initialize the output buffer with a default value, so\n  // we need to explicitly set missing indices to the default value.\n\n  if (numIndices === 0) {\n    if (outputRows > 0) {\n      output.fill(defaultValue);\n    }\n\n    return [output, outputShape];\n  }\n\n  if (outputRows <= 0) {\n    throw new Error(backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());\n  }\n\n  let start = 0,\n      end = 1; // Index from which the output is not initialized.\n\n  let uninitializedIndex = 0;\n  let outIndex = segmentIds[start];\n\n  while (true) {\n    // We initialize nextIndex to 0 to avoid may be uninitialized warning\n    let nextIndex = 0;\n\n    if (end < numIndices) {\n      nextIndex = segmentIds[end];\n\n      if (outIndex === nextIndex) {\n        ++end;\n        continue;\n      } // We have a new segment here.  Verify that the segment ids are growing.\n\n\n      if (outIndex >= nextIndex) {\n        throw new Error(backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage());\n      }\n    }\n\n    if (outIndex < 0 || outIndex >= outputRows) {\n      throw new Error(backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(outIndex, outputRows));\n    } // If there is a gap between two indices, we need to set that gap to the\n    // default value.\n\n\n    if (outIndex > uninitializedIndex) {\n      output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);\n    }\n\n    for (let i = start; i < end; ++i) {\n      const index = indices[i];\n\n      if (index < 0 || index >= inputFlat[0]) {\n        throw new Error(backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(i, indices[i], inputFlat[0]));\n      }\n\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] += input[index * numCol + j];\n      }\n    }\n\n    if (isMean) {\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] /= end - start;\n      }\n    }\n\n    start = end;\n    ++end;\n    uninitializedIndex = outIndex + 1;\n    outIndex = nextIndex;\n\n    if (end > numIndices) {\n      break;\n    }\n  } // Fill the gap at the end with the default value.\n\n\n  if (uninitializedIndex < outputRows) {\n    output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);\n  }\n\n  return [output, outputShape];\n}","map":{"version":3,"names":["backend_util","util","sparseSegmentReductionImpl","input","inputShape","inputDType","indices","segmentIds","isMean","defaultValue","numIndices","length","inputFlat","numCol","lastSegmentIdPlusOne","outputRows","Error","getSparseSegmentReductionNegativeSegmentIdsErrorMessage","outputShape","slice","outputLength","reduce","product","value","output","getArrayFromDType","fill","start","end","uninitializedIndex","outIndex","nextIndex","getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage","getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage","i","index","getSparseSegmentReductionIndicesOutOfRangeErrorMessage","j"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseSegmentReduction_impl.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nexport function sparseSegmentReductionImpl(input, inputShape, inputDType, indices, segmentIds, isMean = false, defaultValue = 0) {\n    const numIndices = indices.length;\n    // Flatten the array to two dimensions\n    const inputFlat = [inputShape[0], input.length / inputShape[0]];\n    const numCol = inputFlat[1];\n    // Note that the current implementation assumes that segmentIds values are\n    // sorted.\n    const lastSegmentIdPlusOne = numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;\n    const outputRows = lastSegmentIdPlusOne;\n    if (outputRows < 0) {\n        throw new Error(backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());\n    }\n    const outputShape = inputShape.slice();\n    outputShape[0] = outputRows;\n    const outputLength = outputShape.reduce((product, value) => product * value, 1);\n    // Output array is initialized with the value 0 by default.\n    const output = util.getArrayFromDType(inputDType, outputLength);\n    // Note that we do not initialize the output buffer with a default value, so\n    // we need to explicitly set missing indices to the default value.\n    if (numIndices === 0) {\n        if (outputRows > 0) {\n            output.fill(defaultValue);\n        }\n        return [output, outputShape];\n    }\n    if (outputRows <= 0) {\n        throw new Error(backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());\n    }\n    let start = 0, end = 1;\n    // Index from which the output is not initialized.\n    let uninitializedIndex = 0;\n    let outIndex = segmentIds[start];\n    while (true) {\n        // We initialize nextIndex to 0 to avoid may be uninitialized warning\n        let nextIndex = 0;\n        if (end < numIndices) {\n            nextIndex = segmentIds[end];\n            if (outIndex === nextIndex) {\n                ++end;\n                continue;\n            }\n            // We have a new segment here.  Verify that the segment ids are growing.\n            if (outIndex >= nextIndex) {\n                throw new Error(backend_util\n                    .getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage());\n            }\n        }\n        if (outIndex < 0 || outIndex >= outputRows) {\n            throw new Error(backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(outIndex, outputRows));\n        }\n        // If there is a gap between two indices, we need to set that gap to the\n        // default value.\n        if (outIndex > uninitializedIndex) {\n            output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);\n        }\n        for (let i = start; i < end; ++i) {\n            const index = indices[i];\n            if (index < 0 || index >= inputFlat[0]) {\n                throw new Error(backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(i, indices[i], inputFlat[0]));\n            }\n            for (let j = 0; j < numCol; j++) {\n                output[outIndex * numCol + j] += input[index * numCol + j];\n            }\n        }\n        if (isMean) {\n            for (let j = 0; j < numCol; j++) {\n                output[outIndex * numCol + j] /= end - start;\n            }\n        }\n        start = end;\n        ++end;\n        uninitializedIndex = outIndex + 1;\n        outIndex = nextIndex;\n        if (end > numIndices) {\n            break;\n        }\n    }\n    // Fill the gap at the end with the default value.\n    if (uninitializedIndex < outputRows) {\n        output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);\n    }\n    return [output, outputShape];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}