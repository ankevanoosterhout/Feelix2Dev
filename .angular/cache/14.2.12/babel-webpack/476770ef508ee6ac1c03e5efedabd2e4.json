{"ast":null,"code":"import { ChainSolver } from './ChainSolver.js';\nimport { findRoots } from './utils/findRoots.js';\nimport { MatrixPool } from './MatrixPool.js';\nexport class Solver {\n  constructor(roots = []) {\n    this.matrixPool = new MatrixPool();\n    this.useSVD = false;\n    this.maxIterations = 5;\n    this.stallThreshold = 1e-4;\n    this.dampingFactor = 0.001;\n    this.divergeThreshold = 0.01;\n    this.restPoseFactor = 0.01;\n    this.translationConvergeThreshold = 1e-3;\n    this.rotationConvergeThreshold = 1e-5;\n    this.translationFactor = 1;\n    this.rotationFactor = 1;\n    this.translationStep = 1e-3;\n    this.rotationStep = 1e-3;\n    this.translationErrorClamp = 0.1;\n    this.rotationErrorClamp = 0.1;\n    this.roots = Array.isArray(roots) ? [...roots] : [roots];\n    this.solvers = null;\n    this.updateStructure();\n  } // needs to be called whenever tree structure is updated\n\n\n  updateStructure() {\n    const roots = findRoots(this.roots);\n    const chains = [];\n    const traversal = new Set();\n    const allChainJoints = new Set();\n\n    const traverseChains = frame => {\n      // If we found a joint then add it to the traversal list\n      if (frame.isJoint) {\n        const joint = frame;\n        traversal.add(joint); // If we found a closure joint\n\n        if (joint.isClosure) {\n          // Traverse back up the tree until we find a common ancestor\n          // and create a new chain\n          const chainSet = new Set();\n          let curr = joint.child;\n\n          while (curr) {\n            if (curr.isJoint) {\n              if (traversal.has(curr)) {\n                break;\n              } else {\n                chainSet.add(curr);\n                allChainJoints.add(curr);\n              }\n            }\n\n            curr = curr.parent;\n          }\n\n          traversal.forEach(c => {\n            chainSet.add(c);\n            allChainJoints.add(c);\n          });\n          chains.push(chainSet);\n        }\n      } // Continue traversing\n\n\n      const children = frame.children;\n\n      for (let i = 0, l = children.length; i < l; i++) {\n        traverseChains(children[i]);\n      } // Remove the joint from our traversal set\n\n\n      traversal.delete(frame);\n    }; // find all chains in the roots\n\n\n    roots.forEach(traverseChains); // Merge interdependent chains\n\n    const independentChains = [];\n\n    while (chains.length) {\n      const currChain = chains.pop();\n      independentChains.push(currChain);\n\n      for (let i = 0; i < chains.length; i++) {\n        // see if this chain is dependent on the current chain\n        // and if so merge the chains.\n        const otherChain = chains[i];\n        let dependent = false;\n        otherChain.forEach(c => {\n          dependent = dependent || currChain.has(c);\n        });\n\n        if (dependent) {\n          otherChain.forEach(c => currChain.add(c));\n          chains.splice(i, 1);\n          i--;\n        }\n      }\n    } // Find any joints that aren't considered part of a solve chain so we\n    // can just update them using forward kinematics.\n\n\n    const nonChainJoints = new Set();\n    roots.forEach(root => root.traverse(c => {\n      if (c.isJoint && c.dof.length > 0 && !allChainJoints.has(c)) {\n        nonChainJoints.add(c);\n      }\n    })); // Create the solvers for the chains\n\n    this.solvers = independentChains.map(c => new ChainSolver(c));\n    this.nonChainJoints = nonChainJoints;\n  }\n\n  solve() {\n    const {\n      solvers,\n      nonChainJoints\n    } = this; // update any non chain joints\n\n    nonChainJoints.forEach(joint => {\n      if (joint.targetSet) {\n        joint.dofValues.set(joint.dofTarget);\n        joint.setMatrixDoFNeedsUpdate();\n      }\n    });\n    const results = [];\n\n    for (let i = 0, l = solvers.length; i < l; i++) {\n      const s = solvers[i];\n      s.matrixPool = this.matrixPool;\n      s.useSVD = this.useSVD;\n      s.maxIterations = this.maxIterations;\n      s.stallThreshold = this.stallThreshold;\n      s.dampingFactor = this.dampingFactor;\n      s.divergeThreshold = this.divergeThreshold;\n      s.restPoseFactor = this.restPoseFactor;\n      s.translationConvergeThreshold = this.translationConvergeThreshold;\n      s.rotationConvergeThreshold = this.rotationConvergeThreshold;\n      s.translationFactor = this.translationFactor;\n      s.rotationFactor = this.rotationFactor;\n      s.translationStep = this.translationStep;\n      s.rotationStep = this.rotationStep;\n      s.translationErrorClamp = this.translationErrorClamp;\n      s.rotationErrorClamp = this.rotationErrorClamp;\n      const result = s.solve();\n      results.push(result);\n    }\n\n    return results;\n  }\n\n}","map":{"version":3,"names":["ChainSolver","findRoots","MatrixPool","Solver","constructor","roots","matrixPool","useSVD","maxIterations","stallThreshold","dampingFactor","divergeThreshold","restPoseFactor","translationConvergeThreshold","rotationConvergeThreshold","translationFactor","rotationFactor","translationStep","rotationStep","translationErrorClamp","rotationErrorClamp","Array","isArray","solvers","updateStructure","chains","traversal","Set","allChainJoints","traverseChains","frame","isJoint","joint","add","isClosure","chainSet","curr","child","has","parent","forEach","c","push","children","i","l","length","delete","independentChains","currChain","pop","otherChain","dependent","splice","nonChainJoints","root","traverse","dof","map","solve","targetSet","dofValues","set","dofTarget","setMatrixDoFNeedsUpdate","results","s","result"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/closed-chain-ik/src/core/Solver.js"],"sourcesContent":["import { ChainSolver } from './ChainSolver.js';\r\nimport { findRoots } from './utils/findRoots.js';\r\nimport { MatrixPool } from './MatrixPool.js';\r\n\r\nexport class Solver {\r\n\r\n\tconstructor( roots = [] ) {\r\n\r\n\t\tthis.matrixPool = new MatrixPool();\r\n\r\n\t\tthis.useSVD = false;\r\n\r\n\t\tthis.maxIterations = 5;\r\n\t\tthis.stallThreshold = 1e-4;\r\n\t\tthis.dampingFactor = 0.001;\r\n\t\tthis.divergeThreshold = 0.01;\r\n\t\tthis.restPoseFactor = 0.01;\r\n\r\n\t\tthis.translationConvergeThreshold = 1e-3;\r\n\t\tthis.rotationConvergeThreshold = 1e-5;\r\n\r\n\t\tthis.translationFactor = 1;\r\n\t\tthis.rotationFactor = 1;\r\n\r\n\t\tthis.translationStep = 1e-3;\r\n\t\tthis.rotationStep = 1e-3;\r\n\r\n\t\tthis.translationErrorClamp = 0.1;\r\n\t\tthis.rotationErrorClamp = 0.1;\r\n\r\n\t\tthis.roots = Array.isArray( roots ) ? [ ...roots ] : [ roots ];\r\n\t\tthis.solvers = null;\r\n\r\n\t\tthis.updateStructure();\r\n\r\n\t}\r\n\r\n\t// needs to be called whenever tree structure is updated\r\n\tupdateStructure() {\r\n\r\n\t\tconst roots = findRoots( this.roots );\r\n\t\tconst chains = [];\r\n\t\tconst traversal = new Set();\r\n\t\tconst allChainJoints = new Set();\r\n\t\tconst traverseChains = frame => {\r\n\r\n\t\t\t// If we found a joint then add it to the traversal list\r\n\t\t\tif ( frame.isJoint ) {\r\n\r\n\t\t\t\tconst joint = frame;\r\n\t\t\t\ttraversal.add( joint );\r\n\r\n\t\t\t\t// If we found a closure joint\r\n\t\t\t\tif ( joint.isClosure ) {\r\n\r\n\t\t\t\t\t// Traverse back up the tree until we find a common ancestor\r\n\t\t\t\t\t// and create a new chain\r\n\t\t\t\t\tconst chainSet = new Set();\r\n\t\t\t\t\tlet curr = joint.child;\r\n\t\t\t\t\twhile ( curr ) {\r\n\r\n\t\t\t\t\t\tif ( curr.isJoint ) {\r\n\r\n\t\t\t\t\t\t\tif ( traversal.has( curr ) ) {\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tchainSet.add( curr );\r\n\t\t\t\t\t\t\t\tallChainJoints.add( curr );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcurr = curr.parent;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttraversal.forEach( c => {\r\n\r\n\t\t\t\t\t\tchainSet.add( c );\r\n\t\t\t\t\t\tallChainJoints.add( c );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tchains.push( chainSet );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Continue traversing\r\n\t\t\tconst children = frame.children;\r\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\ttraverseChains( children[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Remove the joint from our traversal set\r\n\t\t\ttraversal.delete( frame );\r\n\r\n\t\t};\r\n\r\n\t\t// find all chains in the roots\r\n\t\troots.forEach( traverseChains );\r\n\r\n\t\t// Merge interdependent chains\r\n\t\tconst independentChains = [];\r\n\t\twhile ( chains.length ) {\r\n\r\n\t\t\tconst currChain = chains.pop();\r\n\t\t\tindependentChains.push( currChain );\r\n\t\t\tfor ( let i = 0; i < chains.length; i ++ ) {\r\n\r\n\t\t\t\t// see if this chain is dependent on the current chain\r\n\t\t\t\t// and if so merge the chains.\r\n\t\t\t\tconst otherChain = chains[ i ];\r\n\r\n\t\t\t\tlet dependent = false;\r\n\t\t\t\totherChain.forEach( c => {\r\n\r\n\t\t\t\t\tdependent = dependent || currChain.has( c );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tif ( dependent ) {\r\n\r\n\t\t\t\t\totherChain.forEach( c => currChain.add( c ) );\r\n\t\t\t\t\tchains.splice( i, 1 );\r\n\t\t\t\t\ti --;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Find any joints that aren't considered part of a solve chain so we\r\n\t\t// can just update them using forward kinematics.\r\n\t\tconst nonChainJoints = new Set();\r\n\t\troots.forEach( root => root.traverse( c => {\r\n\r\n\t\t\tif ( c.isJoint && c.dof.length > 0 && ! allChainJoints.has( c ) ) {\r\n\r\n\t\t\t\tnonChainJoints.add( c );\r\n\r\n\t\t\t}\r\n\r\n\t\t} ) );\r\n\r\n\t\t// Create the solvers for the chains\r\n\t\tthis.solvers = independentChains.map( c => new ChainSolver( c ) );\r\n\t\tthis.nonChainJoints = nonChainJoints;\r\n\r\n\t}\r\n\r\n\tsolve() {\r\n\r\n\t\tconst { solvers, nonChainJoints } = this;\r\n\r\n\t\t// update any non chain joints\r\n\t\tnonChainJoints.forEach( joint => {\r\n\r\n\t\t\tif ( joint.targetSet ) {\r\n\r\n\t\t\t\tjoint.dofValues.set( joint.dofTarget );\r\n\t\t\t\tjoint.setMatrixDoFNeedsUpdate();\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tconst results = [];\r\n\t\tfor ( let i = 0, l = solvers.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst s = solvers[ i ];\r\n\t\t\ts.matrixPool = this.matrixPool;\r\n\r\n\t\t\ts.useSVD = this.useSVD;\r\n\r\n\t\t\ts.maxIterations = this.maxIterations;\r\n\t\t\ts.stallThreshold = this.stallThreshold;\r\n\t\t\ts.dampingFactor = this.dampingFactor;\r\n\t\t\ts.divergeThreshold = this.divergeThreshold;\r\n\t\t\ts.restPoseFactor = this.restPoseFactor;\r\n\r\n\t\t\ts.translationConvergeThreshold = this.translationConvergeThreshold;\r\n\t\t\ts.rotationConvergeThreshold = this.rotationConvergeThreshold;\r\n\r\n\t\t\ts.translationFactor = this.translationFactor;\r\n\t\t\ts.rotationFactor = this.rotationFactor;\r\n\r\n\t\t\ts.translationStep = this.translationStep;\r\n\t\t\ts.rotationStep = this.rotationStep;\r\n\r\n\t\t\ts.translationErrorClamp = this.translationErrorClamp;\r\n\t\t\ts.rotationErrorClamp = this.rotationErrorClamp;\r\n\r\n\t\t\tconst result = s.solve();\r\n\t\t\tresults.push( result );\r\n\r\n\t\t}\r\n\r\n\t\treturn results;\r\n\r\n\t}\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}