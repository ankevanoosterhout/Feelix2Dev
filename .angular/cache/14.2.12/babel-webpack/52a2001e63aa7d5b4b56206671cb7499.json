{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { SparseReshape } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport { op } from '../operation';\n/**\n * This operation has the same semantics as reshape on the represented dense\n * tensor. The `inputIndices` are recomputed based on the requested `newShape`.\n * If one component of `newShape` is the special value -1, the size of that\n * dimension is computed so that the total dense size remains constant. At most\n * one component of `newShape` can be -1. The number of dense elements implied\n * by `newShape` must be the same as the number of dense elements originally\n * implied by `inputShape`. Reshaping does not affect the order of values in the\n * SparseTensor. If the input tensor has rank R_in and N non-empty values, and\n * `newShape` has length R_out, then `inputIndices` has shape [N, R_in],\n * `inputShape` has length R_in, `outputIndices` has shape [N, R_out], and\n * `outputShape` has length R_out.\n *\n * ```js\n * const result = tf.sparse.sparseReshape(\n *   [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 2, 3]],\n *   [2, 3, 6], [9, -1]);\n * console.log(result);\n * result['outputIndices'].print(); //[[0, 0], [0, 1], [1, 2], [4, 2], [8, 1]]\n * result['outputShape'].print(); // [9, 4]\n * ```\n * @param inputIndices: 2-D. N x R_in matrix with the indices of non-empty\n * values in a SparseTensor.\n * @param inputShape: 1-D. R_in Tensor1D with the input SparseTensor's dense\n * shape.\n * @param newShape: 1-D. R_out Tensor1D with the requested new dense shape.\n * @return A map with the following properties:\n *     - outputIndices: 2-D. N x R_out matrix with the updated indices of\n *       non-empty values in the output SparseTensor.\n *     - outputShape: 1-D. R_out vector with the full dense shape of the output\n *       SparseTensor. This is the same as newShape but with any -1 dimensions\n *        filled in.\n * @doc {heading: 'Operations', subheading: 'Sparse'}\n */\n\nfunction sparseReshape_(inputIndices, inputShape, newShape) {\n  const $inputIndices = convertToTensor(inputIndices, 'inputIndices', 'sparseReshape', 'int32');\n  const $inputShape = convertToTensor(inputShape, 'inputShape', 'sparseReshape', 'int32');\n  const $newShape = convertToTensor(newShape, 'newShape', 'sparseReshape', 'int32');\n\n  if ($inputIndices.rank !== 2) {\n    throw new Error(`Input indices should be Tensor2D but received shape\n        ${$inputIndices.shape}`);\n  }\n\n  if ($inputShape.rank !== 1) {\n    throw new Error(`Input shape should be Tensor1D but received shape ${$inputShape.shape}`);\n  }\n\n  if ($newShape.rank !== 1) {\n    throw new Error(`New shape should be Tensor1D but received shape ${$newShape.shape}`);\n  }\n\n  const inputs = {\n    inputIndices: $inputIndices,\n    inputShape: $inputShape,\n    newShape: $newShape\n  };\n  const result = ENGINE.runKernel(SparseReshape, inputs);\n  return {\n    outputIndices: result[0],\n    outputShape: result[1]\n  };\n}\n\nexport const sparseReshape = op({\n  sparseReshape_\n});","map":{"version":3,"names":["ENGINE","SparseReshape","convertToTensor","op","sparseReshape_","inputIndices","inputShape","newShape","$inputIndices","$inputShape","$newShape","rank","Error","shape","inputs","result","runKernel","outputIndices","outputShape","sparseReshape"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_reshape.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { SparseReshape } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport { op } from '../operation';\n/**\n * This operation has the same semantics as reshape on the represented dense\n * tensor. The `inputIndices` are recomputed based on the requested `newShape`.\n * If one component of `newShape` is the special value -1, the size of that\n * dimension is computed so that the total dense size remains constant. At most\n * one component of `newShape` can be -1. The number of dense elements implied\n * by `newShape` must be the same as the number of dense elements originally\n * implied by `inputShape`. Reshaping does not affect the order of values in the\n * SparseTensor. If the input tensor has rank R_in and N non-empty values, and\n * `newShape` has length R_out, then `inputIndices` has shape [N, R_in],\n * `inputShape` has length R_in, `outputIndices` has shape [N, R_out], and\n * `outputShape` has length R_out.\n *\n * ```js\n * const result = tf.sparse.sparseReshape(\n *   [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 2, 3]],\n *   [2, 3, 6], [9, -1]);\n * console.log(result);\n * result['outputIndices'].print(); //[[0, 0], [0, 1], [1, 2], [4, 2], [8, 1]]\n * result['outputShape'].print(); // [9, 4]\n * ```\n * @param inputIndices: 2-D. N x R_in matrix with the indices of non-empty\n * values in a SparseTensor.\n * @param inputShape: 1-D. R_in Tensor1D with the input SparseTensor's dense\n * shape.\n * @param newShape: 1-D. R_out Tensor1D with the requested new dense shape.\n * @return A map with the following properties:\n *     - outputIndices: 2-D. N x R_out matrix with the updated indices of\n *       non-empty values in the output SparseTensor.\n *     - outputShape: 1-D. R_out vector with the full dense shape of the output\n *       SparseTensor. This is the same as newShape but with any -1 dimensions\n *        filled in.\n * @doc {heading: 'Operations', subheading: 'Sparse'}\n */\nfunction sparseReshape_(inputIndices, inputShape, newShape) {\n    const $inputIndices = convertToTensor(inputIndices, 'inputIndices', 'sparseReshape', 'int32');\n    const $inputShape = convertToTensor(inputShape, 'inputShape', 'sparseReshape', 'int32');\n    const $newShape = convertToTensor(newShape, 'newShape', 'sparseReshape', 'int32');\n    if ($inputIndices.rank !== 2) {\n        throw new Error(`Input indices should be Tensor2D but received shape\n        ${$inputIndices.shape}`);\n    }\n    if ($inputShape.rank !== 1) {\n        throw new Error(`Input shape should be Tensor1D but received shape ${$inputShape.shape}`);\n    }\n    if ($newShape.rank !== 1) {\n        throw new Error(`New shape should be Tensor1D but received shape ${$newShape.shape}`);\n    }\n    const inputs = {\n        inputIndices: $inputIndices,\n        inputShape: $inputShape,\n        newShape: $newShape\n    };\n    const result = ENGINE.runKernel(SparseReshape, inputs);\n    return { outputIndices: result[0], outputShape: result[1] };\n}\nexport const sparseReshape = op({ sparseReshape_ });\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAT,QAAuB,cAAvB;AACA,SAASC,aAAT,QAA8B,oBAA9B;AACA,SAASC,eAAT,QAAgC,uBAAhC;AACA,SAASC,EAAT,QAAmB,cAAnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,cAAT,CAAwBC,YAAxB,EAAsCC,UAAtC,EAAkDC,QAAlD,EAA4D;EACxD,MAAMC,aAAa,GAAGN,eAAe,CAACG,YAAD,EAAe,cAAf,EAA+B,eAA/B,EAAgD,OAAhD,CAArC;EACA,MAAMI,WAAW,GAAGP,eAAe,CAACI,UAAD,EAAa,YAAb,EAA2B,eAA3B,EAA4C,OAA5C,CAAnC;EACA,MAAMI,SAAS,GAAGR,eAAe,CAACK,QAAD,EAAW,UAAX,EAAuB,eAAvB,EAAwC,OAAxC,CAAjC;;EACA,IAAIC,aAAa,CAACG,IAAd,KAAuB,CAA3B,EAA8B;IAC1B,MAAM,IAAIC,KAAJ,CAAW;AACzB,UAAUJ,aAAa,CAACK,KAAM,EADhB,CAAN;EAEH;;EACD,IAAIJ,WAAW,CAACE,IAAZ,KAAqB,CAAzB,EAA4B;IACxB,MAAM,IAAIC,KAAJ,CAAW,qDAAoDH,WAAW,CAACI,KAAM,EAAjF,CAAN;EACH;;EACD,IAAIH,SAAS,CAACC,IAAV,KAAmB,CAAvB,EAA0B;IACtB,MAAM,IAAIC,KAAJ,CAAW,mDAAkDF,SAAS,CAACG,KAAM,EAA7E,CAAN;EACH;;EACD,MAAMC,MAAM,GAAG;IACXT,YAAY,EAAEG,aADH;IAEXF,UAAU,EAAEG,WAFD;IAGXF,QAAQ,EAAEG;EAHC,CAAf;EAKA,MAAMK,MAAM,GAAGf,MAAM,CAACgB,SAAP,CAAiBf,aAAjB,EAAgCa,MAAhC,CAAf;EACA,OAAO;IAAEG,aAAa,EAAEF,MAAM,CAAC,CAAD,CAAvB;IAA4BG,WAAW,EAAEH,MAAM,CAAC,CAAD;EAA/C,CAAP;AACH;;AACD,OAAO,MAAMI,aAAa,GAAGhB,EAAE,CAAC;EAAEC;AAAF,CAAD,CAAxB"},"metadata":{},"sourceType":"module"}