{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * Common functions for TensorFlow.js Layers.\n */\nimport { VALID_DATA_FORMAT_VALUES, VALID_INTERPOLATION_FORMAT_VALUES, VALID_PADDING_MODE_VALUES, VALID_POOL_MODE_VALUES } from './keras_format/common';\nimport { checkStringTypeUnionValue } from './utils/generic_utils'; // A map from the requested scoped name of a Tensor to the number of Tensors\n// wanting that name so far.  This allows enforcing name uniqueness by appending\n// an incrementing index, e.g. scope/name, scope/name_1, scope/name_2, etc.\n\nconst nameMap = new Map();\nexport function checkDataFormat(value) {\n  checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES, 'DataFormat', value);\n}\nexport function checkInterpolationFormat(value) {\n  checkStringTypeUnionValue(VALID_INTERPOLATION_FORMAT_VALUES, 'InterpolationFormat', value);\n}\nexport function checkPaddingMode(value) {\n  checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES, 'PaddingMode', value);\n}\nexport function checkPoolMode(value) {\n  checkStringTypeUnionValue(VALID_POOL_MODE_VALUES, 'PoolMode', value);\n}\nconst _nameScopeStack = [];\nconst _nameScopeDivider = '/';\n/**\n * Enter namescope, which can be nested.\n */\n\nexport function nameScope(name, fn) {\n  _nameScopeStack.push(name);\n\n  try {\n    const val = fn();\n\n    _nameScopeStack.pop();\n\n    return val;\n  } catch (e) {\n    _nameScopeStack.pop();\n\n    throw e;\n  }\n}\n/**\n * Get the current namescope as a flat, concatenated string.\n */\n\nfunction currentNameScopePrefix() {\n  if (_nameScopeStack.length === 0) {\n    return '';\n  } else {\n    return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;\n  }\n}\n/**\n * Get the name a Tensor (or Variable) would have if not uniqueified.\n * @param tensorName\n * @return Scoped name string.\n */\n\n\nexport function getScopedTensorName(tensorName) {\n  if (!isValidTensorName(tensorName)) {\n    throw new Error('Not a valid tensor name: \\'' + tensorName + '\\'');\n  }\n\n  return currentNameScopePrefix() + tensorName;\n}\n/**\n * Get unique names for Tensors and Variables.\n * @param scopedName The fully-qualified name of the Tensor, i.e. as produced by\n *  `getScopedTensorName()`.\n * @return A unique version of the given fully scoped name.\n *   If this is the first time that the scoped name is seen in this session,\n *   then the given `scopedName` is returned unaltered.  If the same name is\n *   seen again (producing a collision), an incrementing suffix is added to the\n *   end of the name, so it takes the form 'scope/name_1', 'scope/name_2', etc.\n */\n\nexport function getUniqueTensorName(scopedName) {\n  if (!isValidTensorName(scopedName)) {\n    throw new Error('Not a valid tensor name: \\'' + scopedName + '\\'');\n  }\n\n  if (!nameMap.has(scopedName)) {\n    nameMap.set(scopedName, 0);\n  }\n\n  const index = nameMap.get(scopedName);\n  nameMap.set(scopedName, nameMap.get(scopedName) + 1);\n\n  if (index > 0) {\n    const result = `${scopedName}_${index}`; // Mark the composed name as used in case someone wants\n    // to call getUniqueTensorName(\"name_1\").\n\n    nameMap.set(result, 1);\n    return result;\n  } else {\n    return scopedName;\n  }\n}\nconst tensorNameRegex = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\\._\\/]*$/);\n/**\n * Determine whether a string is a valid tensor name.\n * @param name\n * @returns A Boolean indicating whether `name` is a valid tensor name.\n */\n\nexport function isValidTensorName(name) {\n  return !!name.match(tensorNameRegex);\n}","map":{"version":3,"names":["VALID_DATA_FORMAT_VALUES","VALID_INTERPOLATION_FORMAT_VALUES","VALID_PADDING_MODE_VALUES","VALID_POOL_MODE_VALUES","checkStringTypeUnionValue","nameMap","Map","checkDataFormat","value","checkInterpolationFormat","checkPaddingMode","checkPoolMode","_nameScopeStack","_nameScopeDivider","nameScope","name","fn","push","val","pop","e","currentNameScopePrefix","length","join","getScopedTensorName","tensorName","isValidTensorName","Error","getUniqueTensorName","scopedName","has","set","index","get","result","tensorNameRegex","RegExp","match"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-layers/dist/common.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Common functions for TensorFlow.js Layers.\n */\nimport { VALID_DATA_FORMAT_VALUES, VALID_INTERPOLATION_FORMAT_VALUES, VALID_PADDING_MODE_VALUES, VALID_POOL_MODE_VALUES } from './keras_format/common';\nimport { checkStringTypeUnionValue } from './utils/generic_utils';\n// A map from the requested scoped name of a Tensor to the number of Tensors\n// wanting that name so far.  This allows enforcing name uniqueness by appending\n// an incrementing index, e.g. scope/name, scope/name_1, scope/name_2, etc.\nconst nameMap = new Map();\nexport function checkDataFormat(value) {\n    checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES, 'DataFormat', value);\n}\nexport function checkInterpolationFormat(value) {\n    checkStringTypeUnionValue(VALID_INTERPOLATION_FORMAT_VALUES, 'InterpolationFormat', value);\n}\nexport function checkPaddingMode(value) {\n    checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES, 'PaddingMode', value);\n}\nexport function checkPoolMode(value) {\n    checkStringTypeUnionValue(VALID_POOL_MODE_VALUES, 'PoolMode', value);\n}\nconst _nameScopeStack = [];\nconst _nameScopeDivider = '/';\n/**\n * Enter namescope, which can be nested.\n */\nexport function nameScope(name, fn) {\n    _nameScopeStack.push(name);\n    try {\n        const val = fn();\n        _nameScopeStack.pop();\n        return val;\n    }\n    catch (e) {\n        _nameScopeStack.pop();\n        throw e;\n    }\n}\n/**\n * Get the current namescope as a flat, concatenated string.\n */\nfunction currentNameScopePrefix() {\n    if (_nameScopeStack.length === 0) {\n        return '';\n    }\n    else {\n        return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;\n    }\n}\n/**\n * Get the name a Tensor (or Variable) would have if not uniqueified.\n * @param tensorName\n * @return Scoped name string.\n */\nexport function getScopedTensorName(tensorName) {\n    if (!isValidTensorName(tensorName)) {\n        throw new Error('Not a valid tensor name: \\'' + tensorName + '\\'');\n    }\n    return currentNameScopePrefix() + tensorName;\n}\n/**\n * Get unique names for Tensors and Variables.\n * @param scopedName The fully-qualified name of the Tensor, i.e. as produced by\n *  `getScopedTensorName()`.\n * @return A unique version of the given fully scoped name.\n *   If this is the first time that the scoped name is seen in this session,\n *   then the given `scopedName` is returned unaltered.  If the same name is\n *   seen again (producing a collision), an incrementing suffix is added to the\n *   end of the name, so it takes the form 'scope/name_1', 'scope/name_2', etc.\n */\nexport function getUniqueTensorName(scopedName) {\n    if (!isValidTensorName(scopedName)) {\n        throw new Error('Not a valid tensor name: \\'' + scopedName + '\\'');\n    }\n    if (!nameMap.has(scopedName)) {\n        nameMap.set(scopedName, 0);\n    }\n    const index = nameMap.get(scopedName);\n    nameMap.set(scopedName, nameMap.get(scopedName) + 1);\n    if (index > 0) {\n        const result = `${scopedName}_${index}`;\n        // Mark the composed name as used in case someone wants\n        // to call getUniqueTensorName(\"name_1\").\n        nameMap.set(result, 1);\n        return result;\n    }\n    else {\n        return scopedName;\n    }\n}\nconst tensorNameRegex = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\\._\\/]*$/);\n/**\n * Determine whether a string is a valid tensor name.\n * @param name\n * @returns A Boolean indicating whether `name` is a valid tensor name.\n */\nexport function isValidTensorName(name) {\n    return !!name.match(tensorNameRegex);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}