{"ast":null,"code":"import { convertToTensor } from '../../tensor_util_env';\nimport { cast } from '../cast';\nimport { div } from '../div';\nimport { Reduction } from '../loss_ops_utils';\nimport { mean } from '../mean';\nimport { mul } from '../mul';\nimport { notEqual } from '../not_equal';\nimport { ones } from '../ones';\nimport { op } from '../operation';\nimport { scalar } from '../scalar';\nimport { sum } from '../sum';\n/**\n * Computes the weighted loss between two tensors.\n *\n * @param losses Tensor of shape `[batch_size, d1, ..., dN]`.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `losses`, and must be broadcastable to `losses` (i.e., all\n *    dimensions must be either `1`, or the same as the corresponding\n *    `losses` dimension).\n *\n * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}\n */\n\nfunction computeWeightedLoss_(losses, weights, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {\n  const $losses = convertToTensor(losses, 'losses', 'computeWeightedLoss');\n  let $weights = null;\n\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'computeWeightedLoss');\n  }\n\n  const weightedLoss = $weights == null ? $losses : mul($losses, $weights);\n\n  if (reduction === Reduction.NONE) {\n    return weightedLoss;\n  }\n\n  if (reduction === Reduction.SUM) {\n    return sum(weightedLoss);\n  }\n\n  if (reduction === Reduction.MEAN) {\n    if ($weights == null) {\n      return mean(weightedLoss);\n    } else {\n      const broadcastFactor = $losses.size / $weights.size;\n      const result = div(sum(weightedLoss), sum($weights));\n      return broadcastFactor > 1 ? div(result, scalar(broadcastFactor)) : result;\n    }\n  }\n\n  if (reduction === Reduction.SUM_BY_NONZERO_WEIGHTS) {\n    if ($weights == null) {\n      return div(sum(weightedLoss), scalar($losses.size));\n    } else {\n      const broadcastedWeights = mul($weights, ones($losses.shape));\n      const numNonZeros = cast(sum(notEqual(broadcastedWeights, scalar(0))), 'float32');\n      return div(sum(weightedLoss), numNonZeros);\n    }\n  }\n\n  throw Error(`Unknown reduction: ${reduction}`);\n}\n\nexport const computeWeightedLoss = op({\n  computeWeightedLoss_\n});","map":{"version":3,"names":["convertToTensor","cast","div","Reduction","mean","mul","notEqual","ones","op","scalar","sum","computeWeightedLoss_","losses","weights","reduction","SUM_BY_NONZERO_WEIGHTS","$losses","$weights","weightedLoss","NONE","SUM","MEAN","broadcastFactor","size","result","broadcastedWeights","shape","numNonZeros","Error","computeWeightedLoss"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-core/dist/ops/losses/compute_weighted_loss.js"],"sourcesContent":["import { convertToTensor } from '../../tensor_util_env';\nimport { cast } from '../cast';\nimport { div } from '../div';\nimport { Reduction } from '../loss_ops_utils';\nimport { mean } from '../mean';\nimport { mul } from '../mul';\nimport { notEqual } from '../not_equal';\nimport { ones } from '../ones';\nimport { op } from '../operation';\nimport { scalar } from '../scalar';\nimport { sum } from '../sum';\n/**\n * Computes the weighted loss between two tensors.\n *\n * @param losses Tensor of shape `[batch_size, d1, ..., dN]`.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `losses`, and must be broadcastable to `losses` (i.e., all\n *    dimensions must be either `1`, or the same as the corresponding\n *    `losses` dimension).\n *\n * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}\n */\nfunction computeWeightedLoss_(losses, weights, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {\n    const $losses = convertToTensor(losses, 'losses', 'computeWeightedLoss');\n    let $weights = null;\n    if (weights != null) {\n        $weights = convertToTensor(weights, 'weights', 'computeWeightedLoss');\n    }\n    const weightedLoss = ($weights == null) ? $losses : mul($losses, $weights);\n    if (reduction === Reduction.NONE) {\n        return weightedLoss;\n    }\n    if (reduction === Reduction.SUM) {\n        return sum(weightedLoss);\n    }\n    if (reduction === Reduction.MEAN) {\n        if ($weights == null) {\n            return mean(weightedLoss);\n        }\n        else {\n            const broadcastFactor = $losses.size / $weights.size;\n            const result = div(sum(weightedLoss), sum($weights));\n            return broadcastFactor > 1 ? div(result, scalar(broadcastFactor)) :\n                result;\n        }\n    }\n    if (reduction === Reduction.SUM_BY_NONZERO_WEIGHTS) {\n        if ($weights == null) {\n            return div(sum(weightedLoss), scalar($losses.size));\n        }\n        else {\n            const broadcastedWeights = mul($weights, ones($losses.shape));\n            const numNonZeros = cast(sum(notEqual(broadcastedWeights, scalar(0))), 'float32');\n            return div(sum(weightedLoss), numNonZeros);\n        }\n    }\n    throw Error(`Unknown reduction: ${reduction}`);\n}\nexport const computeWeightedLoss = op({ computeWeightedLoss_ });\n"],"mappings":"AAAA,SAASA,eAAT,QAAgC,uBAAhC;AACA,SAASC,IAAT,QAAqB,SAArB;AACA,SAASC,GAAT,QAAoB,QAApB;AACA,SAASC,SAAT,QAA0B,mBAA1B;AACA,SAASC,IAAT,QAAqB,SAArB;AACA,SAASC,GAAT,QAAoB,QAApB;AACA,SAASC,QAAT,QAAyB,cAAzB;AACA,SAASC,IAAT,QAAqB,SAArB;AACA,SAASC,EAAT,QAAmB,cAAnB;AACA,SAASC,MAAT,QAAuB,WAAvB;AACA,SAASC,GAAT,QAAoB,QAApB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,oBAAT,CAA8BC,MAA9B,EAAsCC,OAAtC,EAA+CC,SAAS,GAAGX,SAAS,CAACY,sBAArE,EAA6F;EACzF,MAAMC,OAAO,GAAGhB,eAAe,CAACY,MAAD,EAAS,QAAT,EAAmB,qBAAnB,CAA/B;EACA,IAAIK,QAAQ,GAAG,IAAf;;EACA,IAAIJ,OAAO,IAAI,IAAf,EAAqB;IACjBI,QAAQ,GAAGjB,eAAe,CAACa,OAAD,EAAU,SAAV,EAAqB,qBAArB,CAA1B;EACH;;EACD,MAAMK,YAAY,GAAID,QAAQ,IAAI,IAAb,GAAqBD,OAArB,GAA+BX,GAAG,CAACW,OAAD,EAAUC,QAAV,CAAvD;;EACA,IAAIH,SAAS,KAAKX,SAAS,CAACgB,IAA5B,EAAkC;IAC9B,OAAOD,YAAP;EACH;;EACD,IAAIJ,SAAS,KAAKX,SAAS,CAACiB,GAA5B,EAAiC;IAC7B,OAAOV,GAAG,CAACQ,YAAD,CAAV;EACH;;EACD,IAAIJ,SAAS,KAAKX,SAAS,CAACkB,IAA5B,EAAkC;IAC9B,IAAIJ,QAAQ,IAAI,IAAhB,EAAsB;MAClB,OAAOb,IAAI,CAACc,YAAD,CAAX;IACH,CAFD,MAGK;MACD,MAAMI,eAAe,GAAGN,OAAO,CAACO,IAAR,GAAeN,QAAQ,CAACM,IAAhD;MACA,MAAMC,MAAM,GAAGtB,GAAG,CAACQ,GAAG,CAACQ,YAAD,CAAJ,EAAoBR,GAAG,CAACO,QAAD,CAAvB,CAAlB;MACA,OAAOK,eAAe,GAAG,CAAlB,GAAsBpB,GAAG,CAACsB,MAAD,EAASf,MAAM,CAACa,eAAD,CAAf,CAAzB,GACHE,MADJ;IAEH;EACJ;;EACD,IAAIV,SAAS,KAAKX,SAAS,CAACY,sBAA5B,EAAoD;IAChD,IAAIE,QAAQ,IAAI,IAAhB,EAAsB;MAClB,OAAOf,GAAG,CAACQ,GAAG,CAACQ,YAAD,CAAJ,EAAoBT,MAAM,CAACO,OAAO,CAACO,IAAT,CAA1B,CAAV;IACH,CAFD,MAGK;MACD,MAAME,kBAAkB,GAAGpB,GAAG,CAACY,QAAD,EAAWV,IAAI,CAACS,OAAO,CAACU,KAAT,CAAf,CAA9B;MACA,MAAMC,WAAW,GAAG1B,IAAI,CAACS,GAAG,CAACJ,QAAQ,CAACmB,kBAAD,EAAqBhB,MAAM,CAAC,CAAD,CAA3B,CAAT,CAAJ,EAA+C,SAA/C,CAAxB;MACA,OAAOP,GAAG,CAACQ,GAAG,CAACQ,YAAD,CAAJ,EAAoBS,WAApB,CAAV;IACH;EACJ;;EACD,MAAMC,KAAK,CAAE,sBAAqBd,SAAU,EAAjC,CAAX;AACH;;AACD,OAAO,MAAMe,mBAAmB,GAAGrB,EAAE,CAAC;EAAEG;AAAF,CAAD,CAA9B"},"metadata":{},"sourceType":"module"}