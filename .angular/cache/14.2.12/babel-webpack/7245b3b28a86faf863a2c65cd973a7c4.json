{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { getInternalFormatForFloat16MatrixTexture, getInternalFormatForFloat16PackedMatrixTexture, getInternalFormatForFloat32MatrixTexture, getInternalFormatForPackedMatrixTexture, getInternalFormatForUnsignedBytesMatrixTexture } from './gpgpu_util';\nimport { getPackedMatrixTextureShapeWidthHeight, getUnpackedMatrixTextureShapeWidthHeight, PhysicalTextureType, TextureUsage } from './tex_util';\nexport class TextureManager {\n  constructor(gpgpu) {\n    this.gpgpu = gpgpu;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n    this._numBytesAllocated = 0;\n    this._numBytesFree = 0; // How many bytes that have been allocated\n    // are available for reuse.\n\n    this.freeTextures = {};\n    this.logEnabled = false;\n    this.usedTextures = {};\n  }\n\n  acquireTexture(shapeRC, usage, isPacked) {\n    const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n    const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n\n    if (!(shapeKey in this.usedTextures)) {\n      this.usedTextures[shapeKey] = [];\n    }\n\n    const texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n\n    if (this.freeTextures[shapeKey].length > 0) {\n      this.numFreeTextures--;\n      this.numUsedTextures++;\n      this._numBytesFree -= texBytes;\n      this.log();\n      const newTexture = this.freeTextures[shapeKey].shift();\n      this.usedTextures[shapeKey].push(newTexture);\n      return newTexture;\n    }\n\n    let newTexture;\n\n    if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n      newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n      newTexture = this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n      newTexture = this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n      newTexture = this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n      newTexture = this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n    }\n\n    this.usedTextures[shapeKey].push(newTexture);\n    this.numUsedTextures++;\n    this._numBytesAllocated += texBytes;\n    this.log();\n    return newTexture;\n  }\n\n  releaseTexture(texture, shape, logicalTexType, isPacked) {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n\n    const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n    const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n\n    const texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n    const deleteTexThreshold = env().get('WEBGL_DELETE_TEXTURE_THRESHOLD');\n\n    if (deleteTexThreshold !== -1 && this._numBytesAllocated > deleteTexThreshold) {\n      this.gpgpu.deleteMatrixTexture(texture.texture);\n      this._numBytesAllocated -= texBytes;\n    } else {\n      this.freeTextures[shapeKey].push(texture);\n      this.numFreeTextures++;\n      this._numBytesFree += texBytes;\n    }\n\n    this.numUsedTextures--;\n    const texList = this.usedTextures[shapeKey];\n    const texIndex = texList.indexOf(texture);\n\n    if (texIndex < 0) {\n      throw new Error('Cannot release a texture that was never provided by this ' + 'texture manager');\n    }\n\n    texList.splice(texIndex, 1);\n    this.log();\n  }\n\n  log() {\n    if (!this.logEnabled) {\n      return;\n    }\n\n    const total = this.numFreeTextures + this.numUsedTextures;\n    console.log('Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${total})`);\n    const freeRatio = this._numBytesFree / this._numBytesAllocated;\n    console.log(`Bytes allocated: ${this._numBytesAllocated}`);\n    console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * freeRatio)}%)`);\n  }\n\n  get numBytesAllocated() {\n    return this._numBytesAllocated;\n  }\n\n  get numBytesFree() {\n    return this._numBytesFree;\n  }\n\n  getNumUsedTextures() {\n    return this.numUsedTextures;\n  }\n\n  getNumFreeTextures() {\n    return this.numFreeTextures;\n  }\n\n  dispose() {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n\n    for (const texShape in this.freeTextures) {\n      this.freeTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex.texture);\n      });\n    }\n\n    for (const texShape in this.usedTextures) {\n      this.usedTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex.texture);\n      });\n    }\n\n    this.freeTextures = null;\n    this.usedTextures = null;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n    this._numBytesAllocated = 0;\n    this._numBytesFree = 0;\n  }\n\n}\n\nfunction numBytesForInternalFormat(gl, internalFormat) {\n  // tslint:disable-next-line:no-any\n  const glany = gl;\n\n  if (internalFormat === glany.R32F) {\n    return 4;\n  } else if (internalFormat === glany.R16F) {\n    return 2;\n  } else if (internalFormat === glany.RGBA32F) {\n    return 16;\n  } else if (internalFormat === gl.RGBA) {\n    return 16;\n  } else if (internalFormat === glany.RGBA16F) {\n    return 8;\n  } else if (internalFormat === glany.RGBA8) {\n    return 4;\n  }\n\n  throw new Error(`Unknown internal format ${internalFormat}`);\n}\n\nexport function computeBytes(shape, physicalTexType, gl, textureConfig, isPacked) {\n  // It is not possible to infer packed status from the texture type because\n  // depending on the textureConfig, different  texture types may resolve to the\n  // same internal format (e.g. in WebGL1, the internal format for\n  // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`\n  // explicitly.\n  const internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);\n  let numElements;\n\n  if (isPacked) {\n    const [packedWidth, packedHeight] = getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n    numElements = packedWidth * packedHeight;\n  } else {\n    const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n    numElements = width * height;\n  }\n\n  const bytesPerElement = numBytesForInternalFormat(gl, internalFormat);\n  return numElements * bytesPerElement;\n}\n\nfunction internalFormatForPhysicalTexType(physicalTexType, textureConfig) {\n  switch (physicalTexType) {\n    case PhysicalTextureType.PACKED_2X2_FLOAT32:\n      return getInternalFormatForPackedMatrixTexture(textureConfig);\n\n    case PhysicalTextureType.PACKED_2X2_FLOAT16:\n      return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);\n\n    case PhysicalTextureType.UNPACKED_FLOAT32:\n      return getInternalFormatForFloat32MatrixTexture(textureConfig);\n\n    case PhysicalTextureType.UNPACKED_FLOAT16:\n      return getInternalFormatForFloat16MatrixTexture(textureConfig);\n\n    case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:\n      return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);\n\n    default:\n      throw new Error(`Unknown physical texture type ${physicalTexType}`);\n  }\n}\n\nfunction getPhysicalTextureForRendering(isPacked) {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n    if (isPacked) {\n      return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n\n    return PhysicalTextureType.UNPACKED_FLOAT32;\n  }\n\n  if (isPacked) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT16;\n  }\n\n  return PhysicalTextureType.UNPACKED_FLOAT16;\n}\n\nfunction getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {\n  if (logicalTexType === TextureUsage.UPLOAD) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT32;\n  } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n    return getPhysicalTextureForRendering(isPacked);\n  } else if (logicalTexType === TextureUsage.DOWNLOAD || logicalTexType === TextureUsage.PIXELS) {\n    return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n  }\n\n  throw new Error(`Unknown logical texture type ${logicalTexType}`);\n}\n\nfunction getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {\n  return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;\n}","map":{"version":3,"names":["env","getInternalFormatForFloat16MatrixTexture","getInternalFormatForFloat16PackedMatrixTexture","getInternalFormatForFloat32MatrixTexture","getInternalFormatForPackedMatrixTexture","getInternalFormatForUnsignedBytesMatrixTexture","getPackedMatrixTextureShapeWidthHeight","getUnpackedMatrixTextureShapeWidthHeight","PhysicalTextureType","TextureUsage","TextureManager","constructor","gpgpu","numUsedTextures","numFreeTextures","_numBytesAllocated","_numBytesFree","freeTextures","logEnabled","usedTextures","acquireTexture","shapeRC","usage","isPacked","physicalTexType","getPhysicalFromLogicalTextureType","shapeKey","getKeyFromTextureShape","texBytes","computeBytes","gl","textureConfig","length","log","newTexture","shift","push","PACKED_2X2_FLOAT32","createPackedMatrixTexture","PACKED_2X2_FLOAT16","createFloat16PackedMatrixTexture","UNPACKED_FLOAT32","createFloat32MatrixTexture","UNPACKED_FLOAT16","createFloat16MatrixTexture","PACKED_4X1_UNSIGNED_BYTE","createUnsignedBytesMatrixTexture","releaseTexture","texture","shape","logicalTexType","deleteTexThreshold","get","deleteMatrixTexture","texList","texIndex","indexOf","Error","splice","total","console","freeRatio","Math","round","numBytesAllocated","numBytesFree","getNumUsedTextures","getNumFreeTextures","dispose","texShape","forEach","tex","numBytesForInternalFormat","internalFormat","glany","R32F","R16F","RGBA32F","RGBA","RGBA16F","RGBA8","internalFormatForPhysicalTexType","numElements","packedWidth","packedHeight","width","height","bytesPerElement","getPhysicalTextureForRendering","getBool","UPLOAD","RENDER","DOWNLOAD","PIXELS","shapeRowsCol"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-webgl/dist/texture_manager.js"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { getInternalFormatForFloat16MatrixTexture, getInternalFormatForFloat16PackedMatrixTexture, getInternalFormatForFloat32MatrixTexture, getInternalFormatForPackedMatrixTexture, getInternalFormatForUnsignedBytesMatrixTexture } from './gpgpu_util';\nimport { getPackedMatrixTextureShapeWidthHeight, getUnpackedMatrixTextureShapeWidthHeight, PhysicalTextureType, TextureUsage } from './tex_util';\nexport class TextureManager {\n    constructor(gpgpu) {\n        this.gpgpu = gpgpu;\n        this.numUsedTextures = 0;\n        this.numFreeTextures = 0;\n        this._numBytesAllocated = 0;\n        this._numBytesFree = 0; // How many bytes that have been allocated\n        // are available for reuse.\n        this.freeTextures = {};\n        this.logEnabled = false;\n        this.usedTextures = {};\n    }\n    acquireTexture(shapeRC, usage, isPacked) {\n        const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n        const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n        if (!(shapeKey in this.freeTextures)) {\n            this.freeTextures[shapeKey] = [];\n        }\n        if (!(shapeKey in this.usedTextures)) {\n            this.usedTextures[shapeKey] = [];\n        }\n        const texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n        if (this.freeTextures[shapeKey].length > 0) {\n            this.numFreeTextures--;\n            this.numUsedTextures++;\n            this._numBytesFree -= texBytes;\n            this.log();\n            const newTexture = this.freeTextures[shapeKey].shift();\n            this.usedTextures[shapeKey].push(newTexture);\n            return newTexture;\n        }\n        let newTexture;\n        if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n            newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n            newTexture =\n                this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n            newTexture =\n                this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n            newTexture =\n                this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n            newTexture =\n                this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        this.usedTextures[shapeKey].push(newTexture);\n        this.numUsedTextures++;\n        this._numBytesAllocated += texBytes;\n        this.log();\n        return newTexture;\n    }\n    releaseTexture(texture, shape, logicalTexType, isPacked) {\n        if (this.freeTextures == null) {\n            // Already disposed.\n            return;\n        }\n        const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n        const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n        if (!(shapeKey in this.freeTextures)) {\n            this.freeTextures[shapeKey] = [];\n        }\n        const texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n        const deleteTexThreshold = env().get('WEBGL_DELETE_TEXTURE_THRESHOLD');\n        if (deleteTexThreshold !== -1 &&\n            this._numBytesAllocated > deleteTexThreshold) {\n            this.gpgpu.deleteMatrixTexture(texture.texture);\n            this._numBytesAllocated -= texBytes;\n        }\n        else {\n            this.freeTextures[shapeKey].push(texture);\n            this.numFreeTextures++;\n            this._numBytesFree += texBytes;\n        }\n        this.numUsedTextures--;\n        const texList = this.usedTextures[shapeKey];\n        const texIndex = texList.indexOf(texture);\n        if (texIndex < 0) {\n            throw new Error('Cannot release a texture that was never provided by this ' +\n                'texture manager');\n        }\n        texList.splice(texIndex, 1);\n        this.log();\n    }\n    log() {\n        if (!this.logEnabled) {\n            return;\n        }\n        const total = this.numFreeTextures + this.numUsedTextures;\n        console.log('Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${total})`);\n        const freeRatio = this._numBytesFree / this._numBytesAllocated;\n        console.log(`Bytes allocated: ${this._numBytesAllocated}`);\n        console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * freeRatio)}%)`);\n    }\n    get numBytesAllocated() {\n        return this._numBytesAllocated;\n    }\n    get numBytesFree() {\n        return this._numBytesFree;\n    }\n    getNumUsedTextures() {\n        return this.numUsedTextures;\n    }\n    getNumFreeTextures() {\n        return this.numFreeTextures;\n    }\n    dispose() {\n        if (this.freeTextures == null) {\n            // Already disposed.\n            return;\n        }\n        for (const texShape in this.freeTextures) {\n            this.freeTextures[texShape].forEach(tex => {\n                this.gpgpu.deleteMatrixTexture(tex.texture);\n            });\n        }\n        for (const texShape in this.usedTextures) {\n            this.usedTextures[texShape].forEach(tex => {\n                this.gpgpu.deleteMatrixTexture(tex.texture);\n            });\n        }\n        this.freeTextures = null;\n        this.usedTextures = null;\n        this.numUsedTextures = 0;\n        this.numFreeTextures = 0;\n        this._numBytesAllocated = 0;\n        this._numBytesFree = 0;\n    }\n}\nfunction numBytesForInternalFormat(gl, internalFormat) {\n    // tslint:disable-next-line:no-any\n    const glany = gl;\n    if (internalFormat === glany.R32F) {\n        return 4;\n    }\n    else if (internalFormat === glany.R16F) {\n        return 2;\n    }\n    else if (internalFormat === glany.RGBA32F) {\n        return 16;\n    }\n    else if (internalFormat === gl.RGBA) {\n        return 16;\n    }\n    else if (internalFormat === glany.RGBA16F) {\n        return 8;\n    }\n    else if (internalFormat === glany.RGBA8) {\n        return 4;\n    }\n    throw new Error(`Unknown internal format ${internalFormat}`);\n}\nexport function computeBytes(shape, physicalTexType, gl, textureConfig, isPacked) {\n    // It is not possible to infer packed status from the texture type because\n    // depending on the textureConfig, different  texture types may resolve to the\n    // same internal format (e.g. in WebGL1, the internal format for\n    // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`\n    // explicitly.\n    const internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);\n    let numElements;\n    if (isPacked) {\n        const [packedWidth, packedHeight] = getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n        numElements = packedWidth * packedHeight;\n    }\n    else {\n        const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n        numElements = width * height;\n    }\n    const bytesPerElement = numBytesForInternalFormat(gl, internalFormat);\n    return numElements * bytesPerElement;\n}\nfunction internalFormatForPhysicalTexType(physicalTexType, textureConfig) {\n    switch (physicalTexType) {\n        case PhysicalTextureType.PACKED_2X2_FLOAT32:\n            return getInternalFormatForPackedMatrixTexture(textureConfig);\n        case PhysicalTextureType.PACKED_2X2_FLOAT16:\n            return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);\n        case PhysicalTextureType.UNPACKED_FLOAT32:\n            return getInternalFormatForFloat32MatrixTexture(textureConfig);\n        case PhysicalTextureType.UNPACKED_FLOAT16:\n            return getInternalFormatForFloat16MatrixTexture(textureConfig);\n        case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:\n            return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);\n        default:\n            throw new Error(`Unknown physical texture type ${physicalTexType}`);\n    }\n}\nfunction getPhysicalTextureForRendering(isPacked) {\n    if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n        if (isPacked) {\n            return PhysicalTextureType.PACKED_2X2_FLOAT32;\n        }\n        return PhysicalTextureType.UNPACKED_FLOAT32;\n    }\n    if (isPacked) {\n        return PhysicalTextureType.PACKED_2X2_FLOAT16;\n    }\n    return PhysicalTextureType.UNPACKED_FLOAT16;\n}\nfunction getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {\n    if (logicalTexType === TextureUsage.UPLOAD) {\n        return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n    else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n        return getPhysicalTextureForRendering(isPacked);\n    }\n    else if (logicalTexType === TextureUsage.DOWNLOAD ||\n        logicalTexType === TextureUsage.PIXELS) {\n        return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n    }\n    throw new Error(`Unknown logical texture type ${logicalTexType}`);\n}\nfunction getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {\n    return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}