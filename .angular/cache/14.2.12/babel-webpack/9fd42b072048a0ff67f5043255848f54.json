{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { nearestDivisor } from '../util';\nimport { PARALLELIZE_THRESHOLD } from './reduce_util';\nexport function segOpComputeOptimalWindowSize(inSize, numSegments) {\n  let done = false;\n  let res;\n\n  if (inSize <= PARALLELIZE_THRESHOLD) {\n    res = inSize;\n    done = true;\n  } else {\n    res = nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));\n  }\n\n  while (!done) {\n    if (res > numSegments || res === inSize) {\n      done = true;\n    } else {\n      res = nearestDivisor(inSize, res + 1);\n    }\n  }\n\n  return res;\n}\nexport function computeOutShape(aShape, axis, numSegments) {\n  const outShape = [];\n  const rank = aShape.length;\n\n  for (let dim = 0; dim < rank; dim++) {\n    if (dim !== axis) {\n      outShape.push(aShape[dim]);\n    } else {\n      outShape.push(numSegments);\n    }\n  }\n\n  return outShape;\n}\nexport function collectGatherOpShapeInfo(x, indices, axis, batchDims) {\n  const indicesRank = indices.shape.length;\n  const xRank = x.shape.length;\n\n  if (batchDims !== 0) {\n    if (batchDims < -indicesRank || batchDims > indicesRank) {\n      throw new Error(`Expect batchDims in the range of [-${indicesRank}, ${indicesRank}], but got ${batchDims}`);\n    }\n  }\n\n  if (batchDims < 0) {\n    batchDims += indicesRank;\n  }\n\n  if (batchDims > xRank) {\n    throw new Error(`batchDims (${batchDims}) must be less than rank(x) (\n    ${xRank}).`);\n  }\n\n  if (axis < batchDims) {\n    throw new Error(`batchDims (${batchDims}) must be less than or equal to axis (${axis}).`);\n  }\n\n  for (let i = 0; i < batchDims; ++i) {\n    if (x.shape[i] !== indices.shape[i]) {\n      throw new Error(`x.shape[${i}]: ${x.shape[i]} should be equal to indices.shape[${i}]: ${indices.shape[i]}.`);\n    }\n  }\n\n  const dimSize = x.shape[axis];\n  const outputShape = [];\n  let batchSize = 1;\n  let outerSize = 1;\n  let sliceSize = 1;\n\n  for (let i = 0; i < batchDims; ++i) {\n    outputShape.push(x.shape[i]);\n    batchSize *= x.shape[i];\n  }\n\n  for (let i = batchDims; i < axis; i++) {\n    outputShape.push(x.shape[i]);\n    outerSize *= x.shape[i];\n  }\n\n  for (let i = batchDims; i < indicesRank; i++) {\n    outputShape.push(indices.shape[i]);\n  }\n\n  for (let i = axis + 1; i < xRank; i++) {\n    outputShape.push(x.shape[i]);\n    sliceSize *= x.shape[i];\n  }\n\n  return {\n    batchSize,\n    sliceSize,\n    outerSize,\n    dimSize,\n    outputShape\n  };\n}","map":{"version":3,"names":["nearestDivisor","PARALLELIZE_THRESHOLD","segOpComputeOptimalWindowSize","inSize","numSegments","done","res","Math","floor","sqrt","computeOutShape","aShape","axis","outShape","rank","length","dim","push","collectGatherOpShapeInfo","x","indices","batchDims","indicesRank","shape","xRank","Error","i","dimSize","outputShape","batchSize","outerSize","sliceSize"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-core/dist/ops/segment_util.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { nearestDivisor } from '../util';\nimport { PARALLELIZE_THRESHOLD } from './reduce_util';\nexport function segOpComputeOptimalWindowSize(inSize, numSegments) {\n    let done = false;\n    let res;\n    if (inSize <= PARALLELIZE_THRESHOLD) {\n        res = inSize;\n        done = true;\n    }\n    else {\n        res = nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));\n    }\n    while (!done) {\n        if (res > numSegments || res === inSize) {\n            done = true;\n        }\n        else {\n            res = nearestDivisor(inSize, res + 1);\n        }\n    }\n    return res;\n}\nexport function computeOutShape(aShape, axis, numSegments) {\n    const outShape = [];\n    const rank = aShape.length;\n    for (let dim = 0; dim < rank; dim++) {\n        if (dim !== axis) {\n            outShape.push(aShape[dim]);\n        }\n        else {\n            outShape.push(numSegments);\n        }\n    }\n    return outShape;\n}\nexport function collectGatherOpShapeInfo(x, indices, axis, batchDims) {\n    const indicesRank = indices.shape.length;\n    const xRank = x.shape.length;\n    if (batchDims !== 0) {\n        if (batchDims < -indicesRank || batchDims > indicesRank) {\n            throw new Error(`Expect batchDims in the range of [-${indicesRank}, ${indicesRank}], but got ${batchDims}`);\n        }\n    }\n    if (batchDims < 0) {\n        batchDims += indicesRank;\n    }\n    if (batchDims > xRank) {\n        throw new Error(`batchDims (${batchDims}) must be less than rank(x) (\n    ${xRank}).`);\n    }\n    if (axis < batchDims) {\n        throw new Error(`batchDims (${batchDims}) must be less than or equal to axis (${axis}).`);\n    }\n    for (let i = 0; i < batchDims; ++i) {\n        if (x.shape[i] !== indices.shape[i]) {\n            throw new Error(`x.shape[${i}]: ${x.shape[i]} should be equal to indices.shape[${i}]: ${indices.shape[i]}.`);\n        }\n    }\n    const dimSize = x.shape[axis];\n    const outputShape = [];\n    let batchSize = 1;\n    let outerSize = 1;\n    let sliceSize = 1;\n    for (let i = 0; i < batchDims; ++i) {\n        outputShape.push(x.shape[i]);\n        batchSize *= x.shape[i];\n    }\n    for (let i = batchDims; i < axis; i++) {\n        outputShape.push(x.shape[i]);\n        outerSize *= x.shape[i];\n    }\n    for (let i = batchDims; i < indicesRank; i++) {\n        outputShape.push(indices.shape[i]);\n    }\n    for (let i = axis + 1; i < xRank; i++) {\n        outputShape.push(x.shape[i]);\n        sliceSize *= x.shape[i];\n    }\n    return { batchSize, sliceSize, outerSize, dimSize, outputShape };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}