{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * Built-in metrics.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { tidy } from '@tensorflow/tfjs-core';\nimport * as K from './backend/tfjs_backend';\nimport { NotImplementedError, ValueError } from './errors';\nimport { categoricalCrossentropy as categoricalCrossentropyLoss, cosineProximity, meanAbsoluteError, meanAbsolutePercentageError, meanSquaredError, sparseCategoricalCrossentropy as sparseCategoricalCrossentropyLoss } from './losses';\nimport { binaryCrossentropy as lossBinaryCrossentropy } from './losses';\nimport { lossesMap } from './losses';\nimport * as util from './utils/generic_utils';\nexport function binaryAccuracy(yTrue, yPred) {\n  return tidy(() => {\n    const threshold = tfc.mul(.5, tfc.onesLike(yPred));\n    const yPredThresholded = K.cast(tfc.greater(yPred, threshold), yTrue.dtype);\n    return tfc.mean(tfc.equal(yTrue, yPredThresholded), -1);\n  });\n}\nexport function categoricalAccuracy(yTrue, yPred) {\n  return tidy(() => K.cast(tfc.equal(tfc.argMax(yTrue, -1), tfc.argMax(yPred, -1)), 'float32'));\n}\n\nfunction truePositives(yTrue, yPred) {\n  return tidy(() => {\n    return tfc.cast(tfc.sum(tfc.logicalAnd(tfc.equal(yTrue, 1), tfc.equal(yPred, 1))), 'float32');\n  });\n}\n\nfunction falseNegatives(yTrue, yPred) {\n  return tidy(() => {\n    return tfc.cast(tfc.sum(tfc.logicalAnd(tfc.equal(yTrue, 1), tfc.equal(yPred, 0))), 'float32');\n  });\n}\n\nfunction falsePositives(yTrue, yPred) {\n  return tidy(() => {\n    return tfc.cast(tfc.sum(tfc.logicalAnd(tfc.equal(yTrue, 0), tfc.equal(yPred, 1))), 'float32');\n  });\n}\n\nexport function precision(yTrue, yPred) {\n  return tidy(() => {\n    const tp = truePositives(yTrue, yPred);\n    const fp = falsePositives(yTrue, yPred);\n    const denominator = tfc.add(tp, fp);\n    return tfc.cast(tfc.where(tfc.greater(denominator, 0), tfc.div(tp, denominator), 0), 'float32');\n  });\n}\nexport function recall(yTrue, yPred) {\n  return tidy(() => {\n    const tp = truePositives(yTrue, yPred);\n    const fn = falseNegatives(yTrue, yPred);\n    const denominator = tfc.add(tp, fn);\n    return tfc.cast(tfc.where(tfc.greater(denominator, 0), tfc.div(tp, denominator), 0), 'float32');\n  });\n}\nexport function binaryCrossentropy(yTrue, yPred) {\n  return lossBinaryCrossentropy(yTrue, yPred);\n}\nexport function sparseCategoricalAccuracy(yTrue, yPred) {\n  if (yTrue.rank === yPred.rank) {\n    yTrue = tfc.squeeze(yTrue, [yTrue.rank - 1]);\n  }\n\n  yPred = tfc.argMax(yPred, -1);\n\n  if (yPred.dtype !== yTrue.dtype) {\n    yPred = tfc.cast(yPred, yTrue.dtype);\n  }\n\n  return tfc.cast(tfc.equal(yTrue, yPred), 'float32');\n}\nexport function topKCategoricalAccuracy(yTrue, yPred) {\n  throw new NotImplementedError();\n}\nexport function sparseTopKCategoricalAccuracy(yTrue, yPred) {\n  throw new NotImplementedError();\n} // Aliases.\n\nexport const mse = meanSquaredError;\nexport const MSE = meanSquaredError;\nexport const mae = meanAbsoluteError;\nexport const MAE = meanAbsoluteError;\nexport const mape = meanAbsolutePercentageError;\nexport const MAPE = meanAbsolutePercentageError;\nexport const categoricalCrossentropy = categoricalCrossentropyLoss;\nexport const cosine = cosineProximity;\nexport const sparseCategoricalCrossentropy = sparseCategoricalCrossentropyLoss; // TODO(cais, nielsene): Add serialize().\n\nexport const metricsMap = {\n  binaryAccuracy,\n  categoricalAccuracy,\n  precision,\n  categoricalCrossentropy,\n  sparseCategoricalCrossentropy,\n  mse,\n  MSE,\n  mae,\n  MAE,\n  mape,\n  MAPE,\n  cosine\n};\nexport function get(identifier) {\n  if (typeof identifier === 'string' && identifier in metricsMap) {\n    return metricsMap[identifier];\n  } else if (typeof identifier !== 'string' && identifier != null) {\n    return identifier;\n  } else {\n    throw new ValueError(`Unknown metric ${identifier}`);\n  }\n}\n/**\n * Get the shortcut function name.\n *\n * If the fn name is a string,\n *   directly return the string name.\n * If the function is included in metricsMap or lossesMap,\n *   return key of the map.\n *   - If the function relative to multiple keys,\n *     return the first found key as the function name.\n *   - If the function exists in both lossesMap and metricsMap,\n *     search lossesMap first.\n * If the function is not included in metricsMap or lossesMap,\n *   return the function name.\n *\n * @param fn loss function, metric function, or short cut name.\n * @returns Loss or Metric name in string.\n */\n\nexport function getLossOrMetricName(fn) {\n  util.assert(fn !== null, `Unknown LossOrMetricFn ${fn}`);\n\n  if (typeof fn === 'string') {\n    return fn;\n  } else {\n    let fnName;\n\n    for (const key of Object.keys(lossesMap)) {\n      if (lossesMap[key] === fn) {\n        fnName = key;\n        break;\n      }\n    }\n\n    if (fnName !== undefined) {\n      return fnName;\n    }\n\n    for (const key of Object.keys(metricsMap)) {\n      if (metricsMap[key] === fn) {\n        fnName = key;\n        break;\n      }\n    }\n\n    if (fnName !== undefined) {\n      return fnName;\n    }\n\n    return fn.name;\n  }\n}","map":{"version":3,"names":["tfc","tidy","K","NotImplementedError","ValueError","categoricalCrossentropy","categoricalCrossentropyLoss","cosineProximity","meanAbsoluteError","meanAbsolutePercentageError","meanSquaredError","sparseCategoricalCrossentropy","sparseCategoricalCrossentropyLoss","binaryCrossentropy","lossBinaryCrossentropy","lossesMap","util","binaryAccuracy","yTrue","yPred","threshold","mul","onesLike","yPredThresholded","cast","greater","dtype","mean","equal","categoricalAccuracy","argMax","truePositives","sum","logicalAnd","falseNegatives","falsePositives","precision","tp","fp","denominator","add","where","div","recall","fn","sparseCategoricalAccuracy","rank","squeeze","topKCategoricalAccuracy","sparseTopKCategoricalAccuracy","mse","MSE","mae","MAE","mape","MAPE","cosine","metricsMap","get","identifier","getLossOrMetricName","assert","fnName","key","Object","keys","undefined","name"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-layers/dist/metrics.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Built-in metrics.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { tidy } from '@tensorflow/tfjs-core';\nimport * as K from './backend/tfjs_backend';\nimport { NotImplementedError, ValueError } from './errors';\nimport { categoricalCrossentropy as categoricalCrossentropyLoss, cosineProximity, meanAbsoluteError, meanAbsolutePercentageError, meanSquaredError, sparseCategoricalCrossentropy as sparseCategoricalCrossentropyLoss } from './losses';\nimport { binaryCrossentropy as lossBinaryCrossentropy } from './losses';\nimport { lossesMap } from './losses';\nimport * as util from './utils/generic_utils';\nexport function binaryAccuracy(yTrue, yPred) {\n    return tidy(() => {\n        const threshold = tfc.mul(.5, tfc.onesLike(yPred));\n        const yPredThresholded = K.cast(tfc.greater(yPred, threshold), yTrue.dtype);\n        return tfc.mean(tfc.equal(yTrue, yPredThresholded), -1);\n    });\n}\nexport function categoricalAccuracy(yTrue, yPred) {\n    return tidy(() => K.cast(tfc.equal(tfc.argMax(yTrue, -1), tfc.argMax(yPred, -1)), 'float32'));\n}\nfunction truePositives(yTrue, yPred) {\n    return tidy(() => {\n        return tfc.cast(tfc.sum(tfc.logicalAnd(tfc.equal(yTrue, 1), tfc.equal(yPred, 1))), 'float32');\n    });\n}\nfunction falseNegatives(yTrue, yPred) {\n    return tidy(() => {\n        return tfc.cast(tfc.sum(tfc.logicalAnd(tfc.equal(yTrue, 1), tfc.equal(yPred, 0))), 'float32');\n    });\n}\nfunction falsePositives(yTrue, yPred) {\n    return tidy(() => {\n        return tfc.cast(tfc.sum(tfc.logicalAnd(tfc.equal(yTrue, 0), tfc.equal(yPred, 1))), 'float32');\n    });\n}\nexport function precision(yTrue, yPred) {\n    return tidy(() => {\n        const tp = truePositives(yTrue, yPred);\n        const fp = falsePositives(yTrue, yPred);\n        const denominator = tfc.add(tp, fp);\n        return tfc.cast(tfc.where(tfc.greater(denominator, 0), tfc.div(tp, denominator), 0), 'float32');\n    });\n}\nexport function recall(yTrue, yPred) {\n    return tidy(() => {\n        const tp = truePositives(yTrue, yPred);\n        const fn = falseNegatives(yTrue, yPred);\n        const denominator = tfc.add(tp, fn);\n        return tfc.cast(tfc.where(tfc.greater(denominator, 0), tfc.div(tp, denominator), 0), 'float32');\n    });\n}\nexport function binaryCrossentropy(yTrue, yPred) {\n    return lossBinaryCrossentropy(yTrue, yPred);\n}\nexport function sparseCategoricalAccuracy(yTrue, yPred) {\n    if (yTrue.rank === yPred.rank) {\n        yTrue = tfc.squeeze(yTrue, [yTrue.rank - 1]);\n    }\n    yPred = tfc.argMax(yPred, -1);\n    if (yPred.dtype !== yTrue.dtype) {\n        yPred = tfc.cast(yPred, yTrue.dtype);\n    }\n    return tfc.cast(tfc.equal(yTrue, yPred), 'float32');\n}\nexport function topKCategoricalAccuracy(yTrue, yPred) {\n    throw new NotImplementedError();\n}\nexport function sparseTopKCategoricalAccuracy(yTrue, yPred) {\n    throw new NotImplementedError();\n}\n// Aliases.\nexport const mse = meanSquaredError;\nexport const MSE = meanSquaredError;\nexport const mae = meanAbsoluteError;\nexport const MAE = meanAbsoluteError;\nexport const mape = meanAbsolutePercentageError;\nexport const MAPE = meanAbsolutePercentageError;\nexport const categoricalCrossentropy = categoricalCrossentropyLoss;\nexport const cosine = cosineProximity;\nexport const sparseCategoricalCrossentropy = sparseCategoricalCrossentropyLoss;\n// TODO(cais, nielsene): Add serialize().\nexport const metricsMap = {\n    binaryAccuracy,\n    categoricalAccuracy,\n    precision,\n    categoricalCrossentropy,\n    sparseCategoricalCrossentropy,\n    mse,\n    MSE,\n    mae,\n    MAE,\n    mape,\n    MAPE,\n    cosine\n};\nexport function get(identifier) {\n    if (typeof identifier === 'string' && identifier in metricsMap) {\n        return metricsMap[identifier];\n    }\n    else if (typeof identifier !== 'string' && identifier != null) {\n        return identifier;\n    }\n    else {\n        throw new ValueError(`Unknown metric ${identifier}`);\n    }\n}\n/**\n * Get the shortcut function name.\n *\n * If the fn name is a string,\n *   directly return the string name.\n * If the function is included in metricsMap or lossesMap,\n *   return key of the map.\n *   - If the function relative to multiple keys,\n *     return the first found key as the function name.\n *   - If the function exists in both lossesMap and metricsMap,\n *     search lossesMap first.\n * If the function is not included in metricsMap or lossesMap,\n *   return the function name.\n *\n * @param fn loss function, metric function, or short cut name.\n * @returns Loss or Metric name in string.\n */\nexport function getLossOrMetricName(fn) {\n    util.assert(fn !== null, `Unknown LossOrMetricFn ${fn}`);\n    if (typeof fn === 'string') {\n        return fn;\n    }\n    else {\n        let fnName;\n        for (const key of Object.keys(lossesMap)) {\n            if (lossesMap[key] === fn) {\n                fnName = key;\n                break;\n            }\n        }\n        if (fnName !== undefined) {\n            return fnName;\n        }\n        for (const key of Object.keys(metricsMap)) {\n            if (metricsMap[key] === fn) {\n                fnName = key;\n                break;\n            }\n        }\n        if (fnName !== undefined) {\n            return fnName;\n        }\n        return fn.name;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}