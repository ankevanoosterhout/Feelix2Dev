{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { util } from '@tensorflow/tfjs-core';\nimport * as K from '../backend/tfjs_backend';\nimport { checkDataFormat, checkPaddingMode } from '../common';\nimport { InputSpec } from '../engine/topology';\nimport { AttributeError, NotImplementedError, ValueError } from '../errors';\nimport { Initializer } from '../initializers';\nimport { convOutputLength, normalizeArray } from '../utils/conv_utils';\nimport { assertPositiveInteger } from '../utils/generic_utils';\nimport { getExactlyOneShape } from '../utils/types_utils';\nimport { generateDropoutMask, LSTMCell, RNN, RNNCell } from './recurrent';\n\nclass ConvRNN2DCell extends RNNCell {}\n/**\n * Base class for convolutional-recurrent layers.\n */\n\n\nclass ConvRNN2D extends RNN {\n  constructor(args) {\n    if (args.unroll) {\n      throw new NotImplementedError('Unrolling is not possible with convolutional RNNs.');\n    }\n\n    if (Array.isArray(args.cell)) {\n      throw new NotImplementedError('It is not possible at the moment to stack convolutional cells.');\n    }\n\n    super(args);\n    this.inputSpec = [new InputSpec({\n      ndim: 5\n    })];\n  }\n\n  call(inputs, kwargs) {\n    return tfc.tidy(() => {\n      if (this.cell.dropoutMask != null) {\n        tfc.dispose(this.cell.dropoutMask);\n        this.cell.dropoutMask = null;\n      }\n\n      if (this.cell.recurrentDropoutMask != null) {\n        tfc.dispose(this.cell.recurrentDropoutMask);\n        this.cell.recurrentDropoutMask = null;\n      }\n\n      if (kwargs && kwargs['constants']) {\n        throw new ValueError('ConvRNN2D cell does not support constants');\n      }\n\n      const mask = kwargs == null ? null : kwargs['mask'];\n      const training = kwargs == null ? null : kwargs['training'];\n      const initialState = kwargs == null ? null : kwargs['initialState'];\n      return super.call(inputs, {\n        mask,\n        training,\n        initialState\n      });\n    });\n  }\n\n  computeOutputShape(inputShape) {\n    let outShape = this.computeSingleOutputShape(inputShape);\n\n    if (!this.returnSequences) {\n      outShape = [outShape[0], ...outShape.slice(2)];\n    }\n\n    if (this.returnState) {\n      outShape = [outShape, ...Array(2).fill([inputShape[0], ...outShape.slice(-3)])];\n    }\n\n    return outShape;\n  }\n\n  getInitialState(inputs) {\n    return tfc.tidy(() => {\n      const {\n        stateSize\n      } = this.cell;\n      const inputShape = inputs.shape;\n      const outputShape = this.computeSingleOutputShape(inputShape);\n      const stateShape = [outputShape[0], ...outputShape.slice(2)];\n      const initialState = tfc.zeros(stateShape);\n\n      if (Array.isArray(stateSize)) {\n        return Array(stateSize.length).fill(initialState);\n      }\n\n      return [initialState];\n    });\n  }\n\n  resetStates(states, training = false) {\n    tfc.tidy(() => {\n      if (!this.stateful) {\n        throw new AttributeError('Cannot call resetStates() on an RNN Layer that is not stateful.');\n      }\n\n      const inputShape = this.inputSpec[0].shape;\n      const outputShape = this.computeSingleOutputShape(inputShape);\n      const stateShape = [outputShape[0], ...outputShape.slice(2)];\n      const batchSize = inputShape[0];\n\n      if (batchSize == null) {\n        throw new ValueError('If an RNN is stateful, it needs to know its batch size. Specify ' + 'the batch size of your input tensors: \\n' + '- If using a Sequential model, specify the batch size by ' + 'passing a `batchInputShape` option to your first layer.\\n' + '- If using the functional API, specify the batch size by ' + 'passing a `batchShape` option to your Input layer.');\n      } // Initialize state if null.\n\n\n      if (this.getStates() == null) {\n        if (Array.isArray(this.cell.stateSize)) {\n          this.states_ = this.cell.stateSize.map(() => tfc.zeros(stateShape));\n        } else {\n          this.states_ = [tfc.zeros(stateShape)];\n        }\n      } else if (states == null) {\n        // Dispose old state tensors.\n        tfc.dispose(this.states_); // For stateful RNNs, fully dispose kept old states.\n\n        if (this.keptStates != null) {\n          tfc.dispose(this.keptStates);\n          this.keptStates = [];\n        }\n\n        if (Array.isArray(this.cell.stateSize)) {\n          this.states_ = this.cell.stateSize.map(() => tfc.zeros(stateShape));\n        } else {\n          this.states_[0] = tfc.zeros(stateShape);\n        }\n      } else {\n        if (!Array.isArray(states)) {\n          states = [states];\n        }\n\n        if (states.length !== this.states_.length) {\n          throw new ValueError(`Layer ${this.name} expects ${this.states_.length} state(s), ` + `but it received ${states.length} state value(s). Input ` + `received: ${states}`);\n        }\n\n        if (training) {\n          // Store old state tensors for complete disposal later, i.e., during\n          // the next no-arg call to this method. We do not dispose the old\n          // states immediately because that BPTT (among other things) require\n          // them.\n          this.keptStates.push(this.states_.slice());\n        } else {\n          tfc.dispose(this.states_);\n        }\n\n        for (let index = 0; index < this.states_.length; ++index) {\n          const value = states[index];\n          const expectedShape = stateShape;\n\n          if (!util.arraysEqual(value.shape, expectedShape)) {\n            throw new ValueError(`State ${index} is incompatible with layer ${this.name}: ` + `expected shape=${expectedShape}, received shape=${value.shape}`);\n          }\n\n          this.states_[index] = value;\n        }\n      }\n\n      this.states_ = this.states_.map(state => tfc.keep(state.clone()));\n    });\n  }\n\n  computeSingleOutputShape(inputShape) {\n    const {\n      dataFormat,\n      filters,\n      kernelSize,\n      padding,\n      strides,\n      dilationRate\n    } = this.cell;\n    const isChannelsFirst = dataFormat === 'channelsFirst';\n    const h = inputShape[isChannelsFirst ? 3 : 2];\n    const w = inputShape[isChannelsFirst ? 4 : 3];\n    const hOut = convOutputLength(h, kernelSize[0], padding, strides[0], dilationRate[0]);\n    const wOut = convOutputLength(w, kernelSize[1], padding, strides[1], dilationRate[1]);\n    const outShape = [...inputShape.slice(0, 2), ...(isChannelsFirst ? [filters, hOut, wOut] : [hOut, wOut, filters])];\n    return outShape;\n  }\n\n}\n/** @nocollapse */\n\n\nConvRNN2D.className = 'ConvRNN2D';\nexport class ConvLSTM2DCell extends LSTMCell {\n  constructor(args) {\n    const {\n      filters,\n      kernelSize,\n      strides,\n      padding,\n      dataFormat,\n      dilationRate\n    } = args;\n    super(Object.assign({}, args, {\n      units: filters\n    }));\n    this.filters = filters;\n    assertPositiveInteger(this.filters, 'filters');\n    this.kernelSize = normalizeArray(kernelSize, 2, 'kernelSize');\n    this.kernelSize.forEach(size => assertPositiveInteger(size, 'kernelSize'));\n    this.strides = normalizeArray(strides || 1, 2, 'strides');\n    this.strides.forEach(stride => assertPositiveInteger(stride, 'strides'));\n    this.padding = padding || 'valid';\n    checkPaddingMode(this.padding);\n    this.dataFormat = dataFormat || 'channelsLast';\n    checkDataFormat(this.dataFormat);\n    this.dilationRate = normalizeArray(dilationRate || 1, 2, 'dilationRate');\n    this.dilationRate.forEach(rate => assertPositiveInteger(rate, 'dilationRate'));\n  }\n\n  build(inputShape) {\n    var _a;\n\n    inputShape = getExactlyOneShape(inputShape);\n    const channelAxis = this.dataFormat === 'channelsFirst' ? 1 : inputShape.length - 1;\n\n    if (inputShape[channelAxis] == null) {\n      throw new ValueError(`The channel dimension of the input should be defined. ` + `Found ${inputShape[channelAxis]}`);\n    }\n\n    const inputDim = inputShape[channelAxis];\n    const numOfKernels = 4;\n    const kernelShape = this.kernelSize.concat([inputDim, this.filters * numOfKernels]);\n    this.kernel = this.addWeight('kernel', kernelShape, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);\n    const recurrentKernelShape = this.kernelSize.concat([this.filters, this.filters * numOfKernels]);\n    this.recurrentKernel = this.addWeight('recurrent_kernel', recurrentKernelShape, null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);\n\n    if (this.useBias) {\n      let biasInitializer;\n\n      if (this.unitForgetBias) {\n        const init = this.biasInitializer;\n        const filters = this.filters;\n        biasInitializer = new (_a = class CustomInit extends Initializer {\n          apply(shape, dtype) {\n            const biasI = init.apply([filters]);\n            const biasF = tfc.ones([filters]);\n            const biasCAndO = init.apply([filters * 2]);\n            return K.concatenate([biasI, biasF, biasCAndO]);\n          }\n\n        },\n        /** @nocollapse */\n        _a.className = 'CustomInit', _a)();\n      } else {\n        biasInitializer = this.biasInitializer;\n      }\n\n      this.bias = this.addWeight('bias', [this.filters * numOfKernels], null, biasInitializer, this.biasRegularizer, true, this.biasConstraint);\n    }\n\n    this.built = true;\n  }\n\n  call(inputs, kwargs) {\n    return tfc.tidy(() => {\n      if (inputs.length !== 3) {\n        throw new ValueError(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ` + `${inputs.length}.`);\n      }\n\n      const training = kwargs['training'] || false;\n      const x = inputs[0]; // Current input\n\n      const hTMinus1 = inputs[1]; // Previous memory state.\n\n      const cTMinus1 = inputs[2]; // Previous carry state.\n\n      const numOfKernels = 4;\n\n      if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {\n        this.dropoutMask = generateDropoutMask({\n          ones: () => tfc.onesLike(x),\n          rate: this.dropout,\n          training,\n          count: numOfKernels,\n          dropoutFunc: this.dropoutFunc\n        });\n      }\n\n      const dropoutMask = this.dropoutMask;\n\n      const applyDropout = (x, mask, index) => {\n        if (!mask || !mask[index]) {\n          return x;\n        }\n\n        return tfc.mul(mask[index], x);\n      };\n\n      let xI = applyDropout(x, dropoutMask, 0);\n      let xF = applyDropout(x, dropoutMask, 1);\n      let xC = applyDropout(x, dropoutMask, 2);\n      let xO = applyDropout(x, dropoutMask, 3);\n\n      if (0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null) {\n        this.recurrentDropoutMask = generateDropoutMask({\n          ones: () => tfc.onesLike(hTMinus1),\n          rate: this.recurrentDropout,\n          training,\n          count: numOfKernels,\n          dropoutFunc: this.dropoutFunc\n        });\n      }\n\n      const recDropoutMask = this.recurrentDropoutMask;\n      let hI = applyDropout(hTMinus1, recDropoutMask, 0);\n      let hF = applyDropout(hTMinus1, recDropoutMask, 1);\n      let hC = applyDropout(hTMinus1, recDropoutMask, 2);\n      let hO = applyDropout(hTMinus1, recDropoutMask, 3);\n      const kernelChannelAxis = 3;\n      const [kernelI, kernelF, kernelC, kernelO] = tfc.split(this.kernel.read(), numOfKernels, kernelChannelAxis);\n      const [biasI, biasF, biasC, biasO] = this.useBias ? tfc.split(this.bias.read(), numOfKernels) : [null, null, null, null];\n      xI = this.inputConv(xI, kernelI, biasI, this.padding);\n      xF = this.inputConv(xF, kernelF, biasF, this.padding);\n      xC = this.inputConv(xC, kernelC, biasC, this.padding);\n      xO = this.inputConv(xO, kernelO, biasO, this.padding);\n      const [recKernelI, recKernelF, recKernelC, recKernelO] = tfc.split(this.recurrentKernel.read(), numOfKernels, kernelChannelAxis);\n      hI = this.recurrentConv(hI, recKernelI);\n      hF = this.recurrentConv(hF, recKernelF);\n      hC = this.recurrentConv(hC, recKernelC);\n      hO = this.recurrentConv(hO, recKernelO);\n      const i = this.recurrentActivation.apply(tfc.add(xI, hI));\n      const f = this.recurrentActivation.apply(tfc.add(xF, hF));\n      const c = tfc.add(tfc.mul(f, cTMinus1), tfc.mul(i, this.activation.apply(tfc.add(xC, hC))));\n      const h = tfc.mul(this.recurrentActivation.apply(tfc.add(xO, hO)), this.activation.apply(c));\n      return [h, h, c];\n    });\n  }\n\n  getConfig() {\n    const _a = super.getConfig(),\n          {\n      'units': _\n    } = _a,\n          baseConfig = __rest(_a, ['units']);\n\n    const config = {\n      filters: this.filters,\n      kernelSize: this.kernelSize,\n      padding: this.padding,\n      dataFormat: this.dataFormat,\n      dilationRate: this.dilationRate,\n      strides: this.strides\n    };\n    return Object.assign({}, baseConfig, config);\n  }\n\n  inputConv(x, w, b, padding) {\n    const out = tfc.conv2d(x, w, this.strides, padding || 'valid', this.dataFormat === 'channelsFirst' ? 'NCHW' : 'NHWC', this.dilationRate);\n\n    if (b) {\n      return K.biasAdd(out, b, this.dataFormat);\n    }\n\n    return out;\n  }\n\n  recurrentConv(x, w) {\n    const strides = 1;\n    return tfc.conv2d(x, w, strides, 'same', this.dataFormat === 'channelsFirst' ? 'NCHW' : 'NHWC');\n  }\n\n}\n/** @nocollapse */\n\nConvLSTM2DCell.className = 'ConvLSTM2DCell';\ntfc.serialization.registerClass(ConvLSTM2DCell);\nexport class ConvLSTM2D extends ConvRNN2D {\n  constructor(args) {\n    const cell = new ConvLSTM2DCell(args);\n    super(Object.assign({}, args, {\n      cell\n    }));\n  }\n  /** @nocollapse */\n\n\n  static fromConfig(cls, config) {\n    return new cls(config);\n  }\n\n}\n/** @nocollapse */\n\nConvLSTM2D.className = 'ConvLSTM2D';\ntfc.serialization.registerClass(ConvLSTM2D);","map":{"version":3,"names":["__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","tfc","util","K","checkDataFormat","checkPaddingMode","InputSpec","AttributeError","NotImplementedError","ValueError","Initializer","convOutputLength","normalizeArray","assertPositiveInteger","getExactlyOneShape","generateDropoutMask","LSTMCell","RNN","RNNCell","ConvRNN2DCell","ConvRNN2D","constructor","args","unroll","Array","isArray","cell","inputSpec","ndim","inputs","kwargs","tidy","dropoutMask","dispose","recurrentDropoutMask","mask","training","initialState","computeOutputShape","inputShape","outShape","computeSingleOutputShape","returnSequences","slice","returnState","fill","getInitialState","stateSize","shape","outputShape","stateShape","zeros","resetStates","states","stateful","batchSize","getStates","states_","map","keptStates","name","push","index","value","expectedShape","arraysEqual","state","keep","clone","dataFormat","filters","kernelSize","padding","strides","dilationRate","isChannelsFirst","h","w","hOut","wOut","className","ConvLSTM2DCell","assign","units","forEach","size","stride","rate","build","_a","channelAxis","inputDim","numOfKernels","kernelShape","concat","kernel","addWeight","kernelInitializer","kernelRegularizer","kernelConstraint","recurrentKernelShape","recurrentKernel","recurrentInitializer","recurrentRegularizer","recurrentConstraint","useBias","biasInitializer","unitForgetBias","init","CustomInit","apply","dtype","biasI","biasF","ones","biasCAndO","concatenate","bias","biasRegularizer","biasConstraint","built","x","hTMinus1","cTMinus1","dropout","onesLike","count","dropoutFunc","applyDropout","mul","xI","xF","xC","xO","recurrentDropout","recDropoutMask","hI","hF","hC","hO","kernelChannelAxis","kernelI","kernelF","kernelC","kernelO","split","read","biasC","biasO","inputConv","recKernelI","recKernelF","recKernelC","recKernelO","recurrentConv","recurrentActivation","add","f","c","activation","getConfig","_","baseConfig","config","b","out","conv2d","biasAdd","serialization","registerClass","ConvLSTM2D","fromConfig","cls"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-layers/dist/layers/convolutional_recurrent.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { util } from '@tensorflow/tfjs-core';\nimport * as K from '../backend/tfjs_backend';\nimport { checkDataFormat, checkPaddingMode } from '../common';\nimport { InputSpec } from '../engine/topology';\nimport { AttributeError, NotImplementedError, ValueError } from '../errors';\nimport { Initializer } from '../initializers';\nimport { convOutputLength, normalizeArray } from '../utils/conv_utils';\nimport { assertPositiveInteger } from '../utils/generic_utils';\nimport { getExactlyOneShape } from '../utils/types_utils';\nimport { generateDropoutMask, LSTMCell, RNN, RNNCell } from './recurrent';\nclass ConvRNN2DCell extends RNNCell {\n}\n/**\n * Base class for convolutional-recurrent layers.\n */\nclass ConvRNN2D extends RNN {\n    constructor(args) {\n        if (args.unroll) {\n            throw new NotImplementedError('Unrolling is not possible with convolutional RNNs.');\n        }\n        if (Array.isArray(args.cell)) {\n            throw new NotImplementedError('It is not possible at the moment to stack convolutional cells.');\n        }\n        super(args);\n        this.inputSpec = [new InputSpec({ ndim: 5 })];\n    }\n    call(inputs, kwargs) {\n        return tfc.tidy(() => {\n            if (this.cell.dropoutMask != null) {\n                tfc.dispose(this.cell.dropoutMask);\n                this.cell.dropoutMask = null;\n            }\n            if (this.cell.recurrentDropoutMask != null) {\n                tfc.dispose(this.cell.recurrentDropoutMask);\n                this.cell.recurrentDropoutMask = null;\n            }\n            if (kwargs && kwargs['constants']) {\n                throw new ValueError('ConvRNN2D cell does not support constants');\n            }\n            const mask = kwargs == null ? null : kwargs['mask'];\n            const training = kwargs == null ? null : kwargs['training'];\n            const initialState = kwargs == null ? null : kwargs['initialState'];\n            return super.call(inputs, { mask, training, initialState });\n        });\n    }\n    computeOutputShape(inputShape) {\n        let outShape = this.computeSingleOutputShape(inputShape);\n        if (!this.returnSequences) {\n            outShape = [outShape[0], ...outShape.slice(2)];\n        }\n        if (this.returnState) {\n            outShape =\n                [outShape, ...Array(2).fill([inputShape[0], ...outShape.slice(-3)])];\n        }\n        return outShape;\n    }\n    getInitialState(inputs) {\n        return tfc.tidy(() => {\n            const { stateSize } = this.cell;\n            const inputShape = inputs.shape;\n            const outputShape = this.computeSingleOutputShape(inputShape);\n            const stateShape = [outputShape[0], ...outputShape.slice(2)];\n            const initialState = tfc.zeros(stateShape);\n            if (Array.isArray(stateSize)) {\n                return Array(stateSize.length).fill(initialState);\n            }\n            return [initialState];\n        });\n    }\n    resetStates(states, training = false) {\n        tfc.tidy(() => {\n            if (!this.stateful) {\n                throw new AttributeError('Cannot call resetStates() on an RNN Layer that is not stateful.');\n            }\n            const inputShape = this.inputSpec[0].shape;\n            const outputShape = this.computeSingleOutputShape(inputShape);\n            const stateShape = [outputShape[0], ...outputShape.slice(2)];\n            const batchSize = inputShape[0];\n            if (batchSize == null) {\n                throw new ValueError('If an RNN is stateful, it needs to know its batch size. Specify ' +\n                    'the batch size of your input tensors: \\n' +\n                    '- If using a Sequential model, specify the batch size by ' +\n                    'passing a `batchInputShape` option to your first layer.\\n' +\n                    '- If using the functional API, specify the batch size by ' +\n                    'passing a `batchShape` option to your Input layer.');\n            }\n            // Initialize state if null.\n            if (this.getStates() == null) {\n                if (Array.isArray(this.cell.stateSize)) {\n                    this.states_ = this.cell.stateSize.map(() => tfc.zeros(stateShape));\n                }\n                else {\n                    this.states_ = [tfc.zeros(stateShape)];\n                }\n            }\n            else if (states == null) {\n                // Dispose old state tensors.\n                tfc.dispose(this.states_);\n                // For stateful RNNs, fully dispose kept old states.\n                if (this.keptStates != null) {\n                    tfc.dispose(this.keptStates);\n                    this.keptStates = [];\n                }\n                if (Array.isArray(this.cell.stateSize)) {\n                    this.states_ = this.cell.stateSize.map(() => tfc.zeros(stateShape));\n                }\n                else {\n                    this.states_[0] = tfc.zeros(stateShape);\n                }\n            }\n            else {\n                if (!Array.isArray(states)) {\n                    states = [states];\n                }\n                if (states.length !== this.states_.length) {\n                    throw new ValueError(`Layer ${this.name} expects ${this.states_.length} state(s), ` +\n                        `but it received ${states.length} state value(s). Input ` +\n                        `received: ${states}`);\n                }\n                if (training) {\n                    // Store old state tensors for complete disposal later, i.e., during\n                    // the next no-arg call to this method. We do not dispose the old\n                    // states immediately because that BPTT (among other things) require\n                    // them.\n                    this.keptStates.push(this.states_.slice());\n                }\n                else {\n                    tfc.dispose(this.states_);\n                }\n                for (let index = 0; index < this.states_.length; ++index) {\n                    const value = states[index];\n                    const expectedShape = stateShape;\n                    if (!util.arraysEqual(value.shape, expectedShape)) {\n                        throw new ValueError(`State ${index} is incompatible with layer ${this.name}: ` +\n                            `expected shape=${expectedShape}, received shape=${value.shape}`);\n                    }\n                    this.states_[index] = value;\n                }\n            }\n            this.states_ = this.states_.map(state => tfc.keep(state.clone()));\n        });\n    }\n    computeSingleOutputShape(inputShape) {\n        const { dataFormat, filters, kernelSize, padding, strides, dilationRate } = this.cell;\n        const isChannelsFirst = dataFormat === 'channelsFirst';\n        const h = inputShape[isChannelsFirst ? 3 : 2];\n        const w = inputShape[isChannelsFirst ? 4 : 3];\n        const hOut = convOutputLength(h, kernelSize[0], padding, strides[0], dilationRate[0]);\n        const wOut = convOutputLength(w, kernelSize[1], padding, strides[1], dilationRate[1]);\n        const outShape = [\n            ...inputShape.slice(0, 2),\n            ...(isChannelsFirst ? [filters, hOut, wOut] : [hOut, wOut, filters])\n        ];\n        return outShape;\n    }\n}\n/** @nocollapse */\nConvRNN2D.className = 'ConvRNN2D';\nexport class ConvLSTM2DCell extends LSTMCell {\n    constructor(args) {\n        const { filters, kernelSize, strides, padding, dataFormat, dilationRate, } = args;\n        super(Object.assign({}, args, { units: filters }));\n        this.filters = filters;\n        assertPositiveInteger(this.filters, 'filters');\n        this.kernelSize = normalizeArray(kernelSize, 2, 'kernelSize');\n        this.kernelSize.forEach(size => assertPositiveInteger(size, 'kernelSize'));\n        this.strides = normalizeArray(strides || 1, 2, 'strides');\n        this.strides.forEach(stride => assertPositiveInteger(stride, 'strides'));\n        this.padding = padding || 'valid';\n        checkPaddingMode(this.padding);\n        this.dataFormat = dataFormat || 'channelsLast';\n        checkDataFormat(this.dataFormat);\n        this.dilationRate = normalizeArray(dilationRate || 1, 2, 'dilationRate');\n        this.dilationRate.forEach(rate => assertPositiveInteger(rate, 'dilationRate'));\n    }\n    build(inputShape) {\n        var _a;\n        inputShape = getExactlyOneShape(inputShape);\n        const channelAxis = this.dataFormat === 'channelsFirst' ? 1 : inputShape.length - 1;\n        if (inputShape[channelAxis] == null) {\n            throw new ValueError(`The channel dimension of the input should be defined. ` +\n                `Found ${inputShape[channelAxis]}`);\n        }\n        const inputDim = inputShape[channelAxis];\n        const numOfKernels = 4;\n        const kernelShape = this.kernelSize.concat([inputDim, this.filters * numOfKernels]);\n        this.kernel = this.addWeight('kernel', kernelShape, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);\n        const recurrentKernelShape = this.kernelSize.concat([this.filters, this.filters * numOfKernels]);\n        this.recurrentKernel = this.addWeight('recurrent_kernel', recurrentKernelShape, null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);\n        if (this.useBias) {\n            let biasInitializer;\n            if (this.unitForgetBias) {\n                const init = this.biasInitializer;\n                const filters = this.filters;\n                biasInitializer = new (_a = class CustomInit extends Initializer {\n                        apply(shape, dtype) {\n                            const biasI = init.apply([filters]);\n                            const biasF = tfc.ones([filters]);\n                            const biasCAndO = init.apply([filters * 2]);\n                            return K.concatenate([biasI, biasF, biasCAndO]);\n                        }\n                    },\n                    /** @nocollapse */\n                    _a.className = 'CustomInit',\n                    _a)();\n            }\n            else {\n                biasInitializer = this.biasInitializer;\n            }\n            this.bias = this.addWeight('bias', [this.filters * numOfKernels], null, biasInitializer, this.biasRegularizer, true, this.biasConstraint);\n        }\n        this.built = true;\n    }\n    call(inputs, kwargs) {\n        return tfc.tidy(() => {\n            if (inputs.length !== 3) {\n                throw new ValueError(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ` +\n                    `${inputs.length}.`);\n            }\n            const training = kwargs['training'] || false;\n            const x = inputs[0]; // Current input\n            const hTMinus1 = inputs[1]; // Previous memory state.\n            const cTMinus1 = inputs[2]; // Previous carry state.\n            const numOfKernels = 4;\n            if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {\n                this.dropoutMask = generateDropoutMask({\n                    ones: () => tfc.onesLike(x),\n                    rate: this.dropout,\n                    training,\n                    count: numOfKernels,\n                    dropoutFunc: this.dropoutFunc\n                });\n            }\n            const dropoutMask = this.dropoutMask;\n            const applyDropout = (x, mask, index) => {\n                if (!mask || !mask[index]) {\n                    return x;\n                }\n                return tfc.mul(mask[index], x);\n            };\n            let xI = applyDropout(x, dropoutMask, 0);\n            let xF = applyDropout(x, dropoutMask, 1);\n            let xC = applyDropout(x, dropoutMask, 2);\n            let xO = applyDropout(x, dropoutMask, 3);\n            if (0 < this.recurrentDropout && this.recurrentDropout < 1 &&\n                this.recurrentDropoutMask == null) {\n                this.recurrentDropoutMask = generateDropoutMask({\n                    ones: () => tfc.onesLike(hTMinus1),\n                    rate: this.recurrentDropout,\n                    training,\n                    count: numOfKernels,\n                    dropoutFunc: this.dropoutFunc\n                });\n            }\n            const recDropoutMask = this.recurrentDropoutMask;\n            let hI = applyDropout(hTMinus1, recDropoutMask, 0);\n            let hF = applyDropout(hTMinus1, recDropoutMask, 1);\n            let hC = applyDropout(hTMinus1, recDropoutMask, 2);\n            let hO = applyDropout(hTMinus1, recDropoutMask, 3);\n            const kernelChannelAxis = 3;\n            const [kernelI, kernelF, kernelC, kernelO] = tfc.split(this.kernel.read(), numOfKernels, kernelChannelAxis);\n            const [biasI, biasF, biasC, biasO] = this.useBias ?\n                tfc.split(this.bias.read(), numOfKernels) :\n                [null, null, null, null];\n            xI = this.inputConv(xI, kernelI, biasI, this.padding);\n            xF = this.inputConv(xF, kernelF, biasF, this.padding);\n            xC = this.inputConv(xC, kernelC, biasC, this.padding);\n            xO = this.inputConv(xO, kernelO, biasO, this.padding);\n            const [recKernelI, recKernelF, recKernelC, recKernelO] = tfc.split(this.recurrentKernel.read(), numOfKernels, kernelChannelAxis);\n            hI = this.recurrentConv(hI, recKernelI);\n            hF = this.recurrentConv(hF, recKernelF);\n            hC = this.recurrentConv(hC, recKernelC);\n            hO = this.recurrentConv(hO, recKernelO);\n            const i = this.recurrentActivation.apply(tfc.add(xI, hI));\n            const f = this.recurrentActivation.apply(tfc.add(xF, hF));\n            const c = tfc.add(tfc.mul(f, cTMinus1), tfc.mul(i, this.activation.apply(tfc.add(xC, hC))));\n            const h = tfc.mul(this.recurrentActivation.apply(tfc.add(xO, hO)), this.activation.apply(c));\n            return [h, h, c];\n        });\n    }\n    getConfig() {\n        const _a = super.getConfig(), { 'units': _ } = _a, baseConfig = __rest(_a, ['units']);\n        const config = {\n            filters: this.filters,\n            kernelSize: this.kernelSize,\n            padding: this.padding,\n            dataFormat: this.dataFormat,\n            dilationRate: this.dilationRate,\n            strides: this.strides,\n        };\n        return Object.assign({}, baseConfig, config);\n    }\n    inputConv(x, w, b, padding) {\n        const out = tfc.conv2d(x, w, this.strides, (padding || 'valid'), this.dataFormat === 'channelsFirst' ? 'NCHW' : 'NHWC', this.dilationRate);\n        if (b) {\n            return K.biasAdd(out, b, this.dataFormat);\n        }\n        return out;\n    }\n    recurrentConv(x, w) {\n        const strides = 1;\n        return tfc.conv2d(x, w, strides, 'same', this.dataFormat === 'channelsFirst' ? 'NCHW' : 'NHWC');\n    }\n}\n/** @nocollapse */\nConvLSTM2DCell.className = 'ConvLSTM2DCell';\ntfc.serialization.registerClass(ConvLSTM2DCell);\nexport class ConvLSTM2D extends ConvRNN2D {\n    constructor(args) {\n        const cell = new ConvLSTM2DCell(args);\n        super(Object.assign({}, args, { cell }));\n    }\n    /** @nocollapse */\n    static fromConfig(cls, config) {\n        return new cls(config);\n    }\n}\n/** @nocollapse */\nConvLSTM2D.className = 'ConvLSTM2D';\ntfc.serialization.registerClass(ConvLSTM2D);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}