{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, DepthwiseConv2dNative, TensorBuffer, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function depthwiseConv2dNative(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x,\n    filter\n  } = inputs;\n  const {\n    strides,\n    pad,\n    dilations,\n    dimRoundingMode\n  } = attrs;\n  assertNotComplex([x, filter], 'depthwiseConv2DNative');\n  const xStrides = util.computeStrides(x.shape);\n  const filterStrides = util.computeStrides(filter.shape);\n  let $dilations = dilations;\n\n  if ($dilations == null) {\n    $dilations = [1, 1];\n  }\n\n  util.assert(backend_util.eitherStridesOrDilationsAreOne(strides, $dilations), () => 'Error in depthwiseConv2d: Either strides or dilations must be ' + `1. Got strides ${strides} and dilations '${$dilations}'`);\n  const convInfo = backend_util.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad, dimRoundingMode, true\n  /* depthwise */\n  );\n  const {\n    filterHeight,\n    filterWidth,\n    dilationHeight,\n    dilationWidth,\n    padInfo\n  } = convInfo;\n  const padLeft = padInfo.left;\n  const padTop = padInfo.top;\n  const chMul = convInfo.outChannels / convInfo.inChannels;\n  const y = new TensorBuffer(convInfo.outShape, x.dtype);\n  const xVals = backend.data.get(x.dataId).values;\n  const wVals = backend.data.get(filter.dataId).values;\n  const yVals = y.values;\n\n  for (let b = 0; b < convInfo.batchSize; ++b) {\n    const xOffset1 = b * xStrides[0];\n    const yOffset1 = b * y.strides[0];\n\n    for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n      const yOffset2 = yOffset1 + yR * y.strides[1];\n      const xRCorner = yR * convInfo.strideHeight - padTop;\n\n      for (let wR = 0; wR < filterHeight; ++wR) {\n        const xR = xRCorner + wR * dilationHeight;\n\n        if (xR < 0 || xR >= convInfo.inHeight) {\n          continue;\n        }\n\n        const wOffset1 = wR * filterStrides[0];\n        const xOffset2 = xOffset1 + xR * xStrides[1];\n\n        for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n          const yOffset3 = yOffset2 + yC * y.strides[2];\n          const xCCorner = yC * convInfo.strideWidth - padLeft;\n\n          for (let wC = 0; wC < filterWidth; ++wC) {\n            const xC = xCCorner + wC * dilationWidth;\n\n            if (xC < 0 || xC >= convInfo.inWidth) {\n              continue;\n            }\n\n            const wOffset2 = wOffset1 + wC * filterStrides[1];\n            const xOffset3 = xOffset2 + xC * convInfo.inChannels;\n            let yOffset4 = yOffset3;\n            let wOffset3 = wOffset2;\n\n            for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {\n              const xVal = xVals[xOffset3 + d1];\n\n              for (let q = 0; q < chMul; ++q) {\n                yVals[yOffset4 + q] += xVal * wVals[wOffset3 + q];\n              }\n\n              yOffset4 += chMul;\n              wOffset3 += chMul;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return backend.makeTensorInfo(y.shape, y.dtype, y.values);\n}\nexport const depthwiseConv2dNativeConfig = {\n  kernelName: DepthwiseConv2dNative,\n  backendName: 'cpu',\n  kernelFunc: depthwiseConv2dNative\n};","map":{"version":3,"names":["backend_util","DepthwiseConv2dNative","TensorBuffer","util","assertNotComplex","depthwiseConv2dNative","args","inputs","backend","attrs","x","filter","strides","pad","dilations","dimRoundingMode","xStrides","computeStrides","shape","filterStrides","$dilations","assert","eitherStridesOrDilationsAreOne","convInfo","computeConv2DInfo","filterHeight","filterWidth","dilationHeight","dilationWidth","padInfo","padLeft","left","padTop","top","chMul","outChannels","inChannels","y","outShape","dtype","xVals","data","get","dataId","values","wVals","yVals","b","batchSize","xOffset1","yOffset1","yR","outHeight","yOffset2","xRCorner","strideHeight","wR","xR","inHeight","wOffset1","xOffset2","yC","outWidth","yOffset3","xCCorner","strideWidth","wC","xC","inWidth","wOffset2","xOffset3","yOffset4","wOffset3","d1","xVal","q","makeTensorInfo","depthwiseConv2dNativeConfig","kernelName","backendName","kernelFunc"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/DepthwiseConv2dNative.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, DepthwiseConv2dNative, TensorBuffer, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function depthwiseConv2dNative(args) {\n    const { inputs, backend, attrs } = args;\n    const { x, filter } = inputs;\n    const { strides, pad, dilations, dimRoundingMode } = attrs;\n    assertNotComplex([x, filter], 'depthwiseConv2DNative');\n    const xStrides = util.computeStrides(x.shape);\n    const filterStrides = util.computeStrides(filter.shape);\n    let $dilations = dilations;\n    if ($dilations == null) {\n        $dilations = [1, 1];\n    }\n    util.assert(backend_util.eitherStridesOrDilationsAreOne(strides, $dilations), () => 'Error in depthwiseConv2d: Either strides or dilations must be ' +\n        `1. Got strides ${strides} and dilations '${$dilations}'`);\n    const convInfo = backend_util.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad, dimRoundingMode, true /* depthwise */);\n    const { filterHeight, filterWidth, dilationHeight, dilationWidth, padInfo } = convInfo;\n    const padLeft = padInfo.left;\n    const padTop = padInfo.top;\n    const chMul = convInfo.outChannels / convInfo.inChannels;\n    const y = new TensorBuffer(convInfo.outShape, x.dtype);\n    const xVals = backend.data.get(x.dataId).values;\n    const wVals = backend.data.get(filter.dataId).values;\n    const yVals = y.values;\n    for (let b = 0; b < convInfo.batchSize; ++b) {\n        const xOffset1 = b * xStrides[0];\n        const yOffset1 = b * y.strides[0];\n        for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n            const yOffset2 = yOffset1 + yR * y.strides[1];\n            const xRCorner = yR * convInfo.strideHeight - padTop;\n            for (let wR = 0; wR < filterHeight; ++wR) {\n                const xR = xRCorner + wR * dilationHeight;\n                if (xR < 0 || xR >= convInfo.inHeight) {\n                    continue;\n                }\n                const wOffset1 = wR * filterStrides[0];\n                const xOffset2 = xOffset1 + xR * xStrides[1];\n                for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n                    const yOffset3 = yOffset2 + yC * y.strides[2];\n                    const xCCorner = yC * convInfo.strideWidth - padLeft;\n                    for (let wC = 0; wC < filterWidth; ++wC) {\n                        const xC = xCCorner + wC * dilationWidth;\n                        if (xC < 0 || xC >= convInfo.inWidth) {\n                            continue;\n                        }\n                        const wOffset2 = wOffset1 + wC * filterStrides[1];\n                        const xOffset3 = xOffset2 + xC * convInfo.inChannels;\n                        let yOffset4 = yOffset3;\n                        let wOffset3 = wOffset2;\n                        for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {\n                            const xVal = xVals[xOffset3 + d1];\n                            for (let q = 0; q < chMul; ++q) {\n                                yVals[yOffset4 + q] += xVal * wVals[wOffset3 + q];\n                            }\n                            yOffset4 += chMul;\n                            wOffset3 += chMul;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo(y.shape, y.dtype, y.values);\n}\nexport const depthwiseConv2dNativeConfig = {\n    kernelName: DepthwiseConv2dNative,\n    backendName: 'cpu',\n    kernelFunc: depthwiseConv2dNative\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}