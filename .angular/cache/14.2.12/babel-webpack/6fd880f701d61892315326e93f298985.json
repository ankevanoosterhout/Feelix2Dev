{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { FlipLeftRight, util } from '@tensorflow/tfjs-core';\nexport const flipLeftRightConfig = {\n  kernelName: FlipLeftRight,\n  backendName: 'cpu',\n  kernelFunc: ({\n    inputs,\n    attrs,\n    backend\n  }) => {\n    const {\n      image\n    } = inputs;\n    const cpuBackend = backend;\n    const output = util.getTypedArrayFromDType(image.dtype, util.sizeFromShape(image.shape));\n    const [batch, imageHeight, imageWidth, numChannels] = image.shape;\n    const imageVals = cpuBackend.data.get(image.dataId).values;\n\n    for (let batchIdx = 0; batchIdx < batch; batchIdx++) {\n      const batchOffset = batchIdx * imageWidth * imageHeight * numChannels;\n\n      for (let row = 0; row < imageHeight; row++) {\n        const rowOffset = row * (imageWidth * numChannels);\n\n        for (let col = 0; col < imageWidth; col++) {\n          const colOffset = col * numChannels;\n\n          for (let channel = 0; channel < numChannels; channel++) {\n            const coordX = Math.round(imageWidth - col - 1);\n            const outIdx = batchOffset + rowOffset + colOffset + channel;\n            let outputValue = imageVals[outIdx]; // If the coordinate position falls within the image boundaries...\n\n            if (coordX >= 0 && coordX < imageWidth) {\n              // set the output to the image value at the coordinate position.\n              const rotatedColOffset = coordX * numChannels;\n              const imageIdx = batchOffset + rowOffset + rotatedColOffset + channel;\n              outputValue = imageVals[imageIdx];\n            }\n\n            output[outIdx] = outputValue;\n          }\n        }\n      }\n    }\n\n    const dataId = cpuBackend.write(output, image.shape, image.dtype);\n    return {\n      dataId,\n      shape: image.shape,\n      dtype: image.dtype\n    };\n  }\n};","map":{"version":3,"names":["FlipLeftRight","util","flipLeftRightConfig","kernelName","backendName","kernelFunc","inputs","attrs","backend","image","cpuBackend","output","getTypedArrayFromDType","dtype","sizeFromShape","shape","batch","imageHeight","imageWidth","numChannels","imageVals","data","get","dataId","values","batchIdx","batchOffset","row","rowOffset","col","colOffset","channel","coordX","Math","round","outIdx","outputValue","rotatedColOffset","imageIdx","write"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/FlipLeftRight.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { FlipLeftRight, util } from '@tensorflow/tfjs-core';\nexport const flipLeftRightConfig = {\n    kernelName: FlipLeftRight,\n    backendName: 'cpu',\n    kernelFunc: ({ inputs, attrs, backend }) => {\n        const { image } = inputs;\n        const cpuBackend = backend;\n        const output = util.getTypedArrayFromDType(image.dtype, util.sizeFromShape(image.shape));\n        const [batch, imageHeight, imageWidth, numChannels] = image.shape;\n        const imageVals = cpuBackend.data.get(image.dataId).values;\n        for (let batchIdx = 0; batchIdx < batch; batchIdx++) {\n            const batchOffset = batchIdx * imageWidth * imageHeight * numChannels;\n            for (let row = 0; row < imageHeight; row++) {\n                const rowOffset = row * (imageWidth * numChannels);\n                for (let col = 0; col < imageWidth; col++) {\n                    const colOffset = col * numChannels;\n                    for (let channel = 0; channel < numChannels; channel++) {\n                        const coordX = Math.round(imageWidth - col - 1);\n                        const outIdx = batchOffset + rowOffset + colOffset + channel;\n                        let outputValue = imageVals[outIdx];\n                        // If the coordinate position falls within the image boundaries...\n                        if (coordX >= 0 && coordX < imageWidth) {\n                            // set the output to the image value at the coordinate position.\n                            const rotatedColOffset = coordX * numChannels;\n                            const imageIdx = batchOffset + rowOffset + rotatedColOffset + channel;\n                            outputValue = imageVals[imageIdx];\n                        }\n                        output[outIdx] = outputValue;\n                    }\n                }\n            }\n        }\n        const dataId = cpuBackend.write(output, image.shape, image.dtype);\n        return { dataId, shape: image.shape, dtype: image.dtype };\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,aAAT,EAAwBC,IAAxB,QAAoC,uBAApC;AACA,OAAO,MAAMC,mBAAmB,GAAG;EAC/BC,UAAU,EAAEH,aADmB;EAE/BI,WAAW,EAAE,KAFkB;EAG/BC,UAAU,EAAE,CAAC;IAAEC,MAAF;IAAUC,KAAV;IAAiBC;EAAjB,CAAD,KAAgC;IACxC,MAAM;MAAEC;IAAF,IAAYH,MAAlB;IACA,MAAMI,UAAU,GAAGF,OAAnB;IACA,MAAMG,MAAM,GAAGV,IAAI,CAACW,sBAAL,CAA4BH,KAAK,CAACI,KAAlC,EAAyCZ,IAAI,CAACa,aAAL,CAAmBL,KAAK,CAACM,KAAzB,CAAzC,CAAf;IACA,MAAM,CAACC,KAAD,EAAQC,WAAR,EAAqBC,UAArB,EAAiCC,WAAjC,IAAgDV,KAAK,CAACM,KAA5D;IACA,MAAMK,SAAS,GAAGV,UAAU,CAACW,IAAX,CAAgBC,GAAhB,CAAoBb,KAAK,CAACc,MAA1B,EAAkCC,MAApD;;IACA,KAAK,IAAIC,QAAQ,GAAG,CAApB,EAAuBA,QAAQ,GAAGT,KAAlC,EAAyCS,QAAQ,EAAjD,EAAqD;MACjD,MAAMC,WAAW,GAAGD,QAAQ,GAAGP,UAAX,GAAwBD,WAAxB,GAAsCE,WAA1D;;MACA,KAAK,IAAIQ,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGV,WAAxB,EAAqCU,GAAG,EAAxC,EAA4C;QACxC,MAAMC,SAAS,GAAGD,GAAG,IAAIT,UAAU,GAAGC,WAAjB,CAArB;;QACA,KAAK,IAAIU,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGX,UAAxB,EAAoCW,GAAG,EAAvC,EAA2C;UACvC,MAAMC,SAAS,GAAGD,GAAG,GAAGV,WAAxB;;UACA,KAAK,IAAIY,OAAO,GAAG,CAAnB,EAAsBA,OAAO,GAAGZ,WAAhC,EAA6CY,OAAO,EAApD,EAAwD;YACpD,MAAMC,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWhB,UAAU,GAAGW,GAAb,GAAmB,CAA9B,CAAf;YACA,MAAMM,MAAM,GAAGT,WAAW,GAAGE,SAAd,GAA0BE,SAA1B,GAAsCC,OAArD;YACA,IAAIK,WAAW,GAAGhB,SAAS,CAACe,MAAD,CAA3B,CAHoD,CAIpD;;YACA,IAAIH,MAAM,IAAI,CAAV,IAAeA,MAAM,GAAGd,UAA5B,EAAwC;cACpC;cACA,MAAMmB,gBAAgB,GAAGL,MAAM,GAAGb,WAAlC;cACA,MAAMmB,QAAQ,GAAGZ,WAAW,GAAGE,SAAd,GAA0BS,gBAA1B,GAA6CN,OAA9D;cACAK,WAAW,GAAGhB,SAAS,CAACkB,QAAD,CAAvB;YACH;;YACD3B,MAAM,CAACwB,MAAD,CAAN,GAAiBC,WAAjB;UACH;QACJ;MACJ;IACJ;;IACD,MAAMb,MAAM,GAAGb,UAAU,CAAC6B,KAAX,CAAiB5B,MAAjB,EAAyBF,KAAK,CAACM,KAA/B,EAAsCN,KAAK,CAACI,KAA5C,CAAf;IACA,OAAO;MAAEU,MAAF;MAAUR,KAAK,EAAEN,KAAK,CAACM,KAAvB;MAA8BF,KAAK,EAAEJ,KAAK,CAACI;IAA3C,CAAP;EACH;AAjC8B,CAA5B"},"metadata":{},"sourceType":"module"}