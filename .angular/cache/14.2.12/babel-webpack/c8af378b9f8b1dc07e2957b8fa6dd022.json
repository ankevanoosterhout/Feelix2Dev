{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from './engine';\nimport { env } from './environment';\nimport { Tensor } from './tensor';\nimport { assert, flatten, inferDtype, isTypedArray, toTypedArray } from './util';\nexport function inferShape(val, dtype) {\n  let firstElem = val;\n\n  if (isTypedArray(val)) {\n    return dtype === 'string' ? [] : [val.length];\n  }\n\n  if (!Array.isArray(val)) {\n    return []; // Scalar.\n  }\n\n  const shape = [];\n\n  while (Array.isArray(firstElem) || isTypedArray(firstElem) && dtype !== 'string') {\n    shape.push(firstElem.length);\n    firstElem = firstElem[0];\n  }\n\n  if (Array.isArray(val) && env().getBool('TENSORLIKE_CHECK_SHAPE_CONSISTENCY')) {\n    deepAssertShapeConsistency(val, shape, []);\n  }\n\n  return shape;\n}\n\nfunction deepAssertShapeConsistency(val, shape, indices) {\n  indices = indices || [];\n\n  if (!Array.isArray(val) && !isTypedArray(val)) {\n    assert(shape.length === 0, () => `Element arr[${indices.join('][')}] is a primitive, ` + `but should be an array/TypedArray of ${shape[0]} elements`);\n    return;\n  }\n\n  assert(shape.length > 0, () => `Element arr[${indices.join('][')}] should be a primitive, ` + `but is an array of ${val.length} elements`);\n  assert(val.length === shape[0], () => `Element arr[${indices.join('][')}] should have ${shape[0]} ` + `elements, but has ${val.length} elements`);\n  const subShape = shape.slice(1);\n\n  for (let i = 0; i < val.length; ++i) {\n    deepAssertShapeConsistency(val[i], subShape, indices.concat(i));\n  }\n}\n\nfunction assertDtype(expectedDtype, actualDType, argName, functionName) {\n  if (expectedDtype === 'string_or_numeric') {\n    return;\n  }\n\n  if (expectedDtype == null) {\n    throw new Error(`Expected dtype cannot be null.`);\n  }\n\n  if (expectedDtype !== 'numeric' && expectedDtype !== actualDType || expectedDtype === 'numeric' && actualDType === 'string') {\n    throw new Error(`Argument '${argName}' passed to '${functionName}' must ` + `be ${expectedDtype} tensor, but got ${actualDType} tensor`);\n  }\n}\n\nexport function convertToTensor(x, argName, functionName, parseAsDtype = 'numeric') {\n  if (x instanceof Tensor) {\n    assertDtype(parseAsDtype, x.dtype, argName, functionName);\n    return x;\n  }\n\n  let inferredDtype = inferDtype(x); // If the user expects a bool/int/float, use that info to update the\n  // inferredDtype when it is not a string.\n\n  if (inferredDtype !== 'string' && ['bool', 'int32', 'float32'].indexOf(parseAsDtype) >= 0) {\n    inferredDtype = parseAsDtype;\n  }\n\n  assertDtype(parseAsDtype, inferredDtype, argName, functionName);\n\n  if (x == null || !isTypedArray(x) && !Array.isArray(x) && typeof x !== 'number' && typeof x !== 'boolean' && typeof x !== 'string') {\n    const type = x == null ? 'null' : x.constructor.name;\n    throw new Error(`Argument '${argName}' passed to '${functionName}' must be a ` + `Tensor or TensorLike, but got '${type}'`);\n  }\n\n  const inferredShape = inferShape(x, inferredDtype);\n\n  if (!isTypedArray(x) && !Array.isArray(x)) {\n    x = [x];\n  }\n\n  const skipTypedArray = true;\n  const values = inferredDtype !== 'string' ? toTypedArray(x, inferredDtype) : flatten(x, [], skipTypedArray);\n  return ENGINE.makeTensor(values, inferredShape, inferredDtype);\n}\nexport function convertToTensorArray(arg, argName, functionName, parseAsDtype = 'numeric') {\n  if (!Array.isArray(arg)) {\n    throw new Error(`Argument ${argName} passed to ${functionName} must be a ` + '`Tensor[]` or `TensorLike[]`');\n  }\n\n  const tensors = arg;\n  return tensors.map((t, i) => convertToTensor(t, `${argName}[${i}]`, functionName, parseAsDtype));\n}","map":{"version":3,"names":["ENGINE","env","Tensor","assert","flatten","inferDtype","isTypedArray","toTypedArray","inferShape","val","dtype","firstElem","length","Array","isArray","shape","push","getBool","deepAssertShapeConsistency","indices","join","subShape","slice","i","concat","assertDtype","expectedDtype","actualDType","argName","functionName","Error","convertToTensor","x","parseAsDtype","inferredDtype","indexOf","type","constructor","name","inferredShape","skipTypedArray","values","makeTensor","convertToTensorArray","arg","tensors","map","t"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-core/dist/tensor_util_env.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from './engine';\nimport { env } from './environment';\nimport { Tensor } from './tensor';\nimport { assert, flatten, inferDtype, isTypedArray, toTypedArray } from './util';\nexport function inferShape(val, dtype) {\n    let firstElem = val;\n    if (isTypedArray(val)) {\n        return dtype === 'string' ? [] : [val.length];\n    }\n    if (!Array.isArray(val)) {\n        return []; // Scalar.\n    }\n    const shape = [];\n    while (Array.isArray(firstElem) ||\n        isTypedArray(firstElem) && dtype !== 'string') {\n        shape.push(firstElem.length);\n        firstElem = firstElem[0];\n    }\n    if (Array.isArray(val) &&\n        env().getBool('TENSORLIKE_CHECK_SHAPE_CONSISTENCY')) {\n        deepAssertShapeConsistency(val, shape, []);\n    }\n    return shape;\n}\nfunction deepAssertShapeConsistency(val, shape, indices) {\n    indices = indices || [];\n    if (!(Array.isArray(val)) && !isTypedArray(val)) {\n        assert(shape.length === 0, () => `Element arr[${indices.join('][')}] is a primitive, ` +\n            `but should be an array/TypedArray of ${shape[0]} elements`);\n        return;\n    }\n    assert(shape.length > 0, () => `Element arr[${indices.join('][')}] should be a primitive, ` +\n        `but is an array of ${val.length} elements`);\n    assert(val.length === shape[0], () => `Element arr[${indices.join('][')}] should have ${shape[0]} ` +\n        `elements, but has ${val.length} elements`);\n    const subShape = shape.slice(1);\n    for (let i = 0; i < val.length; ++i) {\n        deepAssertShapeConsistency(val[i], subShape, indices.concat(i));\n    }\n}\nfunction assertDtype(expectedDtype, actualDType, argName, functionName) {\n    if (expectedDtype === 'string_or_numeric') {\n        return;\n    }\n    if (expectedDtype == null) {\n        throw new Error(`Expected dtype cannot be null.`);\n    }\n    if (expectedDtype !== 'numeric' && expectedDtype !== actualDType ||\n        expectedDtype === 'numeric' && actualDType === 'string') {\n        throw new Error(`Argument '${argName}' passed to '${functionName}' must ` +\n            `be ${expectedDtype} tensor, but got ${actualDType} tensor`);\n    }\n}\nexport function convertToTensor(x, argName, functionName, parseAsDtype = 'numeric') {\n    if (x instanceof Tensor) {\n        assertDtype(parseAsDtype, x.dtype, argName, functionName);\n        return x;\n    }\n    let inferredDtype = inferDtype(x);\n    // If the user expects a bool/int/float, use that info to update the\n    // inferredDtype when it is not a string.\n    if (inferredDtype !== 'string' &&\n        ['bool', 'int32', 'float32'].indexOf(parseAsDtype) >= 0) {\n        inferredDtype = parseAsDtype;\n    }\n    assertDtype(parseAsDtype, inferredDtype, argName, functionName);\n    if ((x == null) ||\n        (!isTypedArray(x) && !Array.isArray(x) && typeof x !== 'number' &&\n            typeof x !== 'boolean' && typeof x !== 'string')) {\n        const type = x == null ? 'null' : x.constructor.name;\n        throw new Error(`Argument '${argName}' passed to '${functionName}' must be a ` +\n            `Tensor or TensorLike, but got '${type}'`);\n    }\n    const inferredShape = inferShape(x, inferredDtype);\n    if (!isTypedArray(x) && !Array.isArray(x)) {\n        x = [x];\n    }\n    const skipTypedArray = true;\n    const values = inferredDtype !== 'string' ?\n        toTypedArray(x, inferredDtype) :\n        flatten(x, [], skipTypedArray);\n    return ENGINE.makeTensor(values, inferredShape, inferredDtype);\n}\nexport function convertToTensorArray(arg, argName, functionName, parseAsDtype = 'numeric') {\n    if (!Array.isArray(arg)) {\n        throw new Error(`Argument ${argName} passed to ${functionName} must be a ` +\n            '`Tensor[]` or `TensorLike[]`');\n    }\n    const tensors = arg;\n    return tensors.map((t, i) => convertToTensor(t, `${argName}[${i}]`, functionName, parseAsDtype));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}