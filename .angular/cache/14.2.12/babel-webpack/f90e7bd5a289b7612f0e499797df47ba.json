{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\n/**\n *\n * @param inputShape Input tensor shape is of the following dimensions:\n *     `[batch, height, width, inChannels]`.\n * @param filterShape The filter shape is of the following dimensions:\n *     `[filterHeight, filterWidth, depth]`.\n * @param strides The strides of the sliding window for each dimension of the\n *     input tensor: `[strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dataFormat The data format of the input and output data.\n *     Defaults to 'NHWC'.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`.\n *     Defaults to `[1, 1]`. If `dilations` is a single number, then\n *     `dilationHeight == dilationWidth`.\n */\n\nexport function computeDilation2DInfo(inputShape, filterShape, strides, pad, dataFormat = 'NHWC', dilations) {\n  // `computerConv2DInfo` require filterShape to be in the dimension of:\n  // `[filterHeight, filterWidth, depth, outDepth]`, dilation2d doesn't have\n  // outDepth, it should have the same depth as the input.\n  // Input shape: [batch, height, width, inChannels]\n  const inputChannels = inputShape[3];\n  const $filterShape = [...filterShape, inputChannels];\n  const $dataFormat = convertConv2DDataFormat(dataFormat);\n  return computeConv2DInfo(inputShape, $filterShape, strides, dilations, pad, null\n  /* roundingMode */\n  , null\n  /* depthWise */\n  , $dataFormat);\n}\nexport function computePool2DInfo(inShape, filterSize, strides, dilations, pad, roundingMode, dataFormat = 'channelsLast') {\n  const [filterHeight, filterWidth] = parseTupleParam(filterSize);\n  let filterShape;\n\n  if (dataFormat === 'channelsLast') {\n    filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];\n  } else if (dataFormat === 'channelsFirst') {\n    filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  return computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, false, dataFormat);\n}\n/**\n * Computes the information for a forward pass of a pooling3D operation.\n */\n\nexport function computePool3DInfo(inShape, filterSize, strides, dilations, pad, roundingMode, dataFormat = 'NDHWC') {\n  const [filterDepth, filterHeight, filterWidth] = parse3TupleParam(filterSize);\n  let filterShape;\n  let $dataFormat;\n\n  if (dataFormat === 'NDHWC') {\n    $dataFormat = 'channelsLast';\n    filterShape = [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];\n  } else if (dataFormat === 'NCDHW') {\n    $dataFormat = 'channelsFirst';\n    filterShape = [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  return computeConv3DInfo(inShape, filterShape, strides, dilations, pad, false, $dataFormat, roundingMode);\n}\n/**\n * Computes the information for a forward pass of a convolution/pooling\n * operation.\n */\n\nexport function computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, depthwise = false, dataFormat = 'channelsLast') {\n  let [batchSize, inHeight, inWidth, inChannels] = [-1, -1, -1, -1];\n\n  if (dataFormat === 'channelsLast') {\n    [batchSize, inHeight, inWidth, inChannels] = inShape;\n  } else if (dataFormat === 'channelsFirst') {\n    [batchSize, inChannels, inHeight, inWidth] = inShape;\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  const [filterHeight, filterWidth,, filterChannels] = filterShape;\n  const [strideHeight, strideWidth] = parseTupleParam(strides);\n  const [dilationHeight, dilationWidth] = parseTupleParam(dilations);\n  const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);\n  const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);\n  const {\n    padInfo,\n    outHeight,\n    outWidth\n  } = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode, dataFormat);\n  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n  let outShape;\n\n  if (dataFormat === 'channelsFirst') {\n    outShape = [batchSize, outChannels, outHeight, outWidth];\n  } else if (dataFormat === 'channelsLast') {\n    outShape = [batchSize, outHeight, outWidth, outChannels];\n  }\n\n  return {\n    batchSize,\n    dataFormat,\n    inHeight,\n    inWidth,\n    inChannels,\n    outHeight,\n    outWidth,\n    outChannels,\n    padInfo,\n    strideHeight,\n    strideWidth,\n    filterHeight,\n    filterWidth,\n    effectiveFilterHeight,\n    effectiveFilterWidth,\n    dilationHeight,\n    dilationWidth,\n    inShape,\n    outShape,\n    filterShape\n  };\n}\n/**\n * Computes the information for a forward pass of a 3D convolution/pooling\n * operation.\n */\n\nexport function computeConv3DInfo(inShape, filterShape, strides, dilations, pad, depthwise = false, dataFormat = 'channelsLast', roundingMode) {\n  let [batchSize, inDepth, inHeight, inWidth, inChannels] = [-1, -1, -1, -1, -1];\n\n  if (dataFormat === 'channelsLast') {\n    [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;\n  } else if (dataFormat === 'channelsFirst') {\n    [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  const [filterDepth, filterHeight, filterWidth,, filterChannels] = filterShape;\n  const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);\n  const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);\n  const effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);\n  const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);\n  const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);\n  const {\n    padInfo,\n    outDepth,\n    outHeight,\n    outWidth\n  } = get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth, roundingMode);\n  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n  let outShape;\n\n  if (dataFormat === 'channelsFirst') {\n    outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];\n  } else if (dataFormat === 'channelsLast') {\n    outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];\n  }\n\n  return {\n    batchSize,\n    dataFormat,\n    inDepth,\n    inHeight,\n    inWidth,\n    inChannels,\n    outDepth,\n    outHeight,\n    outWidth,\n    outChannels,\n    padInfo,\n    strideDepth,\n    strideHeight,\n    strideWidth,\n    filterDepth,\n    filterHeight,\n    filterWidth,\n    effectiveFilterDepth,\n    effectiveFilterHeight,\n    effectiveFilterWidth,\n    dilationDepth,\n    dilationHeight,\n    dilationWidth,\n    inShape,\n    outShape,\n    filterShape\n  };\n}\n\nfunction computeOutputShape2D(inShape, fieldSize, stride, zeroPad, roundingMode) {\n  if (zeroPad == null) {\n    zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n  }\n\n  const inputRows = inShape[0];\n  const inputCols = inShape[1];\n  const outputRows = round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  const outputCols = round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  return [outputRows, outputCols];\n}\n\nfunction computeOutputShape4D(inShape, fieldSize, outChannels, stride, zeroPad, roundingMode) {\n  if (zeroPad == null) {\n    zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n  }\n\n  const inputDepth = inShape[0];\n  const inputRows = inShape[1];\n  const inputCols = inShape[2];\n  const outputDepths = round((inputDepth - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  const outputRows = round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  const outputCols = round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  return [outputDepths, outputRows, outputCols, outChannels];\n}\n\nexport function computeDefaultPad(inputShape, fieldSize, stride, dilation = 1) {\n  const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);\n  return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);\n}\n\nfunction parseTupleParam(param) {\n  if (typeof param === 'number') {\n    return [param, param, param];\n  }\n\n  if (param.length === 2) {\n    return [param[0], param[1], 1];\n  }\n\n  return param;\n}\n\nfunction parse3TupleParam(param) {\n  return typeof param === 'number' ? [param, param, param] : param;\n}\n/* See https://www.tensorflow.org/api_docs/python/tf/nn/atrous_conv2d\n * Atrous convolution is equivalent to standard convolution with upsampled\n * filters with effective_filter_height =\n * filter_height + (filter_height - 1) * (dilation - 1)\n * and effective_filter_width =\n * filter_width + (filter_width - 1) * (dilation - 1),\n * produced by inserting dilation - 1 zeros along consecutive elements across\n * the filters' spatial dimensions.\n * When there is a dilation, this converts a filter dimension to the\n * effective filter dimension, so it can be used in a standard convolution.\n */\n\n\nfunction getEffectiveFilterSize(filterSize, dilation) {\n  if (dilation <= 1) {\n    return filterSize;\n  }\n\n  return filterSize + (filterSize - 1) * (dilation - 1);\n}\n\nfunction getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode, dataFormat) {\n  let padInfo;\n  let outHeight;\n  let outWidth;\n\n  if (typeof pad === 'number') {\n    const padType = pad === 0 ? 'VALID' : 'NUMBER';\n    padInfo = {\n      top: pad,\n      bottom: pad,\n      left: pad,\n      right: pad,\n      type: padType\n    };\n    const outShape = computeOutputShape2D([inHeight, inWidth], filterHeight, strideHeight, pad, roundingMode);\n    outHeight = outShape[0];\n    outWidth = outShape[1];\n  } else if (pad === 'same') {\n    outHeight = Math.ceil(inHeight / strideHeight);\n    outWidth = Math.ceil(inWidth / strideWidth);\n    const padAlongHeight = Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);\n    const padAlongWidth = Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);\n    const top = Math.floor(padAlongHeight / 2);\n    const bottom = padAlongHeight - top;\n    const left = Math.floor(padAlongWidth / 2);\n    const right = padAlongWidth - left;\n    padInfo = {\n      top,\n      bottom,\n      left,\n      right,\n      type: 'SAME'\n    };\n  } else if (pad === 'valid') {\n    padInfo = {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      type: 'VALID'\n    };\n    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n  } else if (typeof pad === 'object') {\n    const top = dataFormat === 'channelsLast' ? pad[1][0] : pad[2][0];\n    const bottom = dataFormat === 'channelsLast' ? pad[1][1] : pad[2][1];\n    const left = dataFormat === 'channelsLast' ? pad[2][0] : pad[3][0];\n    const right = dataFormat === 'channelsLast' ? pad[2][1] : pad[3][1];\n    const padType = top === 0 && bottom === 0 && left === 0 && right === 0 ? 'VALID' : 'EXPLICIT';\n    padInfo = {\n      top,\n      bottom,\n      left,\n      right,\n      type: padType\n    };\n    outHeight = round((inHeight - filterHeight + top + bottom) / strideHeight + 1, roundingMode);\n    outWidth = round((inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);\n  } else {\n    throw Error(`Unknown padding parameter: ${pad}`);\n  }\n\n  return {\n    padInfo,\n    outHeight,\n    outWidth\n  };\n}\n\nfunction get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth, roundingMode) {\n  let padInfo;\n  let outDepth;\n  let outHeight;\n  let outWidth;\n\n  if (typeof pad === 'number') {\n    const padType = pad === 0 ? 'VALID' : 'NUMBER';\n    padInfo = {\n      top: pad,\n      bottom: pad,\n      left: pad,\n      right: pad,\n      front: pad,\n      back: pad,\n      type: padType\n    };\n    const outShape = computeOutputShape4D([inDepth, inHeight, inWidth, 1], filterDepth, 1, strideDepth, pad, roundingMode);\n    outDepth = outShape[0];\n    outHeight = outShape[1];\n    outWidth = outShape[2];\n  } else if (pad === 'same') {\n    outDepth = Math.ceil(inDepth / strideDepth);\n    outHeight = Math.ceil(inHeight / strideHeight);\n    outWidth = Math.ceil(inWidth / strideWidth);\n    const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;\n    const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;\n    const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;\n    const front = Math.floor(padAlongDepth / 2);\n    const back = padAlongDepth - front;\n    const top = Math.floor(padAlongHeight / 2);\n    const bottom = padAlongHeight - top;\n    const left = Math.floor(padAlongWidth / 2);\n    const right = padAlongWidth - left;\n    padInfo = {\n      top,\n      bottom,\n      left,\n      right,\n      front,\n      back,\n      type: 'SAME'\n    };\n  } else if (pad === 'valid') {\n    padInfo = {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      front: 0,\n      back: 0,\n      type: 'VALID'\n    };\n    outDepth = Math.ceil((inDepth - filterDepth + 1) / strideDepth);\n    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n  } else {\n    throw Error(`Unknown padding parameter: ${pad}`);\n  }\n\n  return {\n    padInfo,\n    outDepth,\n    outHeight,\n    outWidth\n  };\n}\n/**\n * Rounds a value depending on the rounding mode\n * @param value\n * @param roundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n */\n\n\nfunction round(value, roundingMode) {\n  if (!roundingMode) {\n    return Math.trunc(value);\n  }\n\n  switch (roundingMode) {\n    case 'round':\n      // used for Caffe Conv\n      return Math.round(value);\n\n    case 'ceil':\n      // used for Caffe Pool\n      return Math.ceil(value);\n\n    case 'floor':\n      return Math.floor(value);\n\n    default:\n      throw new Error(`Unknown roundingMode ${roundingMode}`);\n  }\n}\n\nexport function tupleValuesAreOne(param) {\n  const [dimA, dimB, dimC] = parseTupleParam(param);\n  return dimA === 1 && dimB === 1 && dimC === 1;\n}\nexport function eitherStridesOrDilationsAreOne(strides, dilations) {\n  return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);\n}\n/**\n * Convert Conv2D dataFormat from 'NHWC'|'NCHW' to\n *    'channelsLast'|'channelsFirst'\n * @param dataFormat in 'NHWC'|'NCHW' mode\n * @return dataFormat in 'channelsLast'|'channelsFirst' mode\n * @throws unknown dataFormat\n */\n\nexport function convertConv2DDataFormat(dataFormat) {\n  if (dataFormat === 'NHWC') {\n    return 'channelsLast';\n  } else if (dataFormat === 'NCHW') {\n    return 'channelsFirst';\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n}\n/**\n * Check validity of pad when using dimRoundingMode.\n * @param opDesc A string of op description\n * @param pad The type of padding algorithm.\n *   - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *   - `valid` output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n * @throws unknown padding parameter\n */\n\nexport function checkPadOnDimRoundingMode(opDesc, pad, dimRoundingMode) {\n  if (dimRoundingMode != null) {\n    if (typeof pad === 'string') {\n      throw Error(`Error in ${opDesc}: pad must be an integer when using ` + `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    } else if (typeof pad === 'number') {\n      util.assert(util.isInt(pad), () => `Error in ${opDesc}: pad must be an integer when using ` + `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    } else if (typeof pad === 'object') {\n      pad.forEach(p => {\n        p.forEach(v => {\n          util.assert(util.isInt(v), () => `Error in ${opDesc}: pad must be an integer when using ` + `dimRoundingMode ${dimRoundingMode} but got pad ${v}.`);\n        });\n      });\n    } else {\n      throw Error(`Error in ${opDesc}: Unknown padding parameter: ${pad}`);\n    }\n  }\n}","map":{"version":3,"names":["util","computeDilation2DInfo","inputShape","filterShape","strides","pad","dataFormat","dilations","inputChannels","$filterShape","$dataFormat","convertConv2DDataFormat","computeConv2DInfo","computePool2DInfo","inShape","filterSize","roundingMode","filterHeight","filterWidth","parseTupleParam","Error","computePool3DInfo","filterDepth","parse3TupleParam","computeConv3DInfo","depthwise","batchSize","inHeight","inWidth","inChannels","filterChannels","strideHeight","strideWidth","dilationHeight","dilationWidth","effectiveFilterHeight","getEffectiveFilterSize","effectiveFilterWidth","padInfo","outHeight","outWidth","getPadAndOutInfo","outChannels","outShape","inDepth","strideDepth","dilationDepth","effectiveFilterDepth","outDepth","get3DPadAndOutInfo","computeOutputShape2D","fieldSize","stride","zeroPad","computeDefaultPad","inputRows","inputCols","outputRows","round","outputCols","computeOutputShape4D","inputDepth","outputDepths","dilation","effectiveFieldSize","Math","floor","param","length","padType","top","bottom","left","right","type","ceil","padAlongHeight","max","padAlongWidth","front","back","padAlongDepth","value","trunc","tupleValuesAreOne","dimA","dimB","dimC","eitherStridesOrDilationsAreOne","checkPadOnDimRoundingMode","opDesc","dimRoundingMode","assert","isInt","forEach","p","v"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-core/dist/ops/conv_util.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\n/**\n *\n * @param inputShape Input tensor shape is of the following dimensions:\n *     `[batch, height, width, inChannels]`.\n * @param filterShape The filter shape is of the following dimensions:\n *     `[filterHeight, filterWidth, depth]`.\n * @param strides The strides of the sliding window for each dimension of the\n *     input tensor: `[strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dataFormat The data format of the input and output data.\n *     Defaults to 'NHWC'.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`.\n *     Defaults to `[1, 1]`. If `dilations` is a single number, then\n *     `dilationHeight == dilationWidth`.\n */\nexport function computeDilation2DInfo(inputShape, filterShape, strides, pad, dataFormat = 'NHWC', dilations) {\n    // `computerConv2DInfo` require filterShape to be in the dimension of:\n    // `[filterHeight, filterWidth, depth, outDepth]`, dilation2d doesn't have\n    // outDepth, it should have the same depth as the input.\n    // Input shape: [batch, height, width, inChannels]\n    const inputChannels = inputShape[3];\n    const $filterShape = [...filterShape, inputChannels];\n    const $dataFormat = convertConv2DDataFormat(dataFormat);\n    return computeConv2DInfo(inputShape, $filterShape, strides, dilations, pad, null /* roundingMode */, null /* depthWise */, $dataFormat);\n}\nexport function computePool2DInfo(inShape, filterSize, strides, dilations, pad, roundingMode, dataFormat = 'channelsLast') {\n    const [filterHeight, filterWidth] = parseTupleParam(filterSize);\n    let filterShape;\n    if (dataFormat === 'channelsLast') {\n        filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];\n    }\n    else if (dataFormat === 'channelsFirst') {\n        filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];\n    }\n    else {\n        throw new Error(`Unknown dataFormat ${dataFormat}`);\n    }\n    return computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, false, dataFormat);\n}\n/**\n * Computes the information for a forward pass of a pooling3D operation.\n */\nexport function computePool3DInfo(inShape, filterSize, strides, dilations, pad, roundingMode, dataFormat = 'NDHWC') {\n    const [filterDepth, filterHeight, filterWidth] = parse3TupleParam(filterSize);\n    let filterShape;\n    let $dataFormat;\n    if (dataFormat === 'NDHWC') {\n        $dataFormat = 'channelsLast';\n        filterShape =\n            [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];\n    }\n    else if (dataFormat === 'NCDHW') {\n        $dataFormat = 'channelsFirst';\n        filterShape =\n            [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];\n    }\n    else {\n        throw new Error(`Unknown dataFormat ${dataFormat}`);\n    }\n    return computeConv3DInfo(inShape, filterShape, strides, dilations, pad, false, $dataFormat, roundingMode);\n}\n/**\n * Computes the information for a forward pass of a convolution/pooling\n * operation.\n */\nexport function computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, depthwise = false, dataFormat = 'channelsLast') {\n    let [batchSize, inHeight, inWidth, inChannels] = [-1, -1, -1, -1];\n    if (dataFormat === 'channelsLast') {\n        [batchSize, inHeight, inWidth, inChannels] = inShape;\n    }\n    else if (dataFormat === 'channelsFirst') {\n        [batchSize, inChannels, inHeight, inWidth] = inShape;\n    }\n    else {\n        throw new Error(`Unknown dataFormat ${dataFormat}`);\n    }\n    const [filterHeight, filterWidth, , filterChannels] = filterShape;\n    const [strideHeight, strideWidth] = parseTupleParam(strides);\n    const [dilationHeight, dilationWidth] = parseTupleParam(dilations);\n    const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);\n    const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);\n    const { padInfo, outHeight, outWidth } = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode, dataFormat);\n    const outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n    let outShape;\n    if (dataFormat === 'channelsFirst') {\n        outShape = [batchSize, outChannels, outHeight, outWidth];\n    }\n    else if (dataFormat === 'channelsLast') {\n        outShape = [batchSize, outHeight, outWidth, outChannels];\n    }\n    return {\n        batchSize,\n        dataFormat,\n        inHeight,\n        inWidth,\n        inChannels,\n        outHeight,\n        outWidth,\n        outChannels,\n        padInfo,\n        strideHeight,\n        strideWidth,\n        filterHeight,\n        filterWidth,\n        effectiveFilterHeight,\n        effectiveFilterWidth,\n        dilationHeight,\n        dilationWidth,\n        inShape,\n        outShape,\n        filterShape\n    };\n}\n/**\n * Computes the information for a forward pass of a 3D convolution/pooling\n * operation.\n */\nexport function computeConv3DInfo(inShape, filterShape, strides, dilations, pad, depthwise = false, dataFormat = 'channelsLast', roundingMode) {\n    let [batchSize, inDepth, inHeight, inWidth, inChannels] = [-1, -1, -1, -1, -1];\n    if (dataFormat === 'channelsLast') {\n        [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;\n    }\n    else if (dataFormat === 'channelsFirst') {\n        [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;\n    }\n    else {\n        throw new Error(`Unknown dataFormat ${dataFormat}`);\n    }\n    const [filterDepth, filterHeight, filterWidth, , filterChannels] = filterShape;\n    const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);\n    const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);\n    const effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);\n    const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);\n    const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);\n    const { padInfo, outDepth, outHeight, outWidth } = get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth, roundingMode);\n    const outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n    let outShape;\n    if (dataFormat === 'channelsFirst') {\n        outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];\n    }\n    else if (dataFormat === 'channelsLast') {\n        outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];\n    }\n    return {\n        batchSize,\n        dataFormat,\n        inDepth,\n        inHeight,\n        inWidth,\n        inChannels,\n        outDepth,\n        outHeight,\n        outWidth,\n        outChannels,\n        padInfo,\n        strideDepth,\n        strideHeight,\n        strideWidth,\n        filterDepth,\n        filterHeight,\n        filterWidth,\n        effectiveFilterDepth,\n        effectiveFilterHeight,\n        effectiveFilterWidth,\n        dilationDepth,\n        dilationHeight,\n        dilationWidth,\n        inShape,\n        outShape,\n        filterShape\n    };\n}\nfunction computeOutputShape2D(inShape, fieldSize, stride, zeroPad, roundingMode) {\n    if (zeroPad == null) {\n        zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n    }\n    const inputRows = inShape[0];\n    const inputCols = inShape[1];\n    const outputRows = round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n    const outputCols = round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n    return [outputRows, outputCols];\n}\nfunction computeOutputShape4D(inShape, fieldSize, outChannels, stride, zeroPad, roundingMode) {\n    if (zeroPad == null) {\n        zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n    }\n    const inputDepth = inShape[0];\n    const inputRows = inShape[1];\n    const inputCols = inShape[2];\n    const outputDepths = round((inputDepth - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n    const outputRows = round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n    const outputCols = round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n    return [outputDepths, outputRows, outputCols, outChannels];\n}\nexport function computeDefaultPad(inputShape, fieldSize, stride, dilation = 1) {\n    const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);\n    return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);\n}\nfunction parseTupleParam(param) {\n    if (typeof param === 'number') {\n        return [param, param, param];\n    }\n    if (param.length === 2) {\n        return [param[0], param[1], 1];\n    }\n    return param;\n}\nfunction parse3TupleParam(param) {\n    return typeof param === 'number' ? [param, param, param] : param;\n}\n/* See https://www.tensorflow.org/api_docs/python/tf/nn/atrous_conv2d\n * Atrous convolution is equivalent to standard convolution with upsampled\n * filters with effective_filter_height =\n * filter_height + (filter_height - 1) * (dilation - 1)\n * and effective_filter_width =\n * filter_width + (filter_width - 1) * (dilation - 1),\n * produced by inserting dilation - 1 zeros along consecutive elements across\n * the filters' spatial dimensions.\n * When there is a dilation, this converts a filter dimension to the\n * effective filter dimension, so it can be used in a standard convolution.\n */\nfunction getEffectiveFilterSize(filterSize, dilation) {\n    if (dilation <= 1) {\n        return filterSize;\n    }\n    return filterSize + (filterSize - 1) * (dilation - 1);\n}\nfunction getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode, dataFormat) {\n    let padInfo;\n    let outHeight;\n    let outWidth;\n    if (typeof pad === 'number') {\n        const padType = (pad === 0) ? 'VALID' : 'NUMBER';\n        padInfo = { top: pad, bottom: pad, left: pad, right: pad, type: padType };\n        const outShape = computeOutputShape2D([inHeight, inWidth], filterHeight, strideHeight, pad, roundingMode);\n        outHeight = outShape[0];\n        outWidth = outShape[1];\n    }\n    else if (pad === 'same') {\n        outHeight = Math.ceil(inHeight / strideHeight);\n        outWidth = Math.ceil(inWidth / strideWidth);\n        const padAlongHeight = Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);\n        const padAlongWidth = Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);\n        const top = Math.floor(padAlongHeight / 2);\n        const bottom = padAlongHeight - top;\n        const left = Math.floor(padAlongWidth / 2);\n        const right = padAlongWidth - left;\n        padInfo = { top, bottom, left, right, type: 'SAME' };\n    }\n    else if (pad === 'valid') {\n        padInfo = { top: 0, bottom: 0, left: 0, right: 0, type: 'VALID' };\n        outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n        outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n    }\n    else if (typeof pad === 'object') {\n        const top = dataFormat === 'channelsLast' ? pad[1][0] : pad[2][0];\n        const bottom = dataFormat === 'channelsLast' ? pad[1][1] : pad[2][1];\n        const left = dataFormat === 'channelsLast' ? pad[2][0] : pad[3][0];\n        const right = dataFormat === 'channelsLast' ? pad[2][1] : pad[3][1];\n        const padType = (top === 0 && bottom === 0 && left === 0 && right === 0) ?\n            'VALID' :\n            'EXPLICIT';\n        padInfo = { top, bottom, left, right, type: padType };\n        outHeight = round((inHeight - filterHeight + top + bottom) / strideHeight + 1, roundingMode);\n        outWidth = round((inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);\n    }\n    else {\n        throw Error(`Unknown padding parameter: ${pad}`);\n    }\n    return { padInfo, outHeight, outWidth };\n}\nfunction get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth, roundingMode) {\n    let padInfo;\n    let outDepth;\n    let outHeight;\n    let outWidth;\n    if (typeof pad === 'number') {\n        const padType = (pad === 0) ? 'VALID' : 'NUMBER';\n        padInfo = {\n            top: pad,\n            bottom: pad,\n            left: pad,\n            right: pad,\n            front: pad,\n            back: pad,\n            type: padType\n        };\n        const outShape = computeOutputShape4D([inDepth, inHeight, inWidth, 1], filterDepth, 1, strideDepth, pad, roundingMode);\n        outDepth = outShape[0];\n        outHeight = outShape[1];\n        outWidth = outShape[2];\n    }\n    else if (pad === 'same') {\n        outDepth = Math.ceil(inDepth / strideDepth);\n        outHeight = Math.ceil(inHeight / strideHeight);\n        outWidth = Math.ceil(inWidth / strideWidth);\n        const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;\n        const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;\n        const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;\n        const front = Math.floor(padAlongDepth / 2);\n        const back = padAlongDepth - front;\n        const top = Math.floor(padAlongHeight / 2);\n        const bottom = padAlongHeight - top;\n        const left = Math.floor(padAlongWidth / 2);\n        const right = padAlongWidth - left;\n        padInfo = { top, bottom, left, right, front, back, type: 'SAME' };\n    }\n    else if (pad === 'valid') {\n        padInfo = {\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0,\n            front: 0,\n            back: 0,\n            type: 'VALID'\n        };\n        outDepth = Math.ceil((inDepth - filterDepth + 1) / strideDepth);\n        outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n        outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n    }\n    else {\n        throw Error(`Unknown padding parameter: ${pad}`);\n    }\n    return { padInfo, outDepth, outHeight, outWidth };\n}\n/**\n * Rounds a value depending on the rounding mode\n * @param value\n * @param roundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n */\nfunction round(value, roundingMode) {\n    if (!roundingMode) {\n        return Math.trunc(value);\n    }\n    switch (roundingMode) {\n        case 'round':\n            // used for Caffe Conv\n            return Math.round(value);\n        case 'ceil':\n            // used for Caffe Pool\n            return Math.ceil(value);\n        case 'floor':\n            return Math.floor(value);\n        default:\n            throw new Error(`Unknown roundingMode ${roundingMode}`);\n    }\n}\nexport function tupleValuesAreOne(param) {\n    const [dimA, dimB, dimC] = parseTupleParam(param);\n    return dimA === 1 && dimB === 1 && dimC === 1;\n}\nexport function eitherStridesOrDilationsAreOne(strides, dilations) {\n    return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);\n}\n/**\n * Convert Conv2D dataFormat from 'NHWC'|'NCHW' to\n *    'channelsLast'|'channelsFirst'\n * @param dataFormat in 'NHWC'|'NCHW' mode\n * @return dataFormat in 'channelsLast'|'channelsFirst' mode\n * @throws unknown dataFormat\n */\nexport function convertConv2DDataFormat(dataFormat) {\n    if (dataFormat === 'NHWC') {\n        return 'channelsLast';\n    }\n    else if (dataFormat === 'NCHW') {\n        return 'channelsFirst';\n    }\n    else {\n        throw new Error(`Unknown dataFormat ${dataFormat}`);\n    }\n}\n/**\n * Check validity of pad when using dimRoundingMode.\n * @param opDesc A string of op description\n * @param pad The type of padding algorithm.\n *   - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *   - `valid` output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n * @throws unknown padding parameter\n */\nexport function checkPadOnDimRoundingMode(opDesc, pad, dimRoundingMode) {\n    if (dimRoundingMode != null) {\n        if (typeof pad === 'string') {\n            throw Error(`Error in ${opDesc}: pad must be an integer when using ` +\n                `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n        }\n        else if (typeof pad === 'number') {\n            util.assert(util.isInt(pad), () => `Error in ${opDesc}: pad must be an integer when using ` +\n                `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n        }\n        else if (typeof pad === 'object') {\n            pad.forEach(p => {\n                p.forEach(v => {\n                    util.assert(util.isInt(v), () => `Error in ${opDesc}: pad must be an integer when using ` +\n                        `dimRoundingMode ${dimRoundingMode} but got pad ${v}.`);\n                });\n            });\n        }\n        else {\n            throw Error(`Error in ${opDesc}: Unknown padding parameter: ${pad}`);\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}