{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\nconst NEW_AXIS = -2;\nconst SHRINK_AXIS = -1;\nexport function assertParamsValid(input, begin, size) {\n  const inputRank = input.shape.length;\n  util.assert(inputRank === begin.length, () => `Error in slice${inputRank}D: Length of begin ${begin} must ` + `match the rank of the array (${inputRank}).`);\n  util.assert(inputRank === size.length, () => `Error in slice${inputRank}D: Length of size ${size} must ` + `match the rank of the array (${inputRank}).`);\n\n  for (let i = 0; i < inputRank; ++i) {\n    util.assert(begin[i] + size[i] <= input.shape[i], () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] ` + `(${begin[i] + size[i]}) would overflow input.shape[${i}] (${input.shape[i]})`);\n  }\n}\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\n\nexport function maskToAxes(mask) {\n  const axes = [];\n  let axis = 0;\n\n  while (mask > 0) {\n    if (mask & 1) {\n      axes.push(axis);\n    }\n\n    mask /= 2;\n    axis++;\n  }\n\n  return axes;\n}\n/** Computes the output shape given the strided slice params. */\n\nexport function computeOutShape(begin, end, strides) {\n  const size = [];\n\n  for (let axis = 0; axis < begin.length; axis++) {\n    size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n  }\n\n  return size;\n} // Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stride value. Otherwise, insert.\n\nexport function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {\n  const newStrides = [...strides];\n\n  for (let i = newStrides.length; i < inputShape.length; i++) {\n    newStrides.push(1);\n  }\n\n  for (let i = 0; i < numElidedAxes; i++) {\n    if (i === 0) {\n      newStrides[ellipsisInsertionIndex] = 1;\n    } else {\n      newStrides.splice(ellipsisInsertionIndex, 0\n      /* num elements to delete */\n      , 1\n      /* element to add */\n      );\n      newStrides.pop();\n    }\n  }\n\n  return newStrides;\n}\n\nfunction unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {\n  if (normalizedAxis <= ellipsisInsertionIndex) {\n    return normalizedAxis;\n  }\n\n  return normalizedAxis - (numElidedAxes - 1);\n}\n\nfunction getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {\n  const elidedAxes = [];\n\n  for (let i = 0; i < numElidedAxes; i++) {\n    elidedAxes.push(ellipsisInsertionIndex + i);\n  }\n\n  return elidedAxes;\n} // Normalize the start, end and strides.\n\n\nexport function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {\n  const inputRank = inputShape.length;\n  let normalizedBegin = new Array(inputRank),\n      normalizedEnd = new Array(inputRank),\n      normalizedStrides = new Array(inputRank);\n\n  if (ellipsisAxes.length && numInterpolatedAxes > 0) {\n    const fullIndex = ellipsisAxes[0]; // The ellipsis applies to the masked index as well as any dimensions\n    // that are interpolated.\n\n    const numElidedAxes = numInterpolatedAxes + 1;\n    normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);\n    normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);\n    normalizedStrides = stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);\n  } else {\n    for (let axis = 0; axis < inputRank; axis++) {\n      normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);\n      normalizedEnd[axis] = stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);\n      normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);\n    }\n  }\n\n  return {\n    begin: normalizedBegin,\n    end: normalizedEnd,\n    strides: normalizedStrides\n  };\n} // Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current start value. Otherwise, insert.\n\nexport function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = 0;\n    } else {\n      const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalBegin[originalAxis];\n\n      if (beginMask & 1 << originalAxis) {\n        originalValue = 0;\n      }\n\n      newIndices[axis] = originalValue;\n    }\n  }\n\n  return newIndices;\n} // Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stop value. Otherwise, insert.\n\nexport function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = Number.MAX_SAFE_INTEGER;\n    } else {\n      const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalEnd[originalAxis];\n\n      if (endMask & 1 << originalAxis) {\n        originalValue = Number.MAX_SAFE_INTEGER;\n      }\n\n      newIndices[axis] = originalValue;\n    }\n  }\n\n  for (let i = 0; i < newIndices.length; i++) {\n    // Handle negative indices\n    const axisSize = inputShape[i];\n\n    if (newIndices[i] < 0) {\n      newIndices[i] += axisSize;\n    }\n\n    newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);\n  }\n\n  return newIndices;\n}\nexport function stridesForAxis(strides, axis, ellipsisMask) {\n  let stride = strides[axis];\n\n  if (ellipsisMask & 1 << axis || stride == null) {\n    stride = 1;\n  }\n\n  return stride;\n}\nexport function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {\n  // Begin with the specified index\n  let start = startIndices[axis];\n  const stride = strides[axis] || 1; // Check the axis bit from right of masked axes, or the begin index is not set\n  // for the axis.\n\n  if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {\n    if (stride > 0) {\n      // Forward iteration - use the first element. These values will get\n      // clamped below (Note: We could have set them to 0 and axis_size-1, but\n      // use lowest() and max() to maintain symmetry with StopForAxis())\n      start = Number.MIN_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the last element.\n      start = Number.MAX_SAFE_INTEGER;\n    }\n  } // Handle negative indices\n\n\n  const axisSize = inputShape[axis];\n\n  if (start < 0) {\n    start += axisSize;\n  } // Clamping\n\n\n  start = util.clamp(0, start, axisSize - 1);\n  return start;\n}\nexport function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {\n  // Begin with the specified index\n  let stop = stopIndices[axis];\n  const stride = strides[axis] || 1; // Check the axis bit from right of masked axes, or if the stop index is not\n  // set for this axis.\n\n  if (endMask & 1 << axis || ellipsisMask & 1 << axis || stop == null) {\n    if (stride > 0) {\n      // Forward iteration - use the last element. These values will get\n      // clamped below\n      stop = Number.MAX_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the first element.\n      stop = Number.MIN_SAFE_INTEGER;\n    }\n  } // Handle negative indices\n\n\n  const axisSize = inputShape[axis];\n\n  if (stop < 0) {\n    stop += axisSize;\n  } // Clamping\n  // Because the end index points one past the last element, we need slightly\n  // different clamping ranges depending on the direction.\n\n\n  if (stride > 0) {\n    // Forward iteration\n    stop = util.clamp(0, stop, axisSize);\n  } else {\n    // Backward iteration\n    stop = util.clamp(-1, stop, axisSize - 1);\n  }\n\n  return stop;\n}\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\n\nexport function isSliceContinous(shape, begin, size) {\n  // Index of the first axis that has size > 1.\n  let firstNonOneAxis = size.length;\n\n  for (let i = 0; i < size.length; i++) {\n    if (size[i] > 1) {\n      firstNonOneAxis = i;\n      break;\n    }\n  }\n\n  for (let i = firstNonOneAxis + 1; i < size.length; i++) {\n    if (begin[i] > 0 || size[i] !== shape[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function computeFlatOffset(begin, strides) {\n  let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n\n  for (let i = 0; i < begin.length - 1; i++) {\n    flatOffset += begin[i] * strides[i];\n  }\n\n  return flatOffset;\n}\nexport function parseSliceParams(x, begin, size) {\n  // The following logic allows for more ergonomic calls.\n  let begin_;\n  const xRank = x.shape.length;\n\n  if (typeof begin === 'number') {\n    begin_ = [begin, ...new Array(xRank - 1).fill(0)];\n  } else if (begin.length < xRank) {\n    begin_ = begin.concat(new Array(xRank - begin.length).fill(0));\n  } else {\n    begin_ = begin.slice();\n  }\n\n  begin_.forEach(d => {\n    util.assert(d !== -1, () => 'slice() does not support negative begin indexing.');\n  });\n  let size_;\n\n  if (size == null) {\n    size_ = new Array(xRank).fill(-1);\n  } else if (typeof size === 'number') {\n    size_ = [size, ...new Array(xRank - 1).fill(-1)];\n  } else if (size.length < xRank) {\n    size_ = size.concat(new Array(xRank - size.length).fill(-1));\n  } else {\n    size_ = size;\n  }\n\n  size_ = size_.map((d, i) => {\n    if (d >= 0) {\n      return d;\n    } else {\n      util.assert(d === -1, () => `Negative size values should be exactly -1 but got ` + `${d} for the slice() size at index ${i}.`);\n      return x.shape[i] - begin_[i];\n    }\n  });\n  return [begin_, size_];\n} // Convert the slicing specification from a sparse representation to a dense\n// representation. This means that all ellipses and newaxis are expanded out.\n\nexport function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {\n  let stridesNonNull;\n\n  if (strides == null) {\n    stridesNonNull = new Array(begin.length);\n    stridesNonNull.fill(1);\n  } else {\n    stridesNonNull = strides;\n  } // Only one non-zero bit is allowed in ellipsisMask, which means ellipsisMask\n  // is a power of 2. Use bit compares to ensure ellipsisMask is 0 or a power\n  // of 2. When i is a power of 2, i & (i - 1) is always 0.\n  // Also ref:\n  // https://stackoverflow.com/questions/600293/how-to-check-if-a-number-is-a-power-of-2\n\n\n  if (ellipsisMask != null && (ellipsisMask & ellipsisMask - 1) !== 0) {\n    throw new Error('Multiple ellipses in slice is not allowed.');\n  } // Step 1: Account for ellipsis and new axis.\n  // Check for ellipsis and count how many non-newaxis there are after.\n\n\n  let ellipsisSeen = false;\n  const sparseSpec = {\n    dims: stridesNonNull.length,\n    numAddAxisAfterEllipsis: 0,\n    begin: begin.slice(),\n    end: end.slice(),\n    strides: stridesNonNull.slice(),\n    beginMask,\n    endMask,\n    ellipsisMask,\n    newAxisMask,\n    shrinkAxisMask\n  };\n\n  for (let i = 0; i < sparseSpec.dims; i++) {\n    if (ellipsisSeen && (1 << i & newAxisMask) !== 0) {\n      sparseSpec.numAddAxisAfterEllipsis++;\n    }\n\n    if (1 << i & ellipsisMask) {\n      ellipsisSeen = true;\n    }\n  } // If no ellipsis insert one at the end.\n\n\n  if (!ellipsisSeen) {\n    sparseSpec.ellipsisMask |= 1 << sparseSpec.dims;\n    sparseSpec.dims++; // this effects loop iteration below\n  } // Step 2: Make a sparse spec into a full index spec.\n  //\n  // The sparse spec deos not correspond to the number of dimensions.\n  // Make a dense spec that cooresponds to the number of dimensions.\n  //\n  // For example suppose foo[...,3:] on foo.shape = [2, 2, 3] then we need to\n  // produce the missing beginMask for the first two dimensions i.e. from\n  // beginMaskSpec = 0, endMaskSpec = 2, we achieve beginMask = 6 (110),\n  // endMask = 7 (111).\n\n\n  const denseSpec = {\n    dims: xShape.length,\n    beginMask: 0,\n    endMask: 0,\n    beginValid: false,\n    endValid: false\n  };\n  buildDenseSpec(sparseSpec, denseSpec); // Step 3: Make implicit ranges (non-zero beginMasks and endMasks) explicit\n  // and bounds check.\n\n  let isIdentity = true;\n  let sliceDim0 = true;\n  let isSimpleSlice = true;\n  const processingShape = [];\n  const finalShape = [];\n\n  for (let i = 0; i < xShape.length; ++i) {\n    if (denseSpec.strides[i] === 0) {\n      throw Error(`strides[${i}] must be non-zero`);\n    }\n\n    const shrinkI = !!(denseSpec.shrinkAxisMask & 1 << i);\n    const dimI = xShape[i];\n\n    if (dimI === -1) {\n      processingShape.push(shrinkI ? 1 : -1);\n      continue;\n    }\n\n    const masks = [denseSpec.beginMask & 1 << i, denseSpec.endMask & 1 << i];\n    const validRange = [denseSpec.strides[i] > 0 ? 0 : -1, denseSpec.strides[i] > 0 ? dimI : dimI - 1];\n\n    if (shrinkI && denseSpec.strides[i] <= 0) {\n      throw Error('only stride 1 allowed on non-range indexing.');\n    }\n\n    isSimpleSlice = isSimpleSlice && denseSpec.strides[i] === 1;\n    const beginAndEndMasked = !!(denseSpec.beginMask & 1 << i && denseSpec.endMask & 1 << i);\n\n    if (denseSpec.beginValid && denseSpec.endValid) {\n      if (shrinkI) {\n        // If we are shrinking, the end index is now possibly incorrect. In\n        // particular foo[-1] produces sparseBegin = -1, sparseEnd = 0.\n        // and canonical puts these to n-1 and 0, which implies a degenerate\n        // interval. Fortunately, it is now safe to re-create end as begin + 1.\n        const xFwd = denseSpec.begin[i] < 0 ? dimI + denseSpec.begin[i] : denseSpec.begin[i];\n        denseSpec.begin[i] = xFwd;\n        denseSpec.end[i] = denseSpec.begin[i] + 1;\n\n        if (xFwd < 0 || xFwd >= dimI) {\n          throw Error(`slice index ${denseSpec.begin[i]} of dimension ${i} out of bounds.`);\n        }\n      } else {\n        denseSpec.begin[i] = canonical(denseSpec.begin[i], 0, denseSpec.strides[i], dimI, masks, validRange);\n        denseSpec.end[i] = canonical(denseSpec.end[i], 1, denseSpec.strides[i], dimI, masks, validRange);\n      } // Update optimization values\n\n\n      const takeAllInDimension = denseSpec.strides[i] === 1 && denseSpec.begin[i] === 0 && denseSpec.end[i] === dimI;\n      isIdentity = isIdentity && takeAllInDimension;\n      sliceDim0 = sliceDim0 && (i === 0 && denseSpec.strides[i] === 1 || takeAllInDimension);\n    } else {\n      isIdentity = isIdentity && denseSpec.strides[i] === 1 && beginAndEndMasked;\n      sliceDim0 = sliceDim0 && (i === 0 && denseSpec.strides[i] === 1 || beginAndEndMasked);\n    } // Compute the processing shape (the intermediate Eigen will produce)\n\n\n    let intervalLength;\n    let knownInterval = false;\n\n    if (denseSpec.beginValid && denseSpec.endValid) {\n      intervalLength = denseSpec.end[i] - denseSpec.begin[i];\n      knownInterval = true;\n    } else if (shrinkI) {\n      // The dimension is still known as 1 for the processingShape, but will be\n      // discarded for the final shape.\n      intervalLength = 1;\n      knownInterval = true;\n    } else if (beginAndEndMasked) {\n      // Even if we don't have values for begin or end, we do know that this\n      // dimension covers the whole interval. If we have shape information for\n      // this dimension, that tells us the interval length.\n      if (dimI >= 0) {\n        if (denseSpec.strides[i] < 0) {\n          intervalLength = -dimI;\n        } else {\n          intervalLength = dimI;\n        }\n\n        knownInterval = true;\n      }\n    }\n\n    if (knownInterval) {\n      let sizeI; // Hold zero if the interval is degenerate, otherwise account for\n      // remainder\n\n      if (intervalLength === 0 || intervalLength < 0 !== denseSpec.strides[i] < 0) {\n        sizeI = 0;\n      } else {\n        sizeI = Math.trunc(intervalLength / denseSpec.strides[i]) + (intervalLength % denseSpec.strides[i] !== 0 ? 1 : 0);\n      }\n\n      processingShape.push(sizeI);\n    } else {\n      processingShape.push(-1);\n    }\n  } // Step 4: Compute the final shape\n  //\n  // newAxis will increase dimension by 1 (with a one-size dimension)\n  // slices like foo[3, ...] will reduce dimension by 1.\n  // This cannot be done earlier, because it depends on Step 3.\n\n\n  for (let denseDim = 0; denseDim < denseSpec.finalShapeGatherIndices.length; ++denseDim) {\n    const gatherIndex = denseSpec.finalShapeGatherIndices[denseDim];\n\n    if (gatherIndex >= 0) {\n      finalShape.push(processingShape[gatherIndex]);\n    } else if (gatherIndex === NEW_AXIS) {\n      finalShape.push(1);\n    }\n  }\n\n  const finalShapeSparse = finalShape.filter((dim, i) => denseSpec.finalShapeGatherIndices[i] !== NEW_AXIS);\n  return {\n    finalShapeSparse,\n    finalShape,\n    isIdentity,\n    sliceDim0,\n    isSimpleSlice,\n    begin: denseSpec.begin,\n    end: denseSpec.end,\n    strides: denseSpec.strides\n  };\n}\n\nfunction buildDenseSpec(sparse, dense) {\n  dense.beginMask = 0;\n  dense.endMask = 0;\n  dense.shrinkAxisMask = 0;\n  let fullIndex = 0;\n  dense.beginValid = sparse.begin != null;\n  dense.endValid = sparse.end != null;\n  dense.begin = new Array(dense.dims);\n  dense.end = new Array(dense.dims);\n  dense.strides = new Array(dense.dims);\n  dense.finalShapeGatherIndices = [];\n  dense.finalShapeGatherIndicesSparse = [];\n  dense.inputShapeGatherIndicesSparse = new Array(dense.dims);\n\n  for (let i = 0; i < sparse.dims; i++) {\n    if (1 << i & sparse.ellipsisMask) {\n      // Only the bit that has ellipsis will fall in this condition.\n      // Expand the ellipsis into the appropriate indices\n      // Note: this only works because we guaranteed one ellipsis.\n      const nextIndex = Math.min(dense.dims - (sparse.dims - i) + 1 + sparse.numAddAxisAfterEllipsis, dense.dims);\n\n      for (; fullIndex < nextIndex; fullIndex++) {\n        // newAxis aren't real axis so you have to skip.\n        dense.begin[fullIndex] = 0;\n        dense.end[fullIndex] = 0;\n        dense.strides[fullIndex] = 1;\n        dense.beginMask |= 1 << fullIndex;\n        dense.endMask |= 1 << fullIndex;\n        dense.finalShapeGatherIndices.push(fullIndex);\n        dense.finalShapeGatherIndicesSparse.push(-1);\n        dense.inputShapeGatherIndicesSparse[fullIndex] = i;\n      }\n    } else if (1 << i & sparse.newAxisMask) {\n      // Only the bit that has newAxis will fall in this condition.\n      dense.finalShapeGatherIndices.push(NEW_AXIS);\n      dense.finalShapeGatherIndicesSparse.push(-1);\n    } else {\n      if (fullIndex === dense.begin.length) {\n        throw Error(`Index out of range using input dim ${fullIndex}; input ` + `has only ${dense.dims} dims, ${dense.begin.length}.`);\n      } // Gather slicing spec into appropriate index.\n\n\n      if (sparse.begin != null) {\n        dense.begin[fullIndex] = sparse.begin[i];\n      }\n\n      if (sparse.end != null) {\n        dense.end[fullIndex] = sparse.end[i];\n      }\n\n      dense.strides[fullIndex] = sparse.strides[i];\n\n      if (sparse.beginMask & 1 << i) {\n        dense.beginMask |= 1 << fullIndex;\n      }\n\n      if (sparse.endMask & 1 << i) {\n        dense.endMask |= 1 << fullIndex;\n      } // If shrink, record where to get the dimensionality from (i.e. newAxis)\n      // creates a fake 1 size dimension. Also remember shrink axis (now in\n      // dense form) so we can ignore dense.end below.\n\n\n      if (sparse.shrinkAxisMask & 1 << i) {\n        dense.finalShapeGatherIndices.push(SHRINK_AXIS);\n        dense.finalShapeGatherIndicesSparse.push(-1);\n        dense.shrinkAxisMask |= 1 << fullIndex;\n      } else {\n        dense.finalShapeGatherIndices.push(fullIndex); // Remember that where in the sparse shape the dense dim comes from.\n\n        dense.finalShapeGatherIndicesSparse.push(i);\n      }\n\n      dense.inputShapeGatherIndicesSparse[fullIndex] = i;\n      fullIndex++;\n    }\n  }\n}\n\nfunction canonical(x, c, strideI, dimI, masks, validRange) {\n  if (masks[c]) {\n    return strideI > 0 ? validRange[c] : validRange[c + 1 & 1];\n  } else {\n    const xFwd = x < 0 ? dimI + x : x; // make negative indices positive\n\n    return xFwd < validRange[0] ? validRange[0] : xFwd > validRange[1] ? validRange[1] : xFwd;\n  }\n}","map":{"version":3,"names":["util","NEW_AXIS","SHRINK_AXIS","assertParamsValid","input","begin","size","inputRank","shape","length","assert","i","maskToAxes","mask","axes","axis","push","computeOutShape","end","strides","Math","ceil","stridesWithElidedDims","ellipsisInsertionIndex","numElidedAxes","inputShape","newStrides","splice","pop","unnormalizeAxis","normalizedAxis","getElidedAxes","elidedAxes","getNormalizedAxes","ellipsisAxes","numInterpolatedAxes","beginMask","endMask","ellipsisMask","normalizedBegin","Array","normalizedEnd","normalizedStrides","fullIndex","startIndicesWithElidedDims","stopIndicesWithElidedDims","startForAxis","stopForAxis","stridesForAxis","originalBegin","newIndices","indexOf","originalAxis","originalValue","originalEnd","Number","MAX_SAFE_INTEGER","axisSize","clamp","stride","startIndices","start","MIN_SAFE_INTEGER","stopIndices","stop","isSliceContinous","firstNonOneAxis","computeFlatOffset","flatOffset","parseSliceParams","x","begin_","xRank","fill","concat","slice","forEach","d","size_","map","sliceInfo","xShape","newAxisMask","shrinkAxisMask","stridesNonNull","Error","ellipsisSeen","sparseSpec","dims","numAddAxisAfterEllipsis","denseSpec","beginValid","endValid","buildDenseSpec","isIdentity","sliceDim0","isSimpleSlice","processingShape","finalShape","shrinkI","dimI","masks","validRange","beginAndEndMasked","xFwd","canonical","takeAllInDimension","intervalLength","knownInterval","sizeI","trunc","denseDim","finalShapeGatherIndices","gatherIndex","finalShapeSparse","filter","dim","sparse","dense","finalShapeGatherIndicesSparse","inputShapeGatherIndicesSparse","nextIndex","min","c","strideI"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-core/dist/ops/slice_util.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\nconst NEW_AXIS = -2;\nconst SHRINK_AXIS = -1;\nexport function assertParamsValid(input, begin, size) {\n    const inputRank = input.shape.length;\n    util.assert(inputRank === begin.length, () => `Error in slice${inputRank}D: Length of begin ${begin} must ` +\n        `match the rank of the array (${inputRank}).`);\n    util.assert(inputRank === size.length, () => `Error in slice${inputRank}D: Length of size ${size} must ` +\n        `match the rank of the array (${inputRank}).`);\n    for (let i = 0; i < inputRank; ++i) {\n        util.assert(begin[i] + size[i] <= input.shape[i], () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] ` +\n            `(${begin[i] + size[i]}) would overflow input.shape[${i}] (${input.shape[i]})`);\n    }\n}\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\nexport function maskToAxes(mask) {\n    const axes = [];\n    let axis = 0;\n    while (mask > 0) {\n        if (mask & 1) {\n            axes.push(axis);\n        }\n        mask /= 2;\n        axis++;\n    }\n    return axes;\n}\n/** Computes the output shape given the strided slice params. */\nexport function computeOutShape(begin, end, strides) {\n    const size = [];\n    for (let axis = 0; axis < begin.length; axis++) {\n        size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n    }\n    return size;\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stride value. Otherwise, insert.\nexport function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {\n    const newStrides = [...strides];\n    for (let i = newStrides.length; i < inputShape.length; i++) {\n        newStrides.push(1);\n    }\n    for (let i = 0; i < numElidedAxes; i++) {\n        if (i === 0) {\n            newStrides[ellipsisInsertionIndex] = 1;\n        }\n        else {\n            newStrides.splice(ellipsisInsertionIndex, 0 /* num elements to delete */, 1 /* element to add */);\n            newStrides.pop();\n        }\n    }\n    return newStrides;\n}\nfunction unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {\n    if (normalizedAxis <= ellipsisInsertionIndex) {\n        return normalizedAxis;\n    }\n    return normalizedAxis - (numElidedAxes - 1);\n}\nfunction getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {\n    const elidedAxes = [];\n    for (let i = 0; i < numElidedAxes; i++) {\n        elidedAxes.push(ellipsisInsertionIndex + i);\n    }\n    return elidedAxes;\n}\n// Normalize the start, end and strides.\nexport function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {\n    const inputRank = inputShape.length;\n    let normalizedBegin = new Array(inputRank), normalizedEnd = new Array(inputRank), normalizedStrides = new Array(inputRank);\n    if (ellipsisAxes.length && numInterpolatedAxes > 0) {\n        const fullIndex = ellipsisAxes[0];\n        // The ellipsis applies to the masked index as well as any dimensions\n        // that are interpolated.\n        const numElidedAxes = numInterpolatedAxes + 1;\n        normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);\n        normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);\n        normalizedStrides =\n            stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);\n    }\n    else {\n        for (let axis = 0; axis < inputRank; axis++) {\n            normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);\n            normalizedEnd[axis] =\n                stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);\n            normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);\n        }\n    }\n    return {\n        begin: normalizedBegin,\n        end: normalizedEnd,\n        strides: normalizedStrides\n    };\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current start value. Otherwise, insert.\nexport function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {\n    const newIndices = [...inputShape];\n    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n    for (let axis = 0; axis < newIndices.length; axis++) {\n        if (elidedAxes.indexOf(axis) > -1) {\n            newIndices[axis] = 0;\n        }\n        else {\n            const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n            let originalValue = originalBegin[originalAxis];\n            if (beginMask & 1 << originalAxis) {\n                originalValue = 0;\n            }\n            newIndices[axis] = originalValue;\n        }\n    }\n    return newIndices;\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stop value. Otherwise, insert.\nexport function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {\n    const newIndices = [...inputShape];\n    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n    for (let axis = 0; axis < newIndices.length; axis++) {\n        if (elidedAxes.indexOf(axis) > -1) {\n            newIndices[axis] = Number.MAX_SAFE_INTEGER;\n        }\n        else {\n            const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n            let originalValue = originalEnd[originalAxis];\n            if (endMask & 1 << originalAxis) {\n                originalValue = Number.MAX_SAFE_INTEGER;\n            }\n            newIndices[axis] = originalValue;\n        }\n    }\n    for (let i = 0; i < newIndices.length; i++) {\n        // Handle negative indices\n        const axisSize = inputShape[i];\n        if (newIndices[i] < 0) {\n            newIndices[i] += axisSize;\n        }\n        newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);\n    }\n    return newIndices;\n}\nexport function stridesForAxis(strides, axis, ellipsisMask) {\n    let stride = strides[axis];\n    if (ellipsisMask & (1 << axis) || stride == null) {\n        stride = 1;\n    }\n    return stride;\n}\nexport function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {\n    // Begin with the specified index\n    let start = startIndices[axis];\n    const stride = strides[axis] || 1;\n    // Check the axis bit from right of masked axes, or the begin index is not set\n    // for the axis.\n    if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {\n        if (stride > 0) {\n            // Forward iteration - use the first element. These values will get\n            // clamped below (Note: We could have set them to 0 and axis_size-1, but\n            // use lowest() and max() to maintain symmetry with StopForAxis())\n            start = Number.MIN_SAFE_INTEGER;\n        }\n        else {\n            // Backward iteration - use the last element.\n            start = Number.MAX_SAFE_INTEGER;\n        }\n    }\n    // Handle negative indices\n    const axisSize = inputShape[axis];\n    if (start < 0) {\n        start += axisSize;\n    }\n    // Clamping\n    start = util.clamp(0, start, axisSize - 1);\n    return start;\n}\nexport function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {\n    // Begin with the specified index\n    let stop = stopIndices[axis];\n    const stride = strides[axis] || 1;\n    // Check the axis bit from right of masked axes, or if the stop index is not\n    // set for this axis.\n    if (endMask & (1 << axis) || ellipsisMask & (1 << axis) || stop == null) {\n        if (stride > 0) {\n            // Forward iteration - use the last element. These values will get\n            // clamped below\n            stop = Number.MAX_SAFE_INTEGER;\n        }\n        else {\n            // Backward iteration - use the first element.\n            stop = Number.MIN_SAFE_INTEGER;\n        }\n    }\n    // Handle negative indices\n    const axisSize = inputShape[axis];\n    if (stop < 0) {\n        stop += axisSize;\n    }\n    // Clamping\n    // Because the end index points one past the last element, we need slightly\n    // different clamping ranges depending on the direction.\n    if (stride > 0) {\n        // Forward iteration\n        stop = util.clamp(0, stop, axisSize);\n    }\n    else {\n        // Backward iteration\n        stop = util.clamp(-1, stop, axisSize - 1);\n    }\n    return stop;\n}\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\nexport function isSliceContinous(shape, begin, size) {\n    // Index of the first axis that has size > 1.\n    let firstNonOneAxis = size.length;\n    for (let i = 0; i < size.length; i++) {\n        if (size[i] > 1) {\n            firstNonOneAxis = i;\n            break;\n        }\n    }\n    for (let i = firstNonOneAxis + 1; i < size.length; i++) {\n        if (begin[i] > 0 || size[i] !== shape[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function computeFlatOffset(begin, strides) {\n    let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n    for (let i = 0; i < begin.length - 1; i++) {\n        flatOffset += begin[i] * strides[i];\n    }\n    return flatOffset;\n}\nexport function parseSliceParams(x, begin, size) {\n    // The following logic allows for more ergonomic calls.\n    let begin_;\n    const xRank = x.shape.length;\n    if (typeof begin === 'number') {\n        begin_ = [begin, ...new Array(xRank - 1).fill(0)];\n    }\n    else if (begin.length < xRank) {\n        begin_ = begin.concat(new Array(xRank - begin.length).fill(0));\n    }\n    else {\n        begin_ = begin.slice();\n    }\n    begin_.forEach(d => {\n        util.assert(d !== -1, () => 'slice() does not support negative begin indexing.');\n    });\n    let size_;\n    if (size == null) {\n        size_ = new Array(xRank).fill(-1);\n    }\n    else if (typeof size === 'number') {\n        size_ = [size, ...new Array(xRank - 1).fill(-1)];\n    }\n    else if (size.length < xRank) {\n        size_ = size.concat(new Array(xRank - size.length).fill(-1));\n    }\n    else {\n        size_ = size;\n    }\n    size_ = size_.map((d, i) => {\n        if (d >= 0) {\n            return d;\n        }\n        else {\n            util.assert(d === -1, () => `Negative size values should be exactly -1 but got ` +\n                `${d} for the slice() size at index ${i}.`);\n            return x.shape[i] - begin_[i];\n        }\n    });\n    return [begin_, size_];\n}\n// Convert the slicing specification from a sparse representation to a dense\n// representation. This means that all ellipses and newaxis are expanded out.\nexport function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {\n    let stridesNonNull;\n    if (strides == null) {\n        stridesNonNull = new Array(begin.length);\n        stridesNonNull.fill(1);\n    }\n    else {\n        stridesNonNull = strides;\n    }\n    // Only one non-zero bit is allowed in ellipsisMask, which means ellipsisMask\n    // is a power of 2. Use bit compares to ensure ellipsisMask is 0 or a power\n    // of 2. When i is a power of 2, i & (i - 1) is always 0.\n    // Also ref:\n    // https://stackoverflow.com/questions/600293/how-to-check-if-a-number-is-a-power-of-2\n    if (ellipsisMask != null && (ellipsisMask & (ellipsisMask - 1)) !== 0) {\n        throw new Error('Multiple ellipses in slice is not allowed.');\n    }\n    // Step 1: Account for ellipsis and new axis.\n    // Check for ellipsis and count how many non-newaxis there are after.\n    let ellipsisSeen = false;\n    const sparseSpec = {\n        dims: stridesNonNull.length,\n        numAddAxisAfterEllipsis: 0,\n        begin: begin.slice(),\n        end: end.slice(),\n        strides: stridesNonNull.slice(),\n        beginMask,\n        endMask,\n        ellipsisMask,\n        newAxisMask,\n        shrinkAxisMask\n    };\n    for (let i = 0; i < sparseSpec.dims; i++) {\n        if (ellipsisSeen && ((1 << i) & newAxisMask) !== 0) {\n            sparseSpec.numAddAxisAfterEllipsis++;\n        }\n        if ((1 << i) & ellipsisMask) {\n            ellipsisSeen = true;\n        }\n    }\n    // If no ellipsis insert one at the end.\n    if (!ellipsisSeen) {\n        sparseSpec.ellipsisMask |= (1 << sparseSpec.dims);\n        sparseSpec.dims++; // this effects loop iteration below\n    }\n    // Step 2: Make a sparse spec into a full index spec.\n    //\n    // The sparse spec deos not correspond to the number of dimensions.\n    // Make a dense spec that cooresponds to the number of dimensions.\n    //\n    // For example suppose foo[...,3:] on foo.shape = [2, 2, 3] then we need to\n    // produce the missing beginMask for the first two dimensions i.e. from\n    // beginMaskSpec = 0, endMaskSpec = 2, we achieve beginMask = 6 (110),\n    // endMask = 7 (111).\n    const denseSpec = {\n        dims: xShape.length,\n        beginMask: 0,\n        endMask: 0,\n        beginValid: false,\n        endValid: false\n    };\n    buildDenseSpec(sparseSpec, denseSpec);\n    // Step 3: Make implicit ranges (non-zero beginMasks and endMasks) explicit\n    // and bounds check.\n    let isIdentity = true;\n    let sliceDim0 = true;\n    let isSimpleSlice = true;\n    const processingShape = [];\n    const finalShape = [];\n    for (let i = 0; i < xShape.length; ++i) {\n        if (denseSpec.strides[i] === 0) {\n            throw Error(`strides[${i}] must be non-zero`);\n        }\n        const shrinkI = !!(denseSpec.shrinkAxisMask & (1 << i));\n        const dimI = xShape[i];\n        if (dimI === -1) {\n            processingShape.push(shrinkI ? 1 : -1);\n            continue;\n        }\n        const masks = [denseSpec.beginMask & (1 << i), denseSpec.endMask & (1 << i)];\n        const validRange = [\n            denseSpec.strides[i] > 0 ? 0 : -1,\n            denseSpec.strides[i] > 0 ? dimI : dimI - 1\n        ];\n        if (shrinkI && denseSpec.strides[i] <= 0) {\n            throw Error('only stride 1 allowed on non-range indexing.');\n        }\n        isSimpleSlice = isSimpleSlice && (denseSpec.strides[i] === 1);\n        const beginAndEndMasked = !!((denseSpec.beginMask & (1 << i)) && (denseSpec.endMask & (1 << i)));\n        if (denseSpec.beginValid && denseSpec.endValid) {\n            if (shrinkI) {\n                // If we are shrinking, the end index is now possibly incorrect. In\n                // particular foo[-1] produces sparseBegin = -1, sparseEnd = 0.\n                // and canonical puts these to n-1 and 0, which implies a degenerate\n                // interval. Fortunately, it is now safe to re-create end as begin + 1.\n                const xFwd = denseSpec.begin[i] < 0 ? dimI + denseSpec.begin[i] :\n                    denseSpec.begin[i];\n                denseSpec.begin[i] = xFwd;\n                denseSpec.end[i] = denseSpec.begin[i] + 1;\n                if (xFwd < 0 || xFwd >= dimI) {\n                    throw Error(`slice index ${denseSpec.begin[i]} of dimension ${i} out of bounds.`);\n                }\n            }\n            else {\n                denseSpec.begin[i] = canonical(denseSpec.begin[i], 0, denseSpec.strides[i], dimI, masks, validRange);\n                denseSpec.end[i] = canonical(denseSpec.end[i], 1, denseSpec.strides[i], dimI, masks, validRange);\n            }\n            // Update optimization values\n            const takeAllInDimension = denseSpec.strides[i] === 1 &&\n                denseSpec.begin[i] === 0 && denseSpec.end[i] === dimI;\n            isIdentity = isIdentity && takeAllInDimension;\n            sliceDim0 = sliceDim0 &&\n                ((i === 0 && denseSpec.strides[i] === 1) || takeAllInDimension);\n        }\n        else {\n            isIdentity =\n                isIdentity && ((denseSpec.strides[i] === 1) && beginAndEndMasked);\n            sliceDim0 = sliceDim0 &&\n                ((i === 0 && denseSpec.strides[i] === 1) || beginAndEndMasked);\n        }\n        // Compute the processing shape (the intermediate Eigen will produce)\n        let intervalLength;\n        let knownInterval = false;\n        if (denseSpec.beginValid && denseSpec.endValid) {\n            intervalLength = denseSpec.end[i] - denseSpec.begin[i];\n            knownInterval = true;\n        }\n        else if (shrinkI) {\n            // The dimension is still known as 1 for the processingShape, but will be\n            // discarded for the final shape.\n            intervalLength = 1;\n            knownInterval = true;\n        }\n        else if (beginAndEndMasked) {\n            // Even if we don't have values for begin or end, we do know that this\n            // dimension covers the whole interval. If we have shape information for\n            // this dimension, that tells us the interval length.\n            if (dimI >= 0) {\n                if (denseSpec.strides[i] < 0) {\n                    intervalLength = -dimI;\n                }\n                else {\n                    intervalLength = dimI;\n                }\n                knownInterval = true;\n            }\n        }\n        if (knownInterval) {\n            let sizeI;\n            // Hold zero if the interval is degenerate, otherwise account for\n            // remainder\n            if (intervalLength === 0 ||\n                ((intervalLength < 0) !== (denseSpec.strides[i] < 0))) {\n                sizeI = 0;\n            }\n            else {\n                sizeI = Math.trunc(intervalLength / denseSpec.strides[i]) +\n                    (intervalLength % denseSpec.strides[i] !== 0 ? 1 : 0);\n            }\n            processingShape.push(sizeI);\n        }\n        else {\n            processingShape.push(-1);\n        }\n    }\n    // Step 4: Compute the final shape\n    //\n    // newAxis will increase dimension by 1 (with a one-size dimension)\n    // slices like foo[3, ...] will reduce dimension by 1.\n    // This cannot be done earlier, because it depends on Step 3.\n    for (let denseDim = 0; denseDim < denseSpec.finalShapeGatherIndices.length; ++denseDim) {\n        const gatherIndex = denseSpec.finalShapeGatherIndices[denseDim];\n        if (gatherIndex >= 0) {\n            finalShape.push(processingShape[gatherIndex]);\n        }\n        else if (gatherIndex === NEW_AXIS) {\n            finalShape.push(1);\n        }\n    }\n    const finalShapeSparse = finalShape.filter((dim, i) => denseSpec.finalShapeGatherIndices[i] !== NEW_AXIS);\n    return {\n        finalShapeSparse,\n        finalShape,\n        isIdentity,\n        sliceDim0,\n        isSimpleSlice,\n        begin: denseSpec.begin,\n        end: denseSpec.end,\n        strides: denseSpec.strides\n    };\n}\nfunction buildDenseSpec(sparse, dense) {\n    dense.beginMask = 0;\n    dense.endMask = 0;\n    dense.shrinkAxisMask = 0;\n    let fullIndex = 0;\n    dense.beginValid = sparse.begin != null;\n    dense.endValid = sparse.end != null;\n    dense.begin = new Array(dense.dims);\n    dense.end = new Array(dense.dims);\n    dense.strides = new Array(dense.dims);\n    dense.finalShapeGatherIndices = [];\n    dense.finalShapeGatherIndicesSparse = [];\n    dense.inputShapeGatherIndicesSparse = new Array(dense.dims);\n    for (let i = 0; i < sparse.dims; i++) {\n        if ((1 << i) & sparse.ellipsisMask) {\n            // Only the bit that has ellipsis will fall in this condition.\n            // Expand the ellipsis into the appropriate indices\n            // Note: this only works because we guaranteed one ellipsis.\n            const nextIndex = Math.min(dense.dims - (sparse.dims - i) + 1 + sparse.numAddAxisAfterEllipsis, dense.dims);\n            for (; fullIndex < nextIndex; fullIndex++) {\n                // newAxis aren't real axis so you have to skip.\n                dense.begin[fullIndex] = 0;\n                dense.end[fullIndex] = 0;\n                dense.strides[fullIndex] = 1;\n                dense.beginMask |= (1 << fullIndex);\n                dense.endMask |= (1 << fullIndex);\n                dense.finalShapeGatherIndices.push(fullIndex);\n                dense.finalShapeGatherIndicesSparse.push(-1);\n                dense.inputShapeGatherIndicesSparse[fullIndex] = i;\n            }\n        }\n        else if ((1 << i) & sparse.newAxisMask) {\n            // Only the bit that has newAxis will fall in this condition.\n            dense.finalShapeGatherIndices.push(NEW_AXIS);\n            dense.finalShapeGatherIndicesSparse.push(-1);\n        }\n        else {\n            if (fullIndex === dense.begin.length) {\n                throw Error(`Index out of range using input dim ${fullIndex}; input ` +\n                    `has only ${dense.dims} dims, ${dense.begin.length}.`);\n            }\n            // Gather slicing spec into appropriate index.\n            if (sparse.begin != null) {\n                dense.begin[fullIndex] = sparse.begin[i];\n            }\n            if (sparse.end != null) {\n                dense.end[fullIndex] = sparse.end[i];\n            }\n            dense.strides[fullIndex] = sparse.strides[i];\n            if (sparse.beginMask & (1 << i)) {\n                dense.beginMask |= (1 << fullIndex);\n            }\n            if (sparse.endMask & (1 << i)) {\n                dense.endMask |= (1 << fullIndex);\n            }\n            // If shrink, record where to get the dimensionality from (i.e. newAxis)\n            // creates a fake 1 size dimension. Also remember shrink axis (now in\n            // dense form) so we can ignore dense.end below.\n            if (sparse.shrinkAxisMask & (1 << i)) {\n                dense.finalShapeGatherIndices.push(SHRINK_AXIS);\n                dense.finalShapeGatherIndicesSparse.push(-1);\n                dense.shrinkAxisMask |= (1 << fullIndex);\n            }\n            else {\n                dense.finalShapeGatherIndices.push(fullIndex);\n                // Remember that where in the sparse shape the dense dim comes from.\n                dense.finalShapeGatherIndicesSparse.push(i);\n            }\n            dense.inputShapeGatherIndicesSparse[fullIndex] = i;\n            fullIndex++;\n        }\n    }\n}\nfunction canonical(x, c, strideI, dimI, masks, validRange) {\n    if (masks[c]) {\n        return strideI > 0 ? validRange[c] : validRange[(c + 1) & 1];\n    }\n    else {\n        const xFwd = x < 0 ? dimI + x : x; // make negative indices positive\n        return xFwd < validRange[0] ? validRange[0] :\n            xFwd > validRange[1] ? validRange[1] : xFwd;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}