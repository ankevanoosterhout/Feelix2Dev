{"ast":null,"code":"import { getCoordsDataType } from './shader_compiler';\nexport var CumOpType;\n\n(function (CumOpType) {\n  CumOpType[\"Prod\"] = \"*\";\n  CumOpType[\"Sum\"] = \"+\";\n})(CumOpType || (CumOpType = {}));\n\nexport class CumProgram {\n  constructor(op, outputShape, exclusive, reverse) {\n    this.op = op;\n    this.outputShape = outputShape;\n    this.variableNames = ['x'];\n    this.customUniforms = [{\n      name: 'index',\n      type: 'float'\n    }];\n    const rank = this.outputShape.length;\n    const initVal = this.op === CumOpType.Prod ? '1.0' : '0.0';\n    const val = exclusive ? initVal : `getX(${getCoords(rank, 'coords', this.op)})`;\n    const length = this.outputShape[this.outputShape.length - 1];\n    let condition = '';\n    let idxString = ''; // When exclusive is set, the cum op becomes roll op that copies the\n    // value from the previous index based on the direction specified by the\n    // reverse flag.\n\n    if (exclusive) {\n      condition = reverse ? `end != ${length - 1}` : 'end != 0';\n      idxString = reverse ? 'end + 1' : 'end - 1';\n    } else {\n      condition = reverse ? `end + pow2 < ${length}` : 'end >= pow2';\n      idxString = reverse ? 'end + pow2' : 'end - pow2';\n    }\n\n    this.userCode = `\n      void main() {\n        ${getCoordsDataType(rank)} coords = getOutputCoords();\n        int end = ${getFinalCoord(rank, 'coords', this.op)};\n        float val = ${val};\n        int pow2 = int(pow(2.0, index));\n        if (${condition}) {\n          int idx = ${idxString};\n          ${getFinalCoord(rank, 'coords', this.op)} = idx;\n          val ${this.op}= getX(${getCoords(rank, 'coords', this.op)});\n        }\n        setOutput(val);\n      }\n    `;\n  }\n\n}\n\nfunction getCoords(rank, name, op) {\n  if (rank === 1) {\n    return `${name}`;\n  } else if (rank === 2) {\n    return `${name}.x, ${name}.y`;\n  } else if (rank === 3) {\n    return `${name}.x, ${name}.y, ${name}.z`;\n  } else if (rank === 4) {\n    return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;\n  } else {\n    throw new Error(`Cumulative ${op} for rank ${rank} is not yet supported`);\n  }\n}\n\nfunction getFinalCoord(rank, name, op) {\n  if (rank === 1) {\n    return `${name}`;\n  } else if (rank === 2) {\n    return `${name}.y`;\n  } else if (rank === 3) {\n    return `${name}.z`;\n  } else if (rank === 4) {\n    return `${name}.w`;\n  } else {\n    throw new Error(`Cumulative ${op} for rank ${rank} is not yet supported`);\n  }\n}","map":{"version":3,"names":["getCoordsDataType","CumOpType","CumProgram","constructor","op","outputShape","exclusive","reverse","variableNames","customUniforms","name","type","rank","length","initVal","Prod","val","getCoords","condition","idxString","userCode","getFinalCoord","Error"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-webgl/dist/cum_gpu.js"],"sourcesContent":["import { getCoordsDataType } from './shader_compiler';\nexport var CumOpType;\n(function (CumOpType) {\n    CumOpType[\"Prod\"] = \"*\";\n    CumOpType[\"Sum\"] = \"+\";\n})(CumOpType || (CumOpType = {}));\nexport class CumProgram {\n    constructor(op, outputShape, exclusive, reverse) {\n        this.op = op;\n        this.outputShape = outputShape;\n        this.variableNames = ['x'];\n        this.customUniforms = [{ name: 'index', type: 'float' }];\n        const rank = this.outputShape.length;\n        const initVal = this.op === CumOpType.Prod ? '1.0' : '0.0';\n        const val = exclusive ? initVal : `getX(${getCoords(rank, 'coords', this.op)})`;\n        const length = this.outputShape[this.outputShape.length - 1];\n        let condition = '';\n        let idxString = '';\n        // When exclusive is set, the cum op becomes roll op that copies the\n        // value from the previous index based on the direction specified by the\n        // reverse flag.\n        if (exclusive) {\n            condition = reverse ? `end != ${length - 1}` : 'end != 0';\n            idxString = reverse ? 'end + 1' : 'end - 1';\n        }\n        else {\n            condition = reverse ? `end + pow2 < ${length}` : 'end >= pow2';\n            idxString = (reverse ? 'end + pow2' : 'end - pow2');\n        }\n        this.userCode = `\n      void main() {\n        ${getCoordsDataType(rank)} coords = getOutputCoords();\n        int end = ${getFinalCoord(rank, 'coords', this.op)};\n        float val = ${val};\n        int pow2 = int(pow(2.0, index));\n        if (${condition}) {\n          int idx = ${idxString};\n          ${getFinalCoord(rank, 'coords', this.op)} = idx;\n          val ${this.op}= getX(${getCoords(rank, 'coords', this.op)});\n        }\n        setOutput(val);\n      }\n    `;\n    }\n}\nfunction getCoords(rank, name, op) {\n    if (rank === 1) {\n        return `${name}`;\n    }\n    else if (rank === 2) {\n        return `${name}.x, ${name}.y`;\n    }\n    else if (rank === 3) {\n        return `${name}.x, ${name}.y, ${name}.z`;\n    }\n    else if (rank === 4) {\n        return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;\n    }\n    else {\n        throw new Error(`Cumulative ${op} for rank ${rank} is not yet supported`);\n    }\n}\nfunction getFinalCoord(rank, name, op) {\n    if (rank === 1) {\n        return `${name}`;\n    }\n    else if (rank === 2) {\n        return `${name}.y`;\n    }\n    else if (rank === 3) {\n        return `${name}.z`;\n    }\n    else if (rank === 4) {\n        return `${name}.w`;\n    }\n    else {\n        throw new Error(`Cumulative ${op} for rank ${rank} is not yet supported`);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}