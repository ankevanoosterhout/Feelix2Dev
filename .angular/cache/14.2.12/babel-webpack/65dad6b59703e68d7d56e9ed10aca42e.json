{"ast":null,"code":"export const JOINT_STRIDE = 304;\nexport const LINK_STRIDE = 56;\nexport function generateSharedBuffer(frames, useSharedArrayBuffer = true) {\n  // dofValues \t6 * 4\n  // dofTarget \t6 * 4\n  // dofRestPose \t6 * 4\n  // minDoFLimit \t6 * 4\n  // maxDoFLimit \t6 * 4\n  // position \t3 * 4\n  // quaternion \t4 * 4\n  // targetSet \t1\n  // restPoseSet \t1\n  // --\n  // total  \t\t150 bytes per joint\n  // 4 byte aligned: 152\n  let arrayBuffer;\n\n  if (useSharedArrayBuffer) {\n    arrayBuffer = new SharedArrayBuffer(JOINT_STRIDE * frames.length);\n  } else {\n    arrayBuffer = new ArrayBuffer(JOINT_STRIDE * frames.length);\n  }\n\n  const float64 = new Float32Array(arrayBuffer);\n  const byte8 = new Uint8Array(arrayBuffer);\n  applyToBuffer(frames, float64, byte8);\n  return arrayBuffer;\n}\nexport function applyToBuffer(frames, floatBuffer, byteBuffer, copyDoFValues = true, copyJointSettings = true) {\n  for (let i = 0, l = frames.length; i < l; i++) {\n    copyFrameToBuffer(frames[i], floatBuffer, byteBuffer, i * JOINT_STRIDE, copyDoFValues, copyJointSettings);\n  }\n}\nexport function applyFromBuffer(frames, floatBuffer, byteBuffer, copyDoFValues = true, copyJointSettings = true) {\n  for (let i = 0, l = frames.length; i < l; i++) {\n    copyBufferToFrame(frames[i], floatBuffer, byteBuffer, JOINT_STRIDE * i, copyDoFValues, copyJointSettings);\n  }\n} // Copy data from the frame to the given buffer starting at the given byte offset. Joints take JOINT_STRIDE\n// bytes while links take LINK_STRIDE bytes.\n\nexport function copyFrameToBuffer(frame, floatBuffer, byteBuffer, byteOffset, copyDoFValues = true, copyJointSettings = true) {\n  const floatOffset = byteOffset / 4;\n\n  if (copyJointSettings) {\n    const {\n      position,\n      quaternion\n    } = frame;\n\n    for (let i = 0; i < 3; i++) {\n      floatBuffer[floatOffset + 0 + i] = position[i];\n    }\n\n    for (let i = 0; i < 4; i++) {\n      floatBuffer[floatOffset + 3 + i] = quaternion[i];\n    }\n\n    if (frame.isJoint) {\n      const {\n        dofTarget,\n        dofRestPose,\n        minDoFLimit,\n        maxDoFLimit,\n        targetSet,\n        restPoseSet\n      } = frame;\n\n      for (let i = 0; i < 6; i++) {\n        floatBuffer[floatOffset + 7 + 0 * 6 + i] = dofTarget[i];\n        floatBuffer[floatOffset + 7 + 1 * 6 + i] = dofRestPose[i];\n        floatBuffer[floatOffset + 7 + 2 * 6 + i] = minDoFLimit[i];\n        floatBuffer[floatOffset + 7 + 3 * 6 + i] = maxDoFLimit[i];\n      }\n\n      byteBuffer[byteOffset + 148] = Number(targetSet);\n      byteBuffer[byteOffset + 149] = Number(restPoseSet);\n    }\n  }\n\n  if (copyDoFValues && frame.isJoint) {\n    const {\n      dofValues\n    } = frame;\n\n    for (let i = 0; i < 6; i++) {\n      floatBuffer[floatOffset + 7 + 4 * 6 + i] = dofValues[i];\n    }\n  }\n} // Copy data from the given buffer to the given frame starting at the given byte offset.\n\nexport function copyBufferToFrame(joint, floatBuffer, byteBuffer, byteOffset, copyDoFValues = true, copyJointSettings = true) {\n  const floatOffset = byteOffset / 4;\n\n  if (copyJointSettings) {\n    joint.setPosition(floatBuffer[floatOffset + 0], floatBuffer[floatOffset + 1], floatBuffer[floatOffset + 2]);\n    joint.setQuaternion(floatBuffer[floatOffset + 3 + 0], floatBuffer[floatOffset + 3 + 1], floatBuffer[floatOffset + 3 + 2], floatBuffer[floatOffset + 3 + 3]);\n\n    if (joint.isJoint) {\n      const {\n        dofTarget,\n        dofRestPose,\n        minDoFLimit,\n        maxDoFLimit\n      } = joint;\n\n      for (let i = 0; i < 6; i++) {\n        dofTarget[i] = floatBuffer[floatOffset + 7 + 0 * 6 + i];\n        dofRestPose[i] = floatBuffer[floatOffset + 7 + 1 * 6 + i];\n        minDoFLimit[i] = floatBuffer[floatOffset + 7 + 2 * 6 + i];\n        maxDoFLimit[i] = floatBuffer[floatOffset + 7 + 3 * 6 + i];\n      }\n\n      joint.targetSet = Boolean(byteBuffer[byteOffset + 148]);\n      joint.restPoseSet = Boolean(byteBuffer[byteOffset + 149]);\n    }\n  }\n\n  if (copyDoFValues && joint.isJoint) {\n    const {\n      dofValues\n    } = joint;\n    let changed = false;\n\n    for (let i = 0; i < 6; i++) {\n      const v = floatBuffer[floatOffset + 7 + 4 * 6 + i];\n\n      if (v !== dofValues[i]) {\n        dofValues[i] = v;\n        changed = true;\n      }\n    } // only update dof matrix if it changed\n\n\n    if (changed) {\n      joint.setMatrixDoFNeedsUpdate();\n    }\n  }\n}","map":{"version":3,"names":["JOINT_STRIDE","LINK_STRIDE","generateSharedBuffer","frames","useSharedArrayBuffer","arrayBuffer","SharedArrayBuffer","length","ArrayBuffer","float64","Float32Array","byte8","Uint8Array","applyToBuffer","floatBuffer","byteBuffer","copyDoFValues","copyJointSettings","i","l","copyFrameToBuffer","applyFromBuffer","copyBufferToFrame","frame","byteOffset","floatOffset","position","quaternion","isJoint","dofTarget","dofRestPose","minDoFLimit","maxDoFLimit","targetSet","restPoseSet","Number","dofValues","joint","setPosition","setQuaternion","Boolean","changed","v","setMatrixDoFNeedsUpdate"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/closed-chain-ik/src/worker/utils.js"],"sourcesContent":["export const JOINT_STRIDE = 304;\r\n\r\nexport const LINK_STRIDE = 56;\r\n\r\nexport function generateSharedBuffer( frames, useSharedArrayBuffer = true ) {\r\n\r\n\t// dofValues \t6 * 4\r\n\t// dofTarget \t6 * 4\r\n\t// dofRestPose \t6 * 4\r\n\t// minDoFLimit \t6 * 4\r\n\t// maxDoFLimit \t6 * 4\r\n\t// position \t3 * 4\r\n\t// quaternion \t4 * 4\r\n\t// targetSet \t1\r\n\t// restPoseSet \t1\r\n\t// --\r\n\t// total  \t\t150 bytes per joint\r\n\t// 4 byte aligned: 152\r\n\r\n\tlet arrayBuffer;\r\n\tif ( useSharedArrayBuffer ) {\r\n\r\n\t\tarrayBuffer = new SharedArrayBuffer( JOINT_STRIDE * frames.length );\r\n\r\n\t} else {\r\n\r\n\t\tarrayBuffer = new ArrayBuffer( JOINT_STRIDE * frames.length );\r\n\r\n\t}\r\n\r\n\tconst float64 = new Float32Array( arrayBuffer );\r\n\tconst byte8 = new Uint8Array( arrayBuffer );\r\n\tapplyToBuffer( frames, float64, byte8 );\r\n\treturn arrayBuffer;\r\n\r\n}\r\n\r\nexport function applyToBuffer( frames, floatBuffer, byteBuffer, copyDoFValues = true, copyJointSettings = true ) {\r\n\r\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\r\n\r\n\t\tcopyFrameToBuffer( frames[ i ], floatBuffer, byteBuffer, i * JOINT_STRIDE, copyDoFValues, copyJointSettings );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function applyFromBuffer( frames, floatBuffer, byteBuffer, copyDoFValues = true, copyJointSettings = true ) {\r\n\r\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\r\n\r\n\t\tcopyBufferToFrame( frames[ i ], floatBuffer, byteBuffer, JOINT_STRIDE * i, copyDoFValues, copyJointSettings );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Copy data from the frame to the given buffer starting at the given byte offset. Joints take JOINT_STRIDE\r\n// bytes while links take LINK_STRIDE bytes.\r\nexport function copyFrameToBuffer(\r\n\tframe,\r\n\tfloatBuffer,\r\n\tbyteBuffer,\r\n\tbyteOffset,\r\n\tcopyDoFValues = true,\r\n\tcopyJointSettings = true,\r\n) {\r\n\r\n\tconst floatOffset = byteOffset / 4;\r\n\tif ( copyJointSettings ) {\r\n\r\n\t\tconst {\r\n\t\t\tposition,\r\n\t\t\tquaternion,\r\n\t\t} = frame;\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tfloatBuffer[ floatOffset + 0 + i ] = position[ i ];\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\tfloatBuffer[ floatOffset + 3 + i ] = quaternion[ i ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( frame.isJoint ) {\r\n\r\n\t\t\tconst {\r\n\t\t\t\tdofTarget,\r\n\t\t\t\tdofRestPose,\r\n\t\t\t\tminDoFLimit,\r\n\t\t\t\tmaxDoFLimit,\r\n\t\t\t\ttargetSet,\r\n\t\t\t\trestPoseSet,\r\n\t\t\t} = frame;\r\n\r\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 0 * 6 + i ] = dofTarget[ i ];\r\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 1 * 6 + i ] = dofRestPose[ i ];\r\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 2 * 6 + i ] = minDoFLimit[ i ];\r\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 3 * 6 + i ] = maxDoFLimit[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbyteBuffer[ byteOffset + 148 ] = Number( targetSet );\r\n\t\t\tbyteBuffer[ byteOffset + 149 ] = Number( restPoseSet );\r\n\r\n\t\t}\r\n\r\n\r\n\t}\r\n\r\n\tif ( copyDoFValues && frame.isJoint ) {\r\n\r\n\t\tconst { dofValues } = frame;\r\n\r\n\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tfloatBuffer[ floatOffset + 7 + 4 * 6 + i ] = dofValues[ i ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Copy data from the given buffer to the given frame starting at the given byte offset.\r\nexport function copyBufferToFrame(\r\n\tjoint,\r\n\tfloatBuffer,\r\n\tbyteBuffer,\r\n\tbyteOffset,\r\n\tcopyDoFValues = true,\r\n\tcopyJointSettings = true,\r\n) {\r\n\r\n\tconst floatOffset = byteOffset / 4;\r\n\r\n\tif ( copyJointSettings ) {\r\n\r\n\t\tjoint.setPosition(\r\n\t\t\tfloatBuffer[ floatOffset + 0 ],\r\n\t\t\tfloatBuffer[ floatOffset + 1 ],\r\n\t\t\tfloatBuffer[ floatOffset + 2 ],\r\n\t\t);\r\n\t\tjoint.setQuaternion(\r\n\t\t\tfloatBuffer[ floatOffset + 3 + 0 ],\r\n\t\t\tfloatBuffer[ floatOffset + 3 + 1 ],\r\n\t\t\tfloatBuffer[ floatOffset + 3 + 2 ],\r\n\t\t\tfloatBuffer[ floatOffset + 3 + 3 ],\r\n\t\t);\r\n\r\n\t\tif ( joint.isJoint ) {\r\n\r\n\t\t\tconst {\r\n\t\t\t\tdofTarget,\r\n\t\t\t\tdofRestPose,\r\n\t\t\t\tminDoFLimit,\r\n\t\t\t\tmaxDoFLimit,\r\n\t\t\t} = joint;\r\n\r\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\tdofTarget[ i ] = floatBuffer[ floatOffset + 7 + 0 * 6 + i ];\r\n\t\t\t\tdofRestPose[ i ] = floatBuffer[ floatOffset + 7 + 1 * 6 + i ];\r\n\t\t\t\tminDoFLimit[ i ] = floatBuffer[ floatOffset + 7 + 2 * 6 + i ];\r\n\t\t\t\tmaxDoFLimit[ i ] = floatBuffer[ floatOffset + 7 + 3 * 6 + i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tjoint.targetSet = Boolean( byteBuffer[ byteOffset + 148 ] );\r\n\t\t\tjoint.restPoseSet = Boolean( byteBuffer[ byteOffset + 149 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( copyDoFValues && joint.isJoint ) {\r\n\r\n\t\tconst { dofValues } = joint;\r\n\t\tlet changed = false;\r\n\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tconst v = floatBuffer[ floatOffset + 7 + 4 * 6 + i ];\r\n\t\t\tif ( v !== dofValues[ i ] ) {\r\n\r\n\t\t\t\tdofValues[ i ] = v;\r\n\t\t\t\tchanged = true;\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t}\r\n\r\n\t\t// only update dof matrix if it changed\r\n\t\tif ( changed ) {\r\n\r\n\t\t\tjoint.setMatrixDoFNeedsUpdate();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}