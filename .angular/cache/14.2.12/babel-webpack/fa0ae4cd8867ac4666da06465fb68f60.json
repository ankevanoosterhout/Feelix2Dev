{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class Pool2DProgram {\n  constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {\n    this.variableNames = ['x'];\n\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n\n    const filterWidth = convInfo.filterWidth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    this.outputShape = convInfo.outShape;\n    const isAvgPool = poolType === 'avg';\n    const batchFlattenPositionStr = `((batch  * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n    const flattenPositionStr = `(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n    let initializationValue = '0.0';\n\n    if (!isAvgPool) {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '-1.0 / 1e-20';\n    }\n\n    if (computePositions) {\n      const compareOp = '>=';\n      this.userCode = `\n        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n        const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${compareOp} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${flattenPositions ? includeBatchInIndex ? batchFlattenPositionStr : flattenPositionStr : `wR * ${effectiveFilterWidth} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n      return;\n    }\n\n    const compareOp = 'max';\n    let returnValue = `${poolType}(${poolType}(${poolType}(` + 'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n\n    if (poolType === 'avg') {\n      returnValue = `avgValue / count`;\n    }\n\n    const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n    const filterWidthVec4Remainder = filterWidth % 4;\n    const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n    this.userCode = `\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              getValue(batch, xR, xC + 3 * ${dilationWidth}, d)\n            );\n\n            ${updateSnippet}\n          }\n\n          int xC = xCCorner + ${filterWidthNearestVec4};\n          if (${filterWidthVec4Remainder === 1}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 2}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 3}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              initializationValue\n            );\n\n            ${updateSnippet}\n          }\n        }\n        setOutput(${returnValue});\n      }\n    `;\n  }\n\n}\nexport class Pool3DProgram {\n  constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {\n    this.variableNames = ['x'];\n\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n\n    const filterWidth = convInfo.filterWidth;\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    this.outputShape = convInfo.outShape;\n    const isAvgPool = poolType === 'avg';\n    let initializationValue = '0.0';\n\n    if (!isAvgPool) {\n      // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n      initializationValue = '-1.0 / 1e-20';\n    }\n\n    if (computePositions) {\n      const compareOp = '>=';\n      this.userCode = `\n        const ivec3 strides =\n            ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${effectiveFilterDepth};\n              wD += ${dilationDepth}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${convInfo.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${effectiveFilterHeight};\n                wR += ${dilationHeight}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${convInfo.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${effectiveFilterWidth};\n                  wC += ${dilationWidth}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${compareOp} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${flattenPositions ? includeBatchInIndex ? `(((batch * ${convInfo.inDepth} + xD) * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` : `((xD * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` : `wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +\n                      wR * ${effectiveFilterWidth} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n      return;\n    }\n\n    const compareOp = 'max';\n    let returnValue = `${poolType}(${poolType}(${poolType}(` + 'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n\n    if (poolType === 'avg') {\n      returnValue = `avgValue / count`;\n    }\n\n    const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n    const filterWidthVec4Remainder = filterWidth % 4;\n    const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n    this.userCode = `\n      const ivec3 strides =\n        ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n            wD += ${dilationDepth}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)\n              );\n\n              ${updateSnippet}\n            }\n\n            int xC = xCCorner + ${filterWidthNearestVec4};\n            if (${filterWidthVec4Remainder === 1}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 2}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 3}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                initializationValue\n              );\n\n              ${updateSnippet}\n            }\n          }\n          setOutput(${returnValue});\n        }\n      }\n    `;\n  }\n\n}","map":{"version":3,"names":["Pool2DProgram","constructor","convInfo","poolType","computePositions","flattenPositions","includeBatchInIndex","variableNames","Error","filterWidth","strideHeight","strideWidth","dilationHeight","dilationWidth","effectiveFilterHeight","effectiveFilterWidth","padTop","padInfo","top","padLeft","left","outputShape","outShape","isAvgPool","batchFlattenPositionStr","inHeight","inWidth","inChannels","flattenPositionStr","initializationValue","compareOp","userCode","returnValue","filterWidthNearestVec4","Math","floor","filterWidthVec4Remainder","updateSnippet","Pool3DProgram","strideDepth","dilationDepth","effectiveFilterDepth","padFront","front","inDepth"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-webgl/dist/pool_gpu.js"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class Pool2DProgram {\n    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {\n        this.variableNames = ['x'];\n        if (poolType === 'avg' && computePositions) {\n            throw new Error('Cannot compute positions for average pool.');\n        }\n        const filterWidth = convInfo.filterWidth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        this.outputShape = convInfo.outShape;\n        const isAvgPool = poolType === 'avg';\n        const batchFlattenPositionStr = `((batch  * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n        const flattenPositionStr = `(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n        let initializationValue = '0.0';\n        if (!isAvgPool) {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '-1.0 / 1e-20';\n        }\n        if (computePositions) {\n            const compareOp = '>=';\n            this.userCode = `\n        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n        const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${compareOp} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${flattenPositions ? (includeBatchInIndex ? batchFlattenPositionStr :\n                flattenPositionStr) :\n                `wR * ${effectiveFilterWidth} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n            return;\n        }\n        const compareOp = 'max';\n        let returnValue = `${poolType}(${poolType}(${poolType}(` +\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n        if (poolType === 'avg') {\n            returnValue = `avgValue / count`;\n        }\n        const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n        const filterWidthVec4Remainder = filterWidth % 4;\n        const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n        this.userCode = `\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              getValue(batch, xR, xC + 3 * ${dilationWidth}, d)\n            );\n\n            ${updateSnippet}\n          }\n\n          int xC = xCCorner + ${filterWidthNearestVec4};\n          if (${filterWidthVec4Remainder === 1}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 2}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 3}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              initializationValue\n            );\n\n            ${updateSnippet}\n          }\n        }\n        setOutput(${returnValue});\n      }\n    `;\n    }\n}\nexport class Pool3DProgram {\n    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {\n        this.variableNames = ['x'];\n        if (poolType === 'avg' && computePositions) {\n            throw new Error('Cannot compute positions for average pool.');\n        }\n        const filterWidth = convInfo.filterWidth;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        this.outputShape = convInfo.outShape;\n        const isAvgPool = poolType === 'avg';\n        let initializationValue = '0.0';\n        if (!isAvgPool) {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '-1.0 / 1e-20';\n        }\n        if (computePositions) {\n            const compareOp = '>=';\n            this.userCode = `\n        const ivec3 strides =\n            ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${effectiveFilterDepth};\n              wD += ${dilationDepth}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${convInfo.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${effectiveFilterHeight};\n                wR += ${dilationHeight}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${convInfo.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${effectiveFilterWidth};\n                  wC += ${dilationWidth}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${compareOp} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${flattenPositions ?\n                (includeBatchInIndex ?\n                    `(((batch * ${convInfo.inDepth} + xD) * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` :\n                    `((xD * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch`) :\n                `wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +\n                      wR * ${effectiveFilterWidth} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n            return;\n        }\n        const compareOp = 'max';\n        let returnValue = `${poolType}(${poolType}(${poolType}(` +\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n        if (poolType === 'avg') {\n            returnValue = `avgValue / count`;\n        }\n        const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n        const filterWidthVec4Remainder = filterWidth % 4;\n        const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n        this.userCode = `\n      const ivec3 strides =\n        ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n            wD += ${dilationDepth}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)\n              );\n\n              ${updateSnippet}\n            }\n\n            int xC = xCCorner + ${filterWidthNearestVec4};\n            if (${filterWidthVec4Remainder === 1}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 2}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 3}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                initializationValue\n              );\n\n              ${updateSnippet}\n            }\n          }\n          setOutput(${returnValue});\n        }\n      }\n    `;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}