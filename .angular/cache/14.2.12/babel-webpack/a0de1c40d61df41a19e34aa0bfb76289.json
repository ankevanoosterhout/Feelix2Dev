{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { env, tensor, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of tensors from microphone audio stream. The tensors are\n * representing audio data as frequency-domain spectrogram generated with\n * browser's native FFT. Tensors representing time-domain waveform is available\n * based on configuration. Only works in browser environment.\n */\n\nexport class MicrophoneIterator extends LazyIterator {\n  constructor(microphoneConfig) {\n    super();\n    this.microphoneConfig = microphoneConfig;\n    this.isClosed = false;\n    this.fftSize = microphoneConfig.fftSize || 1024;\n    const fftSizeLog2 = Math.log2(this.fftSize);\n\n    if (this.fftSize < 0 || fftSizeLog2 < 4 || fftSizeLog2 > 14 || !Number.isInteger(fftSizeLog2)) {\n      throw new Error(`Invalid fftSize: it must be a power of 2 between ` + `2 to 4 and 2 to 14, but got ${this.fftSize}`);\n    }\n\n    this.numFrames = microphoneConfig.numFramesPerSpectrogram || 43;\n    this.sampleRateHz = microphoneConfig.sampleRateHz;\n    this.columnTruncateLength = microphoneConfig.columnTruncateLength || this.fftSize;\n    this.audioTrackConstraints = microphoneConfig.audioTrackConstraints;\n    this.smoothingTimeConstant = microphoneConfig.smoothingTimeConstant || 0;\n    this.includeSpectrogram = microphoneConfig.includeSpectrogram === false ? false : true;\n    this.includeWaveform = microphoneConfig.includeWaveform === true ? true : false;\n\n    if (!this.includeSpectrogram && !this.includeWaveform) {\n      throw new Error('Both includeSpectrogram and includeWaveform are false. ' + 'At least one type of data should be returned.');\n    }\n  }\n\n  summary() {\n    return `microphone`;\n  } // Construct a MicrophoneIterator and start the audio stream.\n\n\n  static create(microphoneConfig = {}) {\n    return _asyncToGenerator(function* () {\n      if (!env().get('IS_BROWSER')) {\n        throw new Error('microphone API is only supported in browser environment.');\n      }\n\n      const microphoneIterator = new MicrophoneIterator(microphoneConfig); // Call async function start() to initialize the audio stream.\n\n      yield microphoneIterator.start();\n      return microphoneIterator;\n    })();\n  } // Start the audio stream and FFT.\n\n\n  start() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        _this.stream = yield navigator.mediaDevices.getUserMedia({\n          audio: _this.audioTrackConstraints == null ? true : _this.audioTrackConstraints,\n          video: false\n        });\n      } catch (e) {\n        throw new Error(`Error thrown while initializing video stream: ${e.message}`);\n      }\n\n      if (!_this.stream) {\n        throw new Error('Could not obtain audio from microphone.');\n      }\n\n      const ctxConstructor = // tslint:disable-next-line:no-any\n      window.AudioContext || window.webkitAudioContext;\n      _this.audioContext = new ctxConstructor();\n\n      if (!_this.sampleRateHz) {\n        // If sample rate is not provided, use the available sample rate on\n        // device.\n        _this.sampleRateHz = _this.audioContext.sampleRate;\n      } else if (_this.audioContext.sampleRate !== _this.sampleRateHz) {\n        throw new Error(`Mismatch in sampling rate: ` + `Expected: ${_this.sampleRateHz}; ` + `Actual: ${_this.audioContext.sampleRate}`);\n      }\n\n      const streamSource = _this.audioContext.createMediaStreamSource(_this.stream);\n\n      _this.analyser = _this.audioContext.createAnalyser();\n      _this.analyser.fftSize = _this.fftSize * 2;\n      _this.analyser.smoothingTimeConstant = _this.smoothingTimeConstant;\n      streamSource.connect(_this.analyser);\n      _this.freqData = new Float32Array(_this.fftSize);\n      _this.timeData = new Float32Array(_this.fftSize);\n      return;\n    })();\n  }\n\n  next() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this2.isClosed) {\n        return {\n          value: null,\n          done: true\n        };\n      }\n\n      let spectrogramTensor;\n      let waveformTensor;\n      const audioDataQueue = yield _this2.getAudioData();\n\n      if (_this2.includeSpectrogram) {\n        const freqData = _this2.flattenQueue(audioDataQueue.freqDataQueue);\n\n        spectrogramTensor = _this2.getTensorFromAudioDataArray(freqData, [_this2.numFrames, _this2.columnTruncateLength, 1]);\n      }\n\n      if (_this2.includeWaveform) {\n        const timeData = _this2.flattenQueue(audioDataQueue.timeDataQueue);\n\n        waveformTensor = _this2.getTensorFromAudioDataArray(timeData, [_this2.numFrames * _this2.fftSize, 1]);\n      }\n\n      return {\n        value: {\n          'spectrogram': spectrogramTensor,\n          'waveform': waveformTensor\n        },\n        done: false\n      };\n    })();\n  } // Capture one result from the audio stream, and extract the value from\n  // iterator.next() result.\n\n\n  capture() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this3.next()).value;\n    })();\n  }\n\n  getAudioData() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const freqDataQueue = [];\n      const timeDataQueue = [];\n      let currentFrames = 0;\n      return new Promise(resolve => {\n        const intervalID = setInterval(() => {\n          if (_this4.includeSpectrogram) {\n            _this4.analyser.getFloatFrequencyData(_this4.freqData); // If the audio stream is initializing, return empty queue.\n\n\n            if (_this4.freqData[0] === -Infinity) {\n              resolve({\n                freqDataQueue,\n                timeDataQueue\n              });\n            }\n\n            freqDataQueue.push(_this4.freqData.slice(0, _this4.columnTruncateLength));\n          }\n\n          if (_this4.includeWaveform) {\n            _this4.analyser.getFloatTimeDomainData(_this4.timeData);\n\n            timeDataQueue.push(_this4.timeData.slice());\n          } // Clean interval and return when all frames have been collected\n\n\n          if (++currentFrames === _this4.numFrames) {\n            clearInterval(intervalID);\n            resolve({\n              freqDataQueue,\n              timeDataQueue\n            });\n          }\n        }, _this4.fftSize / _this4.sampleRateHz * 1e3);\n      });\n    })();\n  } // Stop the audio stream and pause the iterator.\n\n\n  stop() {\n    if (!this.isClosed) {\n      this.isClosed = true;\n      this.analyser.disconnect();\n      this.audioContext.close();\n\n      if (this.stream != null && this.stream.getTracks().length > 0) {\n        this.stream.getTracks()[0].stop();\n      }\n    }\n  } // Override toArray() function to prevent collecting.\n\n\n  toArray() {\n    throw new Error('Can not convert infinite audio stream to array.');\n  } // Return audio sampling rate in Hz\n\n\n  getSampleRate() {\n    return this.sampleRateHz;\n  }\n\n  flattenQueue(queue) {\n    const frameSize = queue[0].length;\n    const freqData = new Float32Array(queue.length * frameSize);\n    queue.forEach((data, i) => freqData.set(data, i * frameSize));\n    return freqData;\n  }\n\n  getTensorFromAudioDataArray(freqData, shape) {\n    const vals = new Float32Array(util.sizeFromShape(shape)); // If the data is less than the output shape, the rest is padded with zeros.\n\n    vals.set(freqData, vals.length - freqData.length);\n    return tensor(vals, shape);\n  }\n\n}","map":{"version":3,"names":["env","tensor","util","LazyIterator","MicrophoneIterator","constructor","microphoneConfig","isClosed","fftSize","fftSizeLog2","Math","log2","Number","isInteger","Error","numFrames","numFramesPerSpectrogram","sampleRateHz","columnTruncateLength","audioTrackConstraints","smoothingTimeConstant","includeSpectrogram","includeWaveform","summary","create","get","microphoneIterator","start","stream","navigator","mediaDevices","getUserMedia","audio","video","e","message","ctxConstructor","window","AudioContext","webkitAudioContext","audioContext","sampleRate","streamSource","createMediaStreamSource","analyser","createAnalyser","connect","freqData","Float32Array","timeData","next","value","done","spectrogramTensor","waveformTensor","audioDataQueue","getAudioData","flattenQueue","freqDataQueue","getTensorFromAudioDataArray","timeDataQueue","capture","currentFrames","Promise","resolve","intervalID","setInterval","getFloatFrequencyData","Infinity","push","slice","getFloatTimeDomainData","clearInterval","stop","disconnect","close","getTracks","length","toArray","getSampleRate","queue","frameSize","forEach","data","i","set","shape","vals","sizeFromShape"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-data/dist/iterators/microphone_iterator.js"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { env, tensor, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of tensors from microphone audio stream. The tensors are\n * representing audio data as frequency-domain spectrogram generated with\n * browser's native FFT. Tensors representing time-domain waveform is available\n * based on configuration. Only works in browser environment.\n */\nexport class MicrophoneIterator extends LazyIterator {\n    constructor(microphoneConfig) {\n        super();\n        this.microphoneConfig = microphoneConfig;\n        this.isClosed = false;\n        this.fftSize = microphoneConfig.fftSize || 1024;\n        const fftSizeLog2 = Math.log2(this.fftSize);\n        if (this.fftSize < 0 || fftSizeLog2 < 4 || fftSizeLog2 > 14 ||\n            !Number.isInteger(fftSizeLog2)) {\n            throw new Error(`Invalid fftSize: it must be a power of 2 between ` +\n                `2 to 4 and 2 to 14, but got ${this.fftSize}`);\n        }\n        this.numFrames = microphoneConfig.numFramesPerSpectrogram || 43;\n        this.sampleRateHz = microphoneConfig.sampleRateHz;\n        this.columnTruncateLength =\n            microphoneConfig.columnTruncateLength || this.fftSize;\n        this.audioTrackConstraints = microphoneConfig.audioTrackConstraints;\n        this.smoothingTimeConstant = microphoneConfig.smoothingTimeConstant || 0;\n        this.includeSpectrogram =\n            microphoneConfig.includeSpectrogram === false ? false : true;\n        this.includeWaveform =\n            microphoneConfig.includeWaveform === true ? true : false;\n        if (!this.includeSpectrogram && !this.includeWaveform) {\n            throw new Error('Both includeSpectrogram and includeWaveform are false. ' +\n                'At least one type of data should be returned.');\n        }\n    }\n    summary() {\n        return `microphone`;\n    }\n    // Construct a MicrophoneIterator and start the audio stream.\n    static async create(microphoneConfig = {}) {\n        if (!env().get('IS_BROWSER')) {\n            throw new Error('microphone API is only supported in browser environment.');\n        }\n        const microphoneIterator = new MicrophoneIterator(microphoneConfig);\n        // Call async function start() to initialize the audio stream.\n        await microphoneIterator.start();\n        return microphoneIterator;\n    }\n    // Start the audio stream and FFT.\n    async start() {\n        try {\n            this.stream = await navigator.mediaDevices.getUserMedia({\n                audio: this.audioTrackConstraints == null ? true :\n                    this.audioTrackConstraints,\n                video: false\n            });\n        }\n        catch (e) {\n            throw new Error(`Error thrown while initializing video stream: ${e.message}`);\n        }\n        if (!this.stream) {\n            throw new Error('Could not obtain audio from microphone.');\n        }\n        const ctxConstructor = \n        // tslint:disable-next-line:no-any\n        window.AudioContext || window.webkitAudioContext;\n        this.audioContext = new ctxConstructor();\n        if (!this.sampleRateHz) {\n            // If sample rate is not provided, use the available sample rate on\n            // device.\n            this.sampleRateHz = this.audioContext.sampleRate;\n        }\n        else if (this.audioContext.sampleRate !== this.sampleRateHz) {\n            throw new Error(`Mismatch in sampling rate: ` +\n                `Expected: ${this.sampleRateHz}; ` +\n                `Actual: ${this.audioContext.sampleRate}`);\n        }\n        const streamSource = this.audioContext.createMediaStreamSource(this.stream);\n        this.analyser = this.audioContext.createAnalyser();\n        this.analyser.fftSize = this.fftSize * 2;\n        this.analyser.smoothingTimeConstant = this.smoothingTimeConstant;\n        streamSource.connect(this.analyser);\n        this.freqData = new Float32Array(this.fftSize);\n        this.timeData = new Float32Array(this.fftSize);\n        return;\n    }\n    async next() {\n        if (this.isClosed) {\n            return { value: null, done: true };\n        }\n        let spectrogramTensor;\n        let waveformTensor;\n        const audioDataQueue = await this.getAudioData();\n        if (this.includeSpectrogram) {\n            const freqData = this.flattenQueue(audioDataQueue.freqDataQueue);\n            spectrogramTensor = this.getTensorFromAudioDataArray(freqData, [this.numFrames, this.columnTruncateLength, 1]);\n        }\n        if (this.includeWaveform) {\n            const timeData = this.flattenQueue(audioDataQueue.timeDataQueue);\n            waveformTensor = this.getTensorFromAudioDataArray(timeData, [this.numFrames * this.fftSize, 1]);\n        }\n        return {\n            value: { 'spectrogram': spectrogramTensor, 'waveform': waveformTensor },\n            done: false\n        };\n    }\n    // Capture one result from the audio stream, and extract the value from\n    // iterator.next() result.\n    async capture() {\n        return (await this.next()).value;\n    }\n    async getAudioData() {\n        const freqDataQueue = [];\n        const timeDataQueue = [];\n        let currentFrames = 0;\n        return new Promise(resolve => {\n            const intervalID = setInterval(() => {\n                if (this.includeSpectrogram) {\n                    this.analyser.getFloatFrequencyData(this.freqData);\n                    // If the audio stream is initializing, return empty queue.\n                    if (this.freqData[0] === -Infinity) {\n                        resolve({ freqDataQueue, timeDataQueue });\n                    }\n                    freqDataQueue.push(this.freqData.slice(0, this.columnTruncateLength));\n                }\n                if (this.includeWaveform) {\n                    this.analyser.getFloatTimeDomainData(this.timeData);\n                    timeDataQueue.push(this.timeData.slice());\n                }\n                // Clean interval and return when all frames have been collected\n                if (++currentFrames === this.numFrames) {\n                    clearInterval(intervalID);\n                    resolve({ freqDataQueue, timeDataQueue });\n                }\n            }, this.fftSize / this.sampleRateHz * 1e3);\n        });\n    }\n    // Stop the audio stream and pause the iterator.\n    stop() {\n        if (!this.isClosed) {\n            this.isClosed = true;\n            this.analyser.disconnect();\n            this.audioContext.close();\n            if (this.stream != null && this.stream.getTracks().length > 0) {\n                this.stream.getTracks()[0].stop();\n            }\n        }\n    }\n    // Override toArray() function to prevent collecting.\n    toArray() {\n        throw new Error('Can not convert infinite audio stream to array.');\n    }\n    // Return audio sampling rate in Hz\n    getSampleRate() {\n        return this.sampleRateHz;\n    }\n    flattenQueue(queue) {\n        const frameSize = queue[0].length;\n        const freqData = new Float32Array(queue.length * frameSize);\n        queue.forEach((data, i) => freqData.set(data, i * frameSize));\n        return freqData;\n    }\n    getTensorFromAudioDataArray(freqData, shape) {\n        const vals = new Float32Array(util.sizeFromShape(shape));\n        // If the data is less than the output shape, the rest is padded with zeros.\n        vals.set(freqData, vals.length - freqData.length);\n        return tensor(vals, shape);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}