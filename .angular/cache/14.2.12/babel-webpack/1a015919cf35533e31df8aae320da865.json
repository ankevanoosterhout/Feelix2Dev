{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { clone, util } from '@tensorflow/tfjs-core';\nexport function getParamValue(paramName, node, tensorMap, context, resourceManager) {\n  const inputParam = node.inputParams[paramName];\n\n  if (inputParam && inputParam.inputIndexStart !== undefined) {\n    const start = inputParam.inputIndexStart;\n    const end = inputParam.inputIndexEnd === 0 ? undefined : inputParam.inputIndexEnd === undefined ? start + 1 : inputParam.inputIndexEnd;\n\n    if (inputParam.type === 'tensor') {\n      return getTensor(node.inputNames[inputParam.inputIndexStart], tensorMap, context, resourceManager);\n    }\n\n    if (inputParam.type === 'tensors') {\n      const inputs = node.inputNames.slice(start, end);\n      return inputs.map(name => getTensor(name, tensorMap, context, resourceManager));\n    }\n\n    const tensor = getTensor(node.inputNames.slice(start)[0], tensorMap, context, resourceManager);\n    const data = tensor.dataSync();\n    return inputParam.type === 'number' ? data[0] : util.toNestedArray(tensor.shape, data);\n  }\n\n  const attrParam = node.attrParams[paramName];\n  return attrParam && attrParam.value;\n}\n/**\n * Retrieve the tensor from tensorsMap based on input name.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n * @param context contains tensors and information for running the current node.\n * @param resourceManager Optional. Contains global resources of the model.\n */\n\nexport function getTensor(name, tensorsMap, context, resourceManager) {\n  const [nodeName, index] = parseNodeName(name);\n\n  if (resourceManager != null) {\n    const tensor = resourceManager.getHashTableHandleByName(nodeName);\n\n    if (tensor != null) {\n      return tensor;\n    }\n  }\n\n  const contextId = context.currentContextIds.find(contextId => {\n    return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId)];\n  });\n  return contextId !== undefined ? tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index] : undefined;\n}\n/**\n * Retrieve the tensors based on input name for current context.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n */\n\nexport function getTensorsForCurrentContenxt(name, tensorsMap, context) {\n  return tensorsMap[getNodeNameWithContextId(name, context.currentContextId)];\n}\n/**\n * Returns the node name, outputName and index from the Node input name.\n * @param inputName The input name of the node, in format of\n * node_name:output_index, i.e. MatMul:0, if the output_index is not set, it is\n * default to 0.\n * If the input name contains output name i.e. StringSplit:indices:0, it will\n * return ['StringSplit', 0, 'indices'].\n */\n\nexport function getNodeNameAndIndex(inputName, context) {\n  const [nodeName, index, outputName] = parseNodeName(inputName);\n  return [getNodeNameWithContextId(nodeName, context && context.currentContextId), index, outputName];\n}\n\nfunction getNodeNameWithContextId(name, contextId) {\n  return !!contextId ? `${name}-${contextId}` : name;\n}\n\nexport function parseNodeName(name) {\n  const parts = name.split(':');\n\n  if (parts.length === 1) {\n    return [name, 0, undefined];\n  }\n\n  const nodeName = parts[0];\n  const outputName = parts.length === 3 ? parts[1] : undefined;\n  const index = Number(parts[parts.length - 1]);\n  return [nodeName, index, outputName];\n}\nexport function split(arr, size) {\n  const res = [];\n\n  for (let i = 0; i < arr.length; i += size) {\n    res.push(arr.slice(i, i + size));\n  }\n\n  return res;\n}\nexport function getPadding(node, tensorMap, context) {\n  let pad = getParamValue('pad', node, tensorMap, context);\n\n  if (pad === 'explicit') {\n    // This is 1d array, we need to convert it to 2d array\n    pad = getParamValue('explicitPaddings', node, tensorMap, context);\n    const explicitPadding = [[0, 0], [0, 0], [0, 0], [0, 0]];\n\n    for (let i = 0; i < 4; i++) {\n      explicitPadding[i][0] = pad[i * 2];\n      explicitPadding[i][1] = pad[i * 2 + 1];\n    }\n\n    return explicitPadding;\n  }\n\n  return pad;\n}\n/**\n *  Reuse the tensor if it is marked as keep, otherwise clone the tensor to\n *  avoid disposal. This is important for TensorArray and TensorList ops, since\n *  internally they use a tensor as the id for TensorArray and TensorList, and\n * to simplify lookup, they also use Tensor.id as the key to the internal map.\n * These id tensors have been marked as kept in the backend, we need avoid clone\n * them in order to create new Tensor.id.\n * @param tensor\n */\n\nexport function cloneTensor(tensor) {\n  return tensor.kept ? tensor : clone(tensor);\n}","map":{"version":3,"names":["clone","util","getParamValue","paramName","node","tensorMap","context","resourceManager","inputParam","inputParams","inputIndexStart","undefined","start","end","inputIndexEnd","type","getTensor","inputNames","inputs","slice","map","name","tensor","data","dataSync","toNestedArray","shape","attrParam","attrParams","value","tensorsMap","nodeName","index","parseNodeName","getHashTableHandleByName","contextId","currentContextIds","find","getNodeNameWithContextId","getTensorsForCurrentContenxt","currentContextId","getNodeNameAndIndex","inputName","outputName","parts","split","length","Number","arr","size","res","i","push","getPadding","pad","explicitPadding","cloneTensor","kept"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-converter/dist/operations/executors/utils.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { clone, util } from '@tensorflow/tfjs-core';\nexport function getParamValue(paramName, node, tensorMap, context, resourceManager) {\n    const inputParam = node.inputParams[paramName];\n    if (inputParam && inputParam.inputIndexStart !== undefined) {\n        const start = inputParam.inputIndexStart;\n        const end = inputParam.inputIndexEnd === 0 ?\n            undefined :\n            (inputParam.inputIndexEnd === undefined ? start + 1 :\n                inputParam.inputIndexEnd);\n        if (inputParam.type === 'tensor') {\n            return getTensor(node.inputNames[inputParam.inputIndexStart], tensorMap, context, resourceManager);\n        }\n        if (inputParam.type === 'tensors') {\n            const inputs = node.inputNames.slice(start, end);\n            return inputs.map(name => getTensor(name, tensorMap, context, resourceManager));\n        }\n        const tensor = getTensor(node.inputNames.slice(start)[0], tensorMap, context, resourceManager);\n        const data = tensor.dataSync();\n        return inputParam.type === 'number' ?\n            data[0] :\n            util.toNestedArray(tensor.shape, data);\n    }\n    const attrParam = node.attrParams[paramName];\n    return attrParam && attrParam.value;\n}\n/**\n * Retrieve the tensor from tensorsMap based on input name.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n * @param context contains tensors and information for running the current node.\n * @param resourceManager Optional. Contains global resources of the model.\n */\nexport function getTensor(name, tensorsMap, context, resourceManager) {\n    const [nodeName, index] = parseNodeName(name);\n    if (resourceManager != null) {\n        const tensor = resourceManager.getHashTableHandleByName(nodeName);\n        if (tensor != null) {\n            return tensor;\n        }\n    }\n    const contextId = context.currentContextIds.find(contextId => {\n        return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId)];\n    });\n    return contextId !== undefined ?\n        tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index] :\n        undefined;\n}\n/**\n * Retrieve the tensors based on input name for current context.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n */\nexport function getTensorsForCurrentContenxt(name, tensorsMap, context) {\n    return tensorsMap[getNodeNameWithContextId(name, context.currentContextId)];\n}\n/**\n * Returns the node name, outputName and index from the Node input name.\n * @param inputName The input name of the node, in format of\n * node_name:output_index, i.e. MatMul:0, if the output_index is not set, it is\n * default to 0.\n * If the input name contains output name i.e. StringSplit:indices:0, it will\n * return ['StringSplit', 0, 'indices'].\n */\nexport function getNodeNameAndIndex(inputName, context) {\n    const [nodeName, index, outputName] = parseNodeName(inputName);\n    return [\n        getNodeNameWithContextId(nodeName, context && context.currentContextId),\n        index, outputName\n    ];\n}\nfunction getNodeNameWithContextId(name, contextId) {\n    return !!contextId ? `${name}-${contextId}` : name;\n}\nexport function parseNodeName(name) {\n    const parts = name.split(':');\n    if (parts.length === 1) {\n        return [name, 0, undefined];\n    }\n    const nodeName = parts[0];\n    const outputName = parts.length === 3 ? parts[1] : undefined;\n    const index = Number(parts[parts.length - 1]);\n    return [nodeName, index, outputName];\n}\nexport function split(arr, size) {\n    const res = [];\n    for (let i = 0; i < arr.length; i += size) {\n        res.push(arr.slice(i, i + size));\n    }\n    return res;\n}\nexport function getPadding(node, tensorMap, context) {\n    let pad = getParamValue('pad', node, tensorMap, context);\n    if (pad === 'explicit') {\n        // This is 1d array, we need to convert it to 2d array\n        pad = getParamValue('explicitPaddings', node, tensorMap, context);\n        const explicitPadding = [[0, 0], [0, 0], [0, 0], [0, 0]];\n        for (let i = 0; i < 4; i++) {\n            explicitPadding[i][0] = pad[i * 2];\n            explicitPadding[i][1] = pad[i * 2 + 1];\n        }\n        return explicitPadding;\n    }\n    return pad;\n}\n/**\n *  Reuse the tensor if it is marked as keep, otherwise clone the tensor to\n *  avoid disposal. This is important for TensorArray and TensorList ops, since\n *  internally they use a tensor as the id for TensorArray and TensorList, and\n * to simplify lookup, they also use Tensor.id as the key to the internal map.\n * These id tensors have been marked as kept in the backend, we need avoid clone\n * them in order to create new Tensor.id.\n * @param tensor\n */\nexport function cloneTensor(tensor) {\n    return tensor.kept ? tensor : clone(tensor);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}