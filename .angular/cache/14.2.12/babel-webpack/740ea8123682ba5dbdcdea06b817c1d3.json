{"ast":null,"code":"import { computeStrides, sizeFromShape } from '../util';\n/**\n * Validate gather nd inputs.\n *\n * @param tensor The tensor contains the source values.\n * @param indices The tensor contains the indices to slice the source.\n *\n * @returns [resultShape, numUpdates, sliceSize, strides]\n */\n\nexport function prepareAndValidate(tensor, indices) {\n  const tensorRank = tensor.shape.length;\n  const indicesRank = indices.shape.length;\n\n  if (tensorRank < 1) {\n    throw new Error('tf.gatherND() expects the input to be rank 1 or higher,' + ` but the rank was ${tensorRank}.`);\n  }\n\n  if (indicesRank < 1) {\n    throw new Error('tf.gatherND() expects the indices to be rank 1 or higher,' + ` but the rank was ${indicesRank}.`);\n  }\n\n  if (indices.dtype !== 'int32') {\n    throw new Error('tf.gatherND() expects the indices to be int32 type,' + ` but the dtype was ${indices.dtype}.`);\n  }\n\n  if (indices.shape[indicesRank - 1] > tensorRank) {\n    throw new Error('index innermost dimension length must be <= tensor rank; saw: ' + `${indices.shape[indicesRank - 1]} vs. ${tensorRank}`);\n  }\n\n  if (sizeFromShape(tensor.shape) === 0) {\n    throw new Error('Requested more than 0 entries, but input is empty.' + ` Input shape: ${tensor.shape}.`);\n  }\n\n  const indicesShape = indices.shape;\n  const sliceRank = indicesShape[indicesShape.length - 1]; // The result shape is\n  //   indices.shape[:-1] + params.shape[indices.shape[-1]:]\n\n  let nResult = 1;\n\n  for (let i = 0; i < indicesShape.length - 1; ++i) {\n    nResult *= indicesShape[i];\n  }\n\n  const inputShape = tensor.shape;\n  const resultShape = indicesShape.slice();\n  resultShape.pop();\n  let sliceSize = 1;\n\n  for (let i = sliceRank; i < tensorRank; ++i) {\n    sliceSize *= inputShape[i];\n    resultShape.push(inputShape[i]);\n  }\n\n  const strides = [...computeStrides(tensor.shape).map(stride => stride / sliceSize), 1].slice(0, sliceRank);\n  return [resultShape, nResult, sliceSize, strides];\n}","map":{"version":3,"names":["computeStrides","sizeFromShape","prepareAndValidate","tensor","indices","tensorRank","shape","length","indicesRank","Error","dtype","indicesShape","sliceRank","nResult","i","inputShape","resultShape","slice","pop","sliceSize","push","strides","map","stride"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-core/dist/ops/gather_nd_util.js"],"sourcesContent":["import { computeStrides, sizeFromShape } from '../util';\n/**\n * Validate gather nd inputs.\n *\n * @param tensor The tensor contains the source values.\n * @param indices The tensor contains the indices to slice the source.\n *\n * @returns [resultShape, numUpdates, sliceSize, strides]\n */\nexport function prepareAndValidate(tensor, indices) {\n    const tensorRank = tensor.shape.length;\n    const indicesRank = indices.shape.length;\n    if (tensorRank < 1) {\n        throw new Error('tf.gatherND() expects the input to be rank 1 or higher,' +\n            ` but the rank was ${tensorRank}.`);\n    }\n    if (indicesRank < 1) {\n        throw new Error('tf.gatherND() expects the indices to be rank 1 or higher,' +\n            ` but the rank was ${indicesRank}.`);\n    }\n    if (indices.dtype !== 'int32') {\n        throw new Error('tf.gatherND() expects the indices to be int32 type,' +\n            ` but the dtype was ${indices.dtype}.`);\n    }\n    if (indices.shape[indicesRank - 1] > tensorRank) {\n        throw new Error('index innermost dimension length must be <= tensor rank; saw: ' +\n            `${indices.shape[indicesRank - 1]} vs. ${tensorRank}`);\n    }\n    if (sizeFromShape(tensor.shape) === 0) {\n        throw new Error('Requested more than 0 entries, but input is empty.' +\n            ` Input shape: ${tensor.shape}.`);\n    }\n    const indicesShape = indices.shape;\n    const sliceRank = indicesShape[indicesShape.length - 1];\n    // The result shape is\n    //   indices.shape[:-1] + params.shape[indices.shape[-1]:]\n    let nResult = 1;\n    for (let i = 0; i < indicesShape.length - 1; ++i) {\n        nResult *= indicesShape[i];\n    }\n    const inputShape = tensor.shape;\n    const resultShape = indicesShape.slice();\n    resultShape.pop();\n    let sliceSize = 1;\n    for (let i = sliceRank; i < tensorRank; ++i) {\n        sliceSize *= inputShape[i];\n        resultShape.push(inputShape[i]);\n    }\n    const strides = [...computeStrides(tensor.shape).map(stride => stride / sliceSize),\n        1].slice(0, sliceRank);\n    return [resultShape, nResult, sliceSize, strides];\n}\n"],"mappings":"AAAA,SAASA,cAAT,EAAyBC,aAAzB,QAA8C,SAA9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,kBAAT,CAA4BC,MAA5B,EAAoCC,OAApC,EAA6C;EAChD,MAAMC,UAAU,GAAGF,MAAM,CAACG,KAAP,CAAaC,MAAhC;EACA,MAAMC,WAAW,GAAGJ,OAAO,CAACE,KAAR,CAAcC,MAAlC;;EACA,IAAIF,UAAU,GAAG,CAAjB,EAAoB;IAChB,MAAM,IAAII,KAAJ,CAAU,4DACX,qBAAoBJ,UAAW,GAD9B,CAAN;EAEH;;EACD,IAAIG,WAAW,GAAG,CAAlB,EAAqB;IACjB,MAAM,IAAIC,KAAJ,CAAU,8DACX,qBAAoBD,WAAY,GAD/B,CAAN;EAEH;;EACD,IAAIJ,OAAO,CAACM,KAAR,KAAkB,OAAtB,EAA+B;IAC3B,MAAM,IAAID,KAAJ,CAAU,wDACX,sBAAqBL,OAAO,CAACM,KAAM,GADlC,CAAN;EAEH;;EACD,IAAIN,OAAO,CAACE,KAAR,CAAcE,WAAW,GAAG,CAA5B,IAAiCH,UAArC,EAAiD;IAC7C,MAAM,IAAII,KAAJ,CAAU,mEACX,GAAEL,OAAO,CAACE,KAAR,CAAcE,WAAW,GAAG,CAA5B,CAA+B,QAAOH,UAAW,EADlD,CAAN;EAEH;;EACD,IAAIJ,aAAa,CAACE,MAAM,CAACG,KAAR,CAAb,KAAgC,CAApC,EAAuC;IACnC,MAAM,IAAIG,KAAJ,CAAU,uDACX,iBAAgBN,MAAM,CAACG,KAAM,GAD5B,CAAN;EAEH;;EACD,MAAMK,YAAY,GAAGP,OAAO,CAACE,KAA7B;EACA,MAAMM,SAAS,GAAGD,YAAY,CAACA,YAAY,CAACJ,MAAb,GAAsB,CAAvB,CAA9B,CAxBgD,CAyBhD;EACA;;EACA,IAAIM,OAAO,GAAG,CAAd;;EACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,YAAY,CAACJ,MAAb,GAAsB,CAA1C,EAA6C,EAAEO,CAA/C,EAAkD;IAC9CD,OAAO,IAAIF,YAAY,CAACG,CAAD,CAAvB;EACH;;EACD,MAAMC,UAAU,GAAGZ,MAAM,CAACG,KAA1B;EACA,MAAMU,WAAW,GAAGL,YAAY,CAACM,KAAb,EAApB;EACAD,WAAW,CAACE,GAAZ;EACA,IAAIC,SAAS,GAAG,CAAhB;;EACA,KAAK,IAAIL,CAAC,GAAGF,SAAb,EAAwBE,CAAC,GAAGT,UAA5B,EAAwC,EAAES,CAA1C,EAA6C;IACzCK,SAAS,IAAIJ,UAAU,CAACD,CAAD,CAAvB;IACAE,WAAW,CAACI,IAAZ,CAAiBL,UAAU,CAACD,CAAD,CAA3B;EACH;;EACD,MAAMO,OAAO,GAAG,CAAC,GAAGrB,cAAc,CAACG,MAAM,CAACG,KAAR,CAAd,CAA6BgB,GAA7B,CAAiCC,MAAM,IAAIA,MAAM,GAAGJ,SAApD,CAAJ,EACZ,CADY,EACTF,KADS,CACH,CADG,EACAL,SADA,CAAhB;EAEA,OAAO,CAACI,WAAD,EAAcH,OAAd,EAAuBM,SAAvB,EAAkCE,OAAlC,CAAP;AACH"},"metadata":{},"sourceType":"module"}