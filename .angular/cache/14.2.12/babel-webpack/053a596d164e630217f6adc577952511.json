{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, env, util } from '@tensorflow/tfjs-core';\nimport * as shader_compiler from './shader_compiler';\nimport { createFragmentShader } from './webgl_util';\nexport function compileProgram(gpgpu, program, inputs, output) {\n  const inputInfos = inputs.map((input, i) => {\n    const shapeInfo = {\n      logicalShape: input.shape,\n      texShape: input.isUniform ? null : input.texData.texShape,\n      isUniform: input.isUniform,\n      isPacked: input.isUniform ? false : input.texData.isPacked,\n      flatOffset: null\n    };\n\n    if (input.texData != null && input.texData.slice != null && input.texData.slice.flatOffset > 0) {\n      shapeInfo.flatOffset = input.texData.slice.flatOffset;\n    }\n\n    return {\n      name: program.variableNames[i],\n      shapeInfo\n    };\n  });\n  const inShapeInfos = inputInfos.map(x => x.shapeInfo);\n  const outShapeInfo = {\n    logicalShape: output.shape,\n    texShape: output.texData.texShape,\n    isUniform: false,\n    isPacked: output.texData.isPacked,\n    flatOffset: null\n  };\n  const source = shader_compiler.makeShader(inputInfos, outShapeInfo, program);\n  const fragmentShader = createFragmentShader(gpgpu.gl, source);\n  const webGLProgram = gpgpu.createProgram(fragmentShader);\n\n  if (!env().get('ENGINE_COMPILE_ONLY')) {\n    return Object.assign({\n      program,\n      fragmentShader,\n      source,\n      webGLProgram,\n      inShapeInfos,\n      outShapeInfo\n    }, getUniformLocations(gpgpu, program, webGLProgram));\n  } else {\n    return {\n      program,\n      fragmentShader,\n      source,\n      webGLProgram,\n      inShapeInfos,\n      outShapeInfo,\n      uniformLocations: null,\n      customUniformLocations: null,\n      infLoc: null,\n      nanLoc: null,\n      inShapesLocations: null,\n      inTexShapesLocations: null,\n      outShapeLocation: null,\n      outShapeStridesLocation: null,\n      outTexShapeLocation: null\n    };\n  }\n}\nexport function getUniformLocations(gpgpu, program, webGLProgram) {\n  const uniformLocations = {};\n  const inShapesLocations = {};\n  const inTexShapesLocations = {};\n  const customUniformLocations = [];\n  let outShapeLocation;\n  let outTexShapeLocation;\n  let outShapeStridesLocation;\n  let infLoc = null;\n  let nanLoc = null; // Add special uniforms (NAN, INFINITY)\n\n  nanLoc = gpgpu.getUniformLocation(webGLProgram, 'NAN', false);\n\n  if (env().getNumber('WEBGL_VERSION') === 1) {\n    infLoc = gpgpu.getUniformLocation(webGLProgram, 'INFINITY', false);\n  } // Add user-defined uniforms\n\n\n  const shouldThrow = false;\n\n  for (let i = 0; i < program.variableNames.length; i++) {\n    const varName = program.variableNames[i];\n    uniformLocations[varName] = gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow);\n    uniformLocations[`offset${varName}`] = gpgpu.getUniformLocation(webGLProgram, `offset${varName}`, shouldThrow);\n\n    if (program.enableShapeUniforms) {\n      inShapesLocations[`${varName}Shape`] = gpgpu.getUniformLocation(webGLProgram, `${varName}Shape`, shouldThrow);\n      inTexShapesLocations[`${varName}TexShape`] = gpgpu.getUniformLocation(webGLProgram, `${varName}TexShape`, shouldThrow);\n    }\n  }\n\n  if (program.enableShapeUniforms) {\n    outShapeLocation = gpgpu.getUniformLocation(webGLProgram, 'outShape', shouldThrow);\n    outShapeStridesLocation = gpgpu.getUniformLocation(webGLProgram, 'outShapeStrides', shouldThrow);\n    outTexShapeLocation = gpgpu.getUniformLocation(webGLProgram, 'outTexShape', shouldThrow);\n  }\n\n  if (program.customUniforms) {\n    program.customUniforms.forEach((d, i) => {\n      customUniformLocations[i] = gpgpu.getUniformLocation(webGLProgram, d.name, shouldThrow);\n    });\n  }\n\n  return {\n    uniformLocations,\n    customUniformLocations,\n    infLoc,\n    nanLoc,\n    inShapesLocations,\n    inTexShapesLocations,\n    outShapeLocation,\n    outShapeStridesLocation,\n    outTexShapeLocation\n  };\n}\n\nfunction validateBinaryAndProgram(shapeInfos, inputs) {\n  if (shapeInfos.length !== inputs.length) {\n    throw Error(`Binary was compiled with ${shapeInfos.length} inputs, but ` + `was executed with ${inputs.length} inputs`);\n  }\n\n  shapeInfos.forEach((s, i) => {\n    const shapeA = s.logicalShape;\n    const input = inputs[i];\n    const shapeB = input.shape;\n\n    if (!util.arraysEqual(shapeA, shapeB)) {\n      throw Error(`Binary was compiled with different shapes than ` + `the current args. Shapes ${shapeA} and ${shapeB} must match`);\n    } // The input is uploaded as uniform.\n\n\n    if (s.isUniform && input.isUniform) {\n      return;\n    }\n\n    const texShapeA = s.texShape;\n    const texShapeB = input.isUniform ? null : input.texData.texShape;\n\n    if (!util.arraysEqual(texShapeA, texShapeB)) {\n      throw Error(`Binary was compiled with different texture shapes than the` + ` current args. Shape ${texShapeA} and ${texShapeB} must match`);\n    }\n  });\n}\n\nexport function runProgram(gpgpu, binary, inputs, output, customUniformValues) {\n  if (!binary.program.enableShapeUniforms) {\n    validateBinaryAndProgram(binary.inShapeInfos, inputs);\n    validateBinaryAndProgram([binary.outShapeInfo], [output]);\n  }\n\n  const outTex = output.texData.texture;\n  const outTexShape = output.texData.texShape;\n\n  if (output.texData.isPacked) {\n    gpgpu.setOutputPackedMatrixTexture(outTex.texture, outTexShape[0], outTexShape[1]);\n  } else {\n    gpgpu.setOutputMatrixTexture(outTex.texture, outTexShape[0], outTexShape[1]);\n  }\n\n  gpgpu.setProgram(binary.webGLProgram); // Set special uniforms (NAN, INFINITY)\n\n  if (env().getNumber('WEBGL_VERSION') === 1) {\n    if (binary.infLoc !== null) {\n      gpgpu.gl.uniform1f(binary.infLoc, Infinity);\n    }\n  }\n\n  if (binary.nanLoc !== null) {\n    gpgpu.gl.uniform1f(binary.nanLoc, NaN);\n  } // Set user-defined inputs\n\n\n  inputs.forEach((input, i) => {\n    const varName = binary.program.variableNames[i];\n    const varLoc = binary.uniformLocations[varName];\n    const varOffsetLoc = binary.uniformLocations[`offset${varName}`];\n    const varShapeLoc = binary.inShapesLocations[`${varName}Shape`];\n    const varTexShapeLoc = binary.inTexShapesLocations[`${varName}TexShape`];\n\n    if (varShapeLoc) {\n      const {\n        uniformShape\n      } = shader_compiler.getUniformInfoFromShape(binary.program.packedInputs, input.shape, input.texData.texShape);\n\n      switch (uniformShape.length) {\n        case 1:\n          gpgpu.gl.uniform1iv(varShapeLoc, new Int32Array(uniformShape));\n          break;\n\n        case 2:\n          gpgpu.gl.uniform2iv(varShapeLoc, new Int32Array(uniformShape));\n          break;\n\n        case 3:\n          gpgpu.gl.uniform3iv(varShapeLoc, new Int32Array(uniformShape));\n          break;\n\n        case 4:\n          gpgpu.gl.uniform4iv(varShapeLoc, new Int32Array(uniformShape));\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    if (varTexShapeLoc) {\n      gpgpu.gl.uniform2i(varTexShapeLoc, input.texData.texShape[0], input.texData.texShape[1]);\n    }\n\n    if (varLoc == null) {\n      // The compiler inferred that this variable is not used in this shader.\n      return;\n    }\n\n    if (input.isUniform) {\n      // Upload the values of the tensor as uniform.\n      if (util.sizeFromShape(input.shape) < 2) {\n        gpgpu.gl.uniform1f(varLoc, input.uniformValues[0]);\n      } else {\n        let vals = input.uniformValues;\n\n        if (!(vals instanceof Float32Array)) {\n          vals = new Float32Array(vals);\n        }\n\n        gpgpu.gl.uniform1fv(varLoc, vals);\n      }\n\n      return;\n    } // If the input was sliced, upload the flat offset index.\n\n\n    if (input.texData.slice != null && varOffsetLoc != null) {\n      gpgpu.gl.uniform1i(varOffsetLoc, input.texData.slice.flatOffset);\n    }\n\n    gpgpu.setInputMatrixTexture(input.texData.texture.texture, varLoc, i);\n  });\n  const outShapeLoc = binary.outShapeLocation;\n\n  if (outShapeLoc) {\n    switch (output.shape.length) {\n      case 1:\n        gpgpu.gl.uniform1iv(outShapeLoc, new Int32Array(output.shape));\n        break;\n\n      case 2:\n        gpgpu.gl.uniform2iv(outShapeLoc, new Int32Array(output.shape));\n        break;\n\n      case 3:\n        gpgpu.gl.uniform3iv(outShapeLoc, new Int32Array(output.shape));\n        break;\n\n      case 4:\n        gpgpu.gl.uniform4iv(outShapeLoc, new Int32Array(output.shape));\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  if (binary.outShapeStridesLocation) {\n    const strides = util.computeStrides(output.shape);\n\n    switch (output.shape.length) {\n      case 2:\n        gpgpu.gl.uniform1iv(binary.outShapeStridesLocation, new Int32Array(strides));\n        break;\n\n      case 3:\n        gpgpu.gl.uniform2iv(binary.outShapeStridesLocation, new Int32Array(strides));\n        break;\n\n      case 4:\n        gpgpu.gl.uniform3iv(binary.outShapeStridesLocation, new Int32Array(strides));\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  if (binary.outTexShapeLocation) {\n    gpgpu.gl.uniform2i(binary.outTexShapeLocation, output.texData.texShape[0], output.texData.texShape[1]);\n  }\n\n  if (binary.program.customUniforms && customUniformValues) {\n    binary.program.customUniforms.forEach((d, i) => {\n      const customLoc = binary.customUniformLocations[i];\n      const customValue = customUniformValues[i];\n\n      if (d.type === 'float') {\n        gpgpu.gl.uniform1fv(customLoc, customValue);\n      } else if (d.type === 'vec2') {\n        gpgpu.gl.uniform2fv(customLoc, customValue);\n      } else if (d.type === 'vec3') {\n        gpgpu.gl.uniform3fv(customLoc, customValue);\n      } else if (d.type === 'vec4') {\n        gpgpu.gl.uniform4fv(customLoc, customValue);\n      } else if (d.type === 'int') {\n        gpgpu.gl.uniform1iv(customLoc, customValue);\n      } else if (d.type === 'ivec2') {\n        gpgpu.gl.uniform2iv(customLoc, customValue);\n      } else if (d.type === 'ivec3') {\n        gpgpu.gl.uniform3iv(customLoc, customValue);\n      } else if (d.type === 'ivec4') {\n        gpgpu.gl.uniform4iv(customLoc, customValue);\n      } else {\n        throw Error(`uniform type ${d.type} is not supported yet.`);\n      }\n    });\n  }\n\n  gpgpu.executeProgram();\n}\nexport function makeShaderKey(program, inputs, output) {\n  let keyInputs = '';\n  inputs.concat(output).forEach(x => {\n    const hasOffset = x.texData != null && x.texData.slice != null && x.texData.slice.flatOffset > 0; // TODO: Remove the condition of !x.isUniform.\n\n    if (program.enableShapeUniforms && !x.isUniform) {\n      const xTexShape = x.texData.texShape;\n      const {\n        useSqueezeShape,\n        uniformShape,\n        keptDims\n      } = shader_compiler.getUniformInfoFromShape(program.packedInputs, x.shape, xTexShape);\n      let rank1 = '',\n          rank2 = '',\n          rank34 = '';\n\n      if (uniformShape.length === 1 && program.packedInputs) {\n        const packedTexShape = [Math.ceil(xTexShape[0] / 2), Math.ceil(xTexShape[1] / 2)];\n        rank1 = `${packedTexShape[0] > 1}_${packedTexShape[1] > 1}`;\n      } else if (uniformShape.length === 2 && !program.packedInputs) {\n        rank2 = `${uniformShape[0] > 1}_${uniformShape[1] > 1}`;\n      } else if (uniformShape.length > 2 && !program.packedInputs) {\n        const strides = util.computeStrides(uniformShape);\n        rank34 = `${strides[0] === xTexShape[1]}_${strides[strides.length - 1] === xTexShape[1]}`;\n      }\n\n      const xRank = x.shape.length;\n      const isLogicalShapTexShapeEqual = uniformShape.length === 2 && util.arraysEqual(x.shape, xTexShape);\n      const isScalar = util.sizeFromShape(x.shape) === 1;\n      const broadcastDims = backend_util.getBroadcastDims(x.shape, output.shape);\n      const isInOutTexShapeEqual = !program.packedInputs && xRank === output.shape.length && util.arraysEqual(xTexShape, output.texData.texShape);\n      const isTexShapeGreaterThanOne = program.packedInputs || uniformShape.length > 2 ? '' : `${xTexShape[0] > 1}_${xTexShape[1] > 1}`; // These key components are needed due to shader_compiler is embedding\n      // them in the shader.\n      // |xRank| is used to determine the coords length. See\n      // get[Packed]SamplerAtOutputCoords.\n      // |isInOutTexShapeEqual| is used to determine whether going to an\n      // optimization path in getSamplerAtOutputCoords.\n      // |useSqueezeShape| is extracted from squeezeInputInfo of\n      // getSampler[2|3|4]D/getPackedSampler3D.\n      // |isScalar| is extracted from isInputScalar/isOutputScalar in\n      // getPackedSamplerAtOutputCoords.\n      // |broadcastDims| is extracted from get[Packed]SamplerAtOutputCoords.\n      // |isLogicalShapTexShapeEqual| is used in\n      // getOutput[Packed]2DCoords/get[Packed]Sampler2D.\n      // |rank1| is used in getOutputPacked1DCoords.\n      // |rank2| is used in getOutput2DCoords.\n      // |rank34| is used in getSampler3D/getSampler4D.\n      // |isTexShapeGreaterThanOne| are used in\n      // getSampler[Scalar|1D|2D]/getOutput1DCoords.\n\n      keyInputs += `${xRank}_${isInOutTexShapeEqual}_${useSqueezeShape ? keptDims : ''}_${uniformShape.length}_${isScalar}_${broadcastDims}_${isLogicalShapTexShapeEqual}_${rank1}_${rank2}_${rank34}_${isTexShapeGreaterThanOne}_${hasOffset}`;\n    } else {\n      const texShape = x.isUniform ? 'uniform' : x.texData.texShape;\n      keyInputs += `${x.shape}_${texShape}_${hasOffset}`;\n    }\n  });\n  const keyUserCode = program.userCode;\n  let key = program.constructor.name; // Fast string concat. See https://jsperf.com/string-concatenation/14.\n\n  key += '_' + keyInputs + '_' + keyUserCode + `${env().getNumber('WEBGL_VERSION')}`;\n  return key;\n}\nexport function useShapeUniforms(rank) {\n  // TODO: Remove the limitaion of rank <= 4.\n  return env().getBool('WEBGL_USE_SHAPES_UNIFORMS') && rank <= 4;\n}","map":{"version":3,"names":["backend_util","env","util","shader_compiler","createFragmentShader","compileProgram","gpgpu","program","inputs","output","inputInfos","map","input","i","shapeInfo","logicalShape","shape","texShape","isUniform","texData","isPacked","flatOffset","slice","name","variableNames","inShapeInfos","x","outShapeInfo","source","makeShader","fragmentShader","gl","webGLProgram","createProgram","get","Object","assign","getUniformLocations","uniformLocations","customUniformLocations","infLoc","nanLoc","inShapesLocations","inTexShapesLocations","outShapeLocation","outShapeStridesLocation","outTexShapeLocation","getUniformLocation","getNumber","shouldThrow","length","varName","enableShapeUniforms","customUniforms","forEach","d","validateBinaryAndProgram","shapeInfos","Error","s","shapeA","shapeB","arraysEqual","texShapeA","texShapeB","runProgram","binary","customUniformValues","outTex","texture","outTexShape","setOutputPackedMatrixTexture","setOutputMatrixTexture","setProgram","uniform1f","Infinity","NaN","varLoc","varOffsetLoc","varShapeLoc","varTexShapeLoc","uniformShape","getUniformInfoFromShape","packedInputs","uniform1iv","Int32Array","uniform2iv","uniform3iv","uniform4iv","uniform2i","sizeFromShape","uniformValues","vals","Float32Array","uniform1fv","uniform1i","setInputMatrixTexture","outShapeLoc","strides","computeStrides","customLoc","customValue","type","uniform2fv","uniform3fv","uniform4fv","executeProgram","makeShaderKey","keyInputs","concat","hasOffset","xTexShape","useSqueezeShape","keptDims","rank1","rank2","rank34","packedTexShape","Math","ceil","xRank","isLogicalShapTexShapeEqual","isScalar","broadcastDims","getBroadcastDims","isInOutTexShapeEqual","isTexShapeGreaterThanOne","keyUserCode","userCode","key","constructor","useShapeUniforms","rank","getBool"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_math.js"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, env, util } from '@tensorflow/tfjs-core';\nimport * as shader_compiler from './shader_compiler';\nimport { createFragmentShader } from './webgl_util';\nexport function compileProgram(gpgpu, program, inputs, output) {\n    const inputInfos = inputs.map((input, i) => {\n        const shapeInfo = {\n            logicalShape: input.shape,\n            texShape: input.isUniform ? null : input.texData.texShape,\n            isUniform: input.isUniform,\n            isPacked: input.isUniform ? false : input.texData.isPacked,\n            flatOffset: null\n        };\n        if (input.texData != null && input.texData.slice != null &&\n            input.texData.slice.flatOffset > 0) {\n            shapeInfo.flatOffset = input.texData.slice.flatOffset;\n        }\n        return { name: program.variableNames[i], shapeInfo };\n    });\n    const inShapeInfos = inputInfos.map(x => x.shapeInfo);\n    const outShapeInfo = {\n        logicalShape: output.shape,\n        texShape: output.texData.texShape,\n        isUniform: false,\n        isPacked: output.texData.isPacked,\n        flatOffset: null\n    };\n    const source = shader_compiler.makeShader(inputInfos, outShapeInfo, program);\n    const fragmentShader = createFragmentShader(gpgpu.gl, source);\n    const webGLProgram = gpgpu.createProgram(fragmentShader);\n    if (!env().get('ENGINE_COMPILE_ONLY')) {\n        return Object.assign({ program,\n            fragmentShader,\n            source,\n            webGLProgram,\n            inShapeInfos,\n            outShapeInfo }, getUniformLocations(gpgpu, program, webGLProgram));\n    }\n    else {\n        return {\n            program,\n            fragmentShader,\n            source,\n            webGLProgram,\n            inShapeInfos,\n            outShapeInfo,\n            uniformLocations: null,\n            customUniformLocations: null,\n            infLoc: null,\n            nanLoc: null,\n            inShapesLocations: null,\n            inTexShapesLocations: null,\n            outShapeLocation: null,\n            outShapeStridesLocation: null,\n            outTexShapeLocation: null\n        };\n    }\n}\nexport function getUniformLocations(gpgpu, program, webGLProgram) {\n    const uniformLocations = {};\n    const inShapesLocations = {};\n    const inTexShapesLocations = {};\n    const customUniformLocations = [];\n    let outShapeLocation;\n    let outTexShapeLocation;\n    let outShapeStridesLocation;\n    let infLoc = null;\n    let nanLoc = null;\n    // Add special uniforms (NAN, INFINITY)\n    nanLoc = gpgpu.getUniformLocation(webGLProgram, 'NAN', false);\n    if (env().getNumber('WEBGL_VERSION') === 1) {\n        infLoc = gpgpu.getUniformLocation(webGLProgram, 'INFINITY', false);\n    }\n    // Add user-defined uniforms\n    const shouldThrow = false;\n    for (let i = 0; i < program.variableNames.length; i++) {\n        const varName = program.variableNames[i];\n        uniformLocations[varName] =\n            gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow);\n        uniformLocations[`offset${varName}`] =\n            gpgpu.getUniformLocation(webGLProgram, `offset${varName}`, shouldThrow);\n        if (program.enableShapeUniforms) {\n            inShapesLocations[`${varName}Shape`] = gpgpu.getUniformLocation(webGLProgram, `${varName}Shape`, shouldThrow);\n            inTexShapesLocations[`${varName}TexShape`] = gpgpu.getUniformLocation(webGLProgram, `${varName}TexShape`, shouldThrow);\n        }\n    }\n    if (program.enableShapeUniforms) {\n        outShapeLocation =\n            gpgpu.getUniformLocation(webGLProgram, 'outShape', shouldThrow);\n        outShapeStridesLocation =\n            gpgpu.getUniformLocation(webGLProgram, 'outShapeStrides', shouldThrow);\n        outTexShapeLocation =\n            gpgpu.getUniformLocation(webGLProgram, 'outTexShape', shouldThrow);\n    }\n    if (program.customUniforms) {\n        program.customUniforms.forEach((d, i) => {\n            customUniformLocations[i] =\n                gpgpu.getUniformLocation(webGLProgram, d.name, shouldThrow);\n        });\n    }\n    return {\n        uniformLocations,\n        customUniformLocations,\n        infLoc,\n        nanLoc,\n        inShapesLocations,\n        inTexShapesLocations,\n        outShapeLocation,\n        outShapeStridesLocation,\n        outTexShapeLocation\n    };\n}\nfunction validateBinaryAndProgram(shapeInfos, inputs) {\n    if (shapeInfos.length !== inputs.length) {\n        throw Error(`Binary was compiled with ${shapeInfos.length} inputs, but ` +\n            `was executed with ${inputs.length} inputs`);\n    }\n    shapeInfos.forEach((s, i) => {\n        const shapeA = s.logicalShape;\n        const input = inputs[i];\n        const shapeB = input.shape;\n        if (!util.arraysEqual(shapeA, shapeB)) {\n            throw Error(`Binary was compiled with different shapes than ` +\n                `the current args. Shapes ${shapeA} and ${shapeB} must match`);\n        }\n        // The input is uploaded as uniform.\n        if (s.isUniform && input.isUniform) {\n            return;\n        }\n        const texShapeA = s.texShape;\n        const texShapeB = input.isUniform ? null : input.texData.texShape;\n        if (!util.arraysEqual(texShapeA, texShapeB)) {\n            throw Error(`Binary was compiled with different texture shapes than the` +\n                ` current args. Shape ${texShapeA} and ${texShapeB} must match`);\n        }\n    });\n}\nexport function runProgram(gpgpu, binary, inputs, output, customUniformValues) {\n    if (!binary.program.enableShapeUniforms) {\n        validateBinaryAndProgram(binary.inShapeInfos, inputs);\n        validateBinaryAndProgram([binary.outShapeInfo], [output]);\n    }\n    const outTex = output.texData.texture;\n    const outTexShape = output.texData.texShape;\n    if (output.texData.isPacked) {\n        gpgpu.setOutputPackedMatrixTexture(outTex.texture, outTexShape[0], outTexShape[1]);\n    }\n    else {\n        gpgpu.setOutputMatrixTexture(outTex.texture, outTexShape[0], outTexShape[1]);\n    }\n    gpgpu.setProgram(binary.webGLProgram);\n    // Set special uniforms (NAN, INFINITY)\n    if (env().getNumber('WEBGL_VERSION') === 1) {\n        if (binary.infLoc !== null) {\n            gpgpu.gl.uniform1f(binary.infLoc, Infinity);\n        }\n    }\n    if (binary.nanLoc !== null) {\n        gpgpu.gl.uniform1f(binary.nanLoc, NaN);\n    }\n    // Set user-defined inputs\n    inputs.forEach((input, i) => {\n        const varName = binary.program.variableNames[i];\n        const varLoc = binary.uniformLocations[varName];\n        const varOffsetLoc = binary.uniformLocations[`offset${varName}`];\n        const varShapeLoc = binary.inShapesLocations[`${varName}Shape`];\n        const varTexShapeLoc = binary.inTexShapesLocations[`${varName}TexShape`];\n        if (varShapeLoc) {\n            const { uniformShape } = shader_compiler.getUniformInfoFromShape(binary.program.packedInputs, input.shape, input.texData.texShape);\n            switch (uniformShape.length) {\n                case 1:\n                    gpgpu.gl.uniform1iv(varShapeLoc, new Int32Array(uniformShape));\n                    break;\n                case 2:\n                    gpgpu.gl.uniform2iv(varShapeLoc, new Int32Array(uniformShape));\n                    break;\n                case 3:\n                    gpgpu.gl.uniform3iv(varShapeLoc, new Int32Array(uniformShape));\n                    break;\n                case 4:\n                    gpgpu.gl.uniform4iv(varShapeLoc, new Int32Array(uniformShape));\n                    break;\n                default:\n                    break;\n            }\n        }\n        if (varTexShapeLoc) {\n            gpgpu.gl.uniform2i(varTexShapeLoc, input.texData.texShape[0], input.texData.texShape[1]);\n        }\n        if (varLoc == null) {\n            // The compiler inferred that this variable is not used in this shader.\n            return;\n        }\n        if (input.isUniform) {\n            // Upload the values of the tensor as uniform.\n            if (util.sizeFromShape(input.shape) < 2) {\n                gpgpu.gl.uniform1f(varLoc, input.uniformValues[0]);\n            }\n            else {\n                let vals = input.uniformValues;\n                if (!(vals instanceof Float32Array)) {\n                    vals = new Float32Array(vals);\n                }\n                gpgpu.gl.uniform1fv(varLoc, vals);\n            }\n            return;\n        }\n        // If the input was sliced, upload the flat offset index.\n        if (input.texData.slice != null && varOffsetLoc != null) {\n            gpgpu.gl.uniform1i(varOffsetLoc, input.texData.slice.flatOffset);\n        }\n        gpgpu.setInputMatrixTexture(input.texData.texture.texture, varLoc, i);\n    });\n    const outShapeLoc = binary.outShapeLocation;\n    if (outShapeLoc) {\n        switch (output.shape.length) {\n            case 1:\n                gpgpu.gl.uniform1iv(outShapeLoc, new Int32Array(output.shape));\n                break;\n            case 2:\n                gpgpu.gl.uniform2iv(outShapeLoc, new Int32Array(output.shape));\n                break;\n            case 3:\n                gpgpu.gl.uniform3iv(outShapeLoc, new Int32Array(output.shape));\n                break;\n            case 4:\n                gpgpu.gl.uniform4iv(outShapeLoc, new Int32Array(output.shape));\n                break;\n            default:\n                break;\n        }\n    }\n    if (binary.outShapeStridesLocation) {\n        const strides = util.computeStrides(output.shape);\n        switch (output.shape.length) {\n            case 2:\n                gpgpu.gl.uniform1iv(binary.outShapeStridesLocation, new Int32Array(strides));\n                break;\n            case 3:\n                gpgpu.gl.uniform2iv(binary.outShapeStridesLocation, new Int32Array(strides));\n                break;\n            case 4:\n                gpgpu.gl.uniform3iv(binary.outShapeStridesLocation, new Int32Array(strides));\n                break;\n            default:\n                break;\n        }\n    }\n    if (binary.outTexShapeLocation) {\n        gpgpu.gl.uniform2i(binary.outTexShapeLocation, output.texData.texShape[0], output.texData.texShape[1]);\n    }\n    if (binary.program.customUniforms && customUniformValues) {\n        binary.program.customUniforms.forEach((d, i) => {\n            const customLoc = binary.customUniformLocations[i];\n            const customValue = customUniformValues[i];\n            if (d.type === 'float') {\n                gpgpu.gl.uniform1fv(customLoc, customValue);\n            }\n            else if (d.type === 'vec2') {\n                gpgpu.gl.uniform2fv(customLoc, customValue);\n            }\n            else if (d.type === 'vec3') {\n                gpgpu.gl.uniform3fv(customLoc, customValue);\n            }\n            else if (d.type === 'vec4') {\n                gpgpu.gl.uniform4fv(customLoc, customValue);\n            }\n            else if (d.type === 'int') {\n                gpgpu.gl.uniform1iv(customLoc, customValue);\n            }\n            else if (d.type === 'ivec2') {\n                gpgpu.gl.uniform2iv(customLoc, customValue);\n            }\n            else if (d.type === 'ivec3') {\n                gpgpu.gl.uniform3iv(customLoc, customValue);\n            }\n            else if (d.type === 'ivec4') {\n                gpgpu.gl.uniform4iv(customLoc, customValue);\n            }\n            else {\n                throw Error(`uniform type ${d.type} is not supported yet.`);\n            }\n        });\n    }\n    gpgpu.executeProgram();\n}\nexport function makeShaderKey(program, inputs, output) {\n    let keyInputs = '';\n    inputs.concat(output).forEach(x => {\n        const hasOffset = x.texData != null && x.texData.slice != null &&\n            x.texData.slice.flatOffset > 0;\n        // TODO: Remove the condition of !x.isUniform.\n        if (program.enableShapeUniforms && !x.isUniform) {\n            const xTexShape = x.texData.texShape;\n            const { useSqueezeShape, uniformShape, keptDims } = shader_compiler.getUniformInfoFromShape(program.packedInputs, x.shape, xTexShape);\n            let rank1 = '', rank2 = '', rank34 = '';\n            if (uniformShape.length === 1 && program.packedInputs) {\n                const packedTexShape = [Math.ceil(xTexShape[0] / 2), Math.ceil(xTexShape[1] / 2)];\n                rank1 = `${packedTexShape[0] > 1}_${packedTexShape[1] > 1}`;\n            }\n            else if (uniformShape.length === 2 && !program.packedInputs) {\n                rank2 = `${uniformShape[0] > 1}_${uniformShape[1] > 1}`;\n            }\n            else if (uniformShape.length > 2 && !program.packedInputs) {\n                const strides = util.computeStrides(uniformShape);\n                rank34 = `${strides[0] === xTexShape[1]}_${strides[strides.length - 1] === xTexShape[1]}`;\n            }\n            const xRank = x.shape.length;\n            const isLogicalShapTexShapeEqual = uniformShape.length === 2 && util.arraysEqual(x.shape, xTexShape);\n            const isScalar = util.sizeFromShape(x.shape) === 1;\n            const broadcastDims = backend_util.getBroadcastDims(x.shape, output.shape);\n            const isInOutTexShapeEqual = !program.packedInputs &&\n                xRank === output.shape.length &&\n                util.arraysEqual(xTexShape, output.texData.texShape);\n            const isTexShapeGreaterThanOne = program.packedInputs || uniformShape.length > 2 ?\n                '' :\n                `${xTexShape[0] > 1}_${xTexShape[1] > 1}`;\n            // These key components are needed due to shader_compiler is embedding\n            // them in the shader.\n            // |xRank| is used to determine the coords length. See\n            // get[Packed]SamplerAtOutputCoords.\n            // |isInOutTexShapeEqual| is used to determine whether going to an\n            // optimization path in getSamplerAtOutputCoords.\n            // |useSqueezeShape| is extracted from squeezeInputInfo of\n            // getSampler[2|3|4]D/getPackedSampler3D.\n            // |isScalar| is extracted from isInputScalar/isOutputScalar in\n            // getPackedSamplerAtOutputCoords.\n            // |broadcastDims| is extracted from get[Packed]SamplerAtOutputCoords.\n            // |isLogicalShapTexShapeEqual| is used in\n            // getOutput[Packed]2DCoords/get[Packed]Sampler2D.\n            // |rank1| is used in getOutputPacked1DCoords.\n            // |rank2| is used in getOutput2DCoords.\n            // |rank34| is used in getSampler3D/getSampler4D.\n            // |isTexShapeGreaterThanOne| are used in\n            // getSampler[Scalar|1D|2D]/getOutput1DCoords.\n            keyInputs += `${xRank}_${isInOutTexShapeEqual}_${useSqueezeShape ? keptDims : ''}_${uniformShape.length}_${isScalar}_${broadcastDims}_${isLogicalShapTexShapeEqual}_${rank1}_${rank2}_${rank34}_${isTexShapeGreaterThanOne}_${hasOffset}`;\n        }\n        else {\n            const texShape = x.isUniform ? 'uniform' : x.texData.texShape;\n            keyInputs += `${x.shape}_${texShape}_${hasOffset}`;\n        }\n    });\n    const keyUserCode = program.userCode;\n    let key = program.constructor.name;\n    // Fast string concat. See https://jsperf.com/string-concatenation/14.\n    key += '_' + keyInputs + '_' + keyUserCode +\n        `${env().getNumber('WEBGL_VERSION')}`;\n    return key;\n}\nexport function useShapeUniforms(rank) {\n    // TODO: Remove the limitaion of rank <= 4.\n    return env().getBool('WEBGL_USE_SHAPES_UNIFORMS') && rank <= 4;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}