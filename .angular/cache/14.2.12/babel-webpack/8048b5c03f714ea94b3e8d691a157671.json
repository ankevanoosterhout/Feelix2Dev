{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeNearestNeighbor, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function resizeNearestNeighbor(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    images\n  } = inputs;\n  const {\n    alignCorners,\n    halfPixelCenters,\n    size\n  } = attrs;\n  assertNotComplex(images, 'resizeNearestNeighbor');\n  const imagesStrides = util.computeStrides(images.shape);\n  const [newHeight, newWidth] = size;\n  const [batch, oldHeight, oldWidth, numChannels] = images.shape;\n  const xValues = backend.data.get(images.dataId).values;\n  const output = new Float32Array(batch * newHeight * newWidth * numChannels);\n  const effectiveInputSize = [alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight, alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth];\n  const effectiveOutputSize = [alignCorners && newHeight > 1 ? newHeight - 1 : newHeight, alignCorners && newWidth > 1 ? newWidth - 1 : newWidth];\n  const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n  const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n  let outputOffset = 0;\n\n  for (let b = 0; b < batch; b++) {\n    const batchOffset = b * imagesStrides[0];\n\n    for (let r = 0; r < newHeight; r++) {\n      const sourceFracRow = halfPixelCenters ? effectiveRowSizeRatio * (r + 0.5) : effectiveRowSizeRatio * r;\n      let sourceNearestRow = Math.min(oldHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));\n\n      if (halfPixelCenters) {\n        sourceNearestRow = Math.max(0, sourceNearestRow);\n      }\n\n      const rowOffset = batchOffset + sourceNearestRow * imagesStrides[1];\n\n      for (let c = 0; c < newWidth; c++) {\n        const sourceFracCol = halfPixelCenters ? effectiveColSizeRatio * (c + 0.5) : effectiveColSizeRatio * c;\n        let sourceNearestCol = Math.min(oldWidth - 1, alignCorners ? Math.round(sourceFracCol) : Math.floor(sourceFracCol));\n\n        if (halfPixelCenters) {\n          sourceNearestCol = Math.max(0, sourceNearestCol);\n        }\n\n        const colOffset = rowOffset + sourceNearestCol * imagesStrides[2];\n\n        for (let d = 0; d < numChannels; d++) {\n          // Begin shader.\n          // Compute the fractional index of the source.\n          const newVal = xValues[colOffset + d];\n          output[outputOffset++] = newVal;\n        }\n      }\n    }\n  }\n\n  return backend.makeTensorInfo([batch, newHeight, newWidth, numChannels], images.dtype, output);\n}\nexport const resizeNearestNeighborConfig = {\n  kernelName: ResizeNearestNeighbor,\n  backendName: 'cpu',\n  kernelFunc: resizeNearestNeighbor\n};","map":{"version":3,"names":["ResizeNearestNeighbor","util","assertNotComplex","resizeNearestNeighbor","args","inputs","backend","attrs","images","alignCorners","halfPixelCenters","size","imagesStrides","computeStrides","shape","newHeight","newWidth","batch","oldHeight","oldWidth","numChannels","xValues","data","get","dataId","values","output","Float32Array","effectiveInputSize","effectiveOutputSize","effectiveRowSizeRatio","effectiveColSizeRatio","outputOffset","b","batchOffset","r","sourceFracRow","sourceNearestRow","Math","min","round","floor","max","rowOffset","c","sourceFracCol","sourceNearestCol","colOffset","d","newVal","makeTensorInfo","dtype","resizeNearestNeighborConfig","kernelName","backendName","kernelFunc"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ResizeNearestNeighbor.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeNearestNeighbor, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function resizeNearestNeighbor(args) {\n    const { inputs, backend, attrs } = args;\n    const { images } = inputs;\n    const { alignCorners, halfPixelCenters, size } = attrs;\n    assertNotComplex(images, 'resizeNearestNeighbor');\n    const imagesStrides = util.computeStrides(images.shape);\n    const [newHeight, newWidth] = size;\n    const [batch, oldHeight, oldWidth, numChannels] = images.shape;\n    const xValues = backend.data.get(images.dataId).values;\n    const output = new Float32Array(batch * newHeight * newWidth * numChannels);\n    const effectiveInputSize = [\n        (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n        (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n    ];\n    const effectiveOutputSize = [\n        (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n        (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n    ];\n    const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n    const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n    let outputOffset = 0;\n    for (let b = 0; b < batch; b++) {\n        const batchOffset = b * imagesStrides[0];\n        for (let r = 0; r < newHeight; r++) {\n            const sourceFracRow = halfPixelCenters ?\n                effectiveRowSizeRatio * (r + 0.5) :\n                effectiveRowSizeRatio * r;\n            let sourceNearestRow = Math.min(oldHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));\n            if (halfPixelCenters) {\n                sourceNearestRow = Math.max(0, sourceNearestRow);\n            }\n            const rowOffset = batchOffset + sourceNearestRow * imagesStrides[1];\n            for (let c = 0; c < newWidth; c++) {\n                const sourceFracCol = halfPixelCenters ?\n                    effectiveColSizeRatio * (c + 0.5) :\n                    effectiveColSizeRatio * c;\n                let sourceNearestCol = Math.min(oldWidth - 1, alignCorners ? Math.round(sourceFracCol) :\n                    Math.floor(sourceFracCol));\n                if (halfPixelCenters) {\n                    sourceNearestCol = Math.max(0, sourceNearestCol);\n                }\n                const colOffset = rowOffset + sourceNearestCol * imagesStrides[2];\n                for (let d = 0; d < numChannels; d++) {\n                    // Begin shader.\n                    // Compute the fractional index of the source.\n                    const newVal = xValues[colOffset + d];\n                    output[outputOffset++] = newVal;\n                }\n            }\n        }\n    }\n    return backend.makeTensorInfo([batch, newHeight, newWidth, numChannels], images.dtype, output);\n}\nexport const resizeNearestNeighborConfig = {\n    kernelName: ResizeNearestNeighbor,\n    backendName: 'cpu',\n    kernelFunc: resizeNearestNeighbor\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}