{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, Slice, slice_util, util } from '@tensorflow/tfjs-core';\nimport { sliceImplCPU } from '../kernel_utils/shared';\nimport { SliceProgram } from '../slice_gpu';\nimport { SlicePackedProgram } from '../slice_packed_gpu';\n\nfunction shallowSlice(x, begin, size, backend) {\n  const xTexData = backend.texData.get(x.dataId);\n  const t = backend.makeTensorInfo(size, x.dtype);\n  const newTexData = backend.texData.get(t.dataId); // Copy texture data from the original tensor.\n\n  Object.assign(newTexData, xTexData);\n  newTexData.refCount = 1;\n  newTexData.shape = size;\n  newTexData.dtype = x.dtype;\n  let flatOffset = slice_util.computeFlatOffset(begin, util.computeStrides(x.shape));\n\n  if (xTexData.slice) {\n    // We are slicing an already sliced tensor, so we have to accumulate\n    // the offset.\n    flatOffset += xTexData.slice.flatOffset;\n  }\n\n  newTexData.slice = {\n    flatOffset,\n    // Point to the original dataId, which is used to do ref counting.\n    origDataId: xTexData.slice && xTexData.slice.origDataId || x.dataId\n  }; // Increase the ref count for that data bucket.\n\n  const refCount = backend.dataRefCount.get(newTexData.slice.origDataId) || 1;\n  backend.dataRefCount.set(newTexData.slice.origDataId, refCount + 1);\n  return t;\n}\n\nexport function slice(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x\n  } = inputs;\n  const {\n    begin,\n    size\n  } = attrs;\n  const [$begin, $size] = slice_util.parseSliceParams(x, begin, size);\n  slice_util.assertParamsValid(x, $begin, $size);\n\n  if (util.sizeFromShape($size) === 0) {\n    return backend.makeTensorInfo($size, x.dtype, []);\n  } // Run on cpu if dtype is string. For string, the backend represents it\n  // as Uint8Array[], where each Uint8Array is a character. Given that the\n  // computation is only on the outer array, uploading the whole data onto\n  // gpu is wasteful. Also, currently webgl doesn't have a design to\n  // upload and retrieve Uint8Array[] between cpu and gpu. Therefore, we\n  // just run the kernel on cpu if dtype is string.\n\n\n  if (backend.shouldExecuteOnCPU([x]) || x.dtype === 'string') {\n    const xTexData = backend.texData.get(x.dataId);\n    const outValues = sliceImplCPU(xTexData.values, $begin, $size, x.shape, x.dtype);\n    return backend.makeTensorInfo($size, x.dtype, outValues);\n  }\n\n  const {\n    isPacked\n  } = backend.texData.get(x.dataId);\n  const isContinous = slice_util.isSliceContinous(x.shape, $begin, $size);\n\n  if (isPacked || !isContinous) {\n    const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ? new SlicePackedProgram($size) : new SliceProgram($size);\n    const customValues = [$begin];\n    return backend.runWebGLProgram(program, [x], x.dtype, customValues);\n  }\n\n  backend.uploadToGPU(x.dataId);\n  return shallowSlice(x, $begin, $size, backend);\n}\nexport const sliceConfig = {\n  kernelName: Slice,\n  backendName: 'webgl',\n  kernelFunc: slice\n};","map":{"version":3,"names":["env","Slice","slice_util","util","sliceImplCPU","SliceProgram","SlicePackedProgram","shallowSlice","x","begin","size","backend","xTexData","texData","get","dataId","t","makeTensorInfo","dtype","newTexData","Object","assign","refCount","shape","flatOffset","computeFlatOffset","computeStrides","slice","origDataId","dataRefCount","set","args","inputs","attrs","$begin","$size","parseSliceParams","assertParamsValid","sizeFromShape","shouldExecuteOnCPU","outValues","values","isPacked","isContinous","isSliceContinous","program","getBool","customValues","runWebGLProgram","uploadToGPU","sliceConfig","kernelName","backendName","kernelFunc"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Slice.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, Slice, slice_util, util } from '@tensorflow/tfjs-core';\nimport { sliceImplCPU } from '../kernel_utils/shared';\nimport { SliceProgram } from '../slice_gpu';\nimport { SlicePackedProgram } from '../slice_packed_gpu';\nfunction shallowSlice(x, begin, size, backend) {\n    const xTexData = backend.texData.get(x.dataId);\n    const t = backend.makeTensorInfo(size, x.dtype);\n    const newTexData = backend.texData.get(t.dataId);\n    // Copy texture data from the original tensor.\n    Object.assign(newTexData, xTexData);\n    newTexData.refCount = 1;\n    newTexData.shape = size;\n    newTexData.dtype = x.dtype;\n    let flatOffset = slice_util.computeFlatOffset(begin, util.computeStrides(x.shape));\n    if (xTexData.slice) {\n        // We are slicing an already sliced tensor, so we have to accumulate\n        // the offset.\n        flatOffset += xTexData.slice.flatOffset;\n    }\n    newTexData.slice = {\n        flatOffset,\n        // Point to the original dataId, which is used to do ref counting.\n        origDataId: xTexData.slice && xTexData.slice.origDataId || x.dataId\n    };\n    // Increase the ref count for that data bucket.\n    const refCount = backend.dataRefCount.get(newTexData.slice.origDataId) || 1;\n    backend.dataRefCount.set(newTexData.slice.origDataId, refCount + 1);\n    return t;\n}\nexport function slice(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { begin, size } = attrs;\n    const [$begin, $size] = slice_util.parseSliceParams(x, begin, size);\n    slice_util.assertParamsValid(x, $begin, $size);\n    if (util.sizeFromShape($size) === 0) {\n        return backend.makeTensorInfo($size, x.dtype, []);\n    }\n    // Run on cpu if dtype is string. For string, the backend represents it\n    // as Uint8Array[], where each Uint8Array is a character. Given that the\n    // computation is only on the outer array, uploading the whole data onto\n    // gpu is wasteful. Also, currently webgl doesn't have a design to\n    // upload and retrieve Uint8Array[] between cpu and gpu. Therefore, we\n    // just run the kernel on cpu if dtype is string.\n    if (backend.shouldExecuteOnCPU([x]) || x.dtype === 'string') {\n        const xTexData = backend.texData.get(x.dataId);\n        const outValues = sliceImplCPU(xTexData.values, $begin, $size, x.shape, x.dtype);\n        return backend.makeTensorInfo($size, x.dtype, outValues);\n    }\n    const { isPacked } = backend.texData.get(x.dataId);\n    const isContinous = slice_util.isSliceContinous(x.shape, $begin, $size);\n    if (isPacked || !isContinous) {\n        const program = env().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ?\n            new SlicePackedProgram($size) :\n            new SliceProgram($size);\n        const customValues = [$begin];\n        return backend.runWebGLProgram(program, [x], x.dtype, customValues);\n    }\n    backend.uploadToGPU(x.dataId);\n    return shallowSlice(x, $begin, $size, backend);\n}\nexport const sliceConfig = {\n    kernelName: Slice,\n    backendName: 'webgl',\n    kernelFunc: slice\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,GAAT,EAAcC,KAAd,EAAqBC,UAArB,EAAiCC,IAAjC,QAA6C,uBAA7C;AACA,SAASC,YAAT,QAA6B,wBAA7B;AACA,SAASC,YAAT,QAA6B,cAA7B;AACA,SAASC,kBAAT,QAAmC,qBAAnC;;AACA,SAASC,YAAT,CAAsBC,CAAtB,EAAyBC,KAAzB,EAAgCC,IAAhC,EAAsCC,OAAtC,EAA+C;EAC3C,MAAMC,QAAQ,GAAGD,OAAO,CAACE,OAAR,CAAgBC,GAAhB,CAAoBN,CAAC,CAACO,MAAtB,CAAjB;EACA,MAAMC,CAAC,GAAGL,OAAO,CAACM,cAAR,CAAuBP,IAAvB,EAA6BF,CAAC,CAACU,KAA/B,CAAV;EACA,MAAMC,UAAU,GAAGR,OAAO,CAACE,OAAR,CAAgBC,GAAhB,CAAoBE,CAAC,CAACD,MAAtB,CAAnB,CAH2C,CAI3C;;EACAK,MAAM,CAACC,MAAP,CAAcF,UAAd,EAA0BP,QAA1B;EACAO,UAAU,CAACG,QAAX,GAAsB,CAAtB;EACAH,UAAU,CAACI,KAAX,GAAmBb,IAAnB;EACAS,UAAU,CAACD,KAAX,GAAmBV,CAAC,CAACU,KAArB;EACA,IAAIM,UAAU,GAAGtB,UAAU,CAACuB,iBAAX,CAA6BhB,KAA7B,EAAoCN,IAAI,CAACuB,cAAL,CAAoBlB,CAAC,CAACe,KAAtB,CAApC,CAAjB;;EACA,IAAIX,QAAQ,CAACe,KAAb,EAAoB;IAChB;IACA;IACAH,UAAU,IAAIZ,QAAQ,CAACe,KAAT,CAAeH,UAA7B;EACH;;EACDL,UAAU,CAACQ,KAAX,GAAmB;IACfH,UADe;IAEf;IACAI,UAAU,EAAEhB,QAAQ,CAACe,KAAT,IAAkBf,QAAQ,CAACe,KAAT,CAAeC,UAAjC,IAA+CpB,CAAC,CAACO;EAH9C,CAAnB,CAf2C,CAoB3C;;EACA,MAAMO,QAAQ,GAAGX,OAAO,CAACkB,YAAR,CAAqBf,GAArB,CAAyBK,UAAU,CAACQ,KAAX,CAAiBC,UAA1C,KAAyD,CAA1E;EACAjB,OAAO,CAACkB,YAAR,CAAqBC,GAArB,CAAyBX,UAAU,CAACQ,KAAX,CAAiBC,UAA1C,EAAsDN,QAAQ,GAAG,CAAjE;EACA,OAAON,CAAP;AACH;;AACD,OAAO,SAASW,KAAT,CAAeI,IAAf,EAAqB;EACxB,MAAM;IAAEC,MAAF;IAAUrB,OAAV;IAAmBsB;EAAnB,IAA6BF,IAAnC;EACA,MAAM;IAAEvB;EAAF,IAAQwB,MAAd;EACA,MAAM;IAAEvB,KAAF;IAASC;EAAT,IAAkBuB,KAAxB;EACA,MAAM,CAACC,MAAD,EAASC,KAAT,IAAkBjC,UAAU,CAACkC,gBAAX,CAA4B5B,CAA5B,EAA+BC,KAA/B,EAAsCC,IAAtC,CAAxB;EACAR,UAAU,CAACmC,iBAAX,CAA6B7B,CAA7B,EAAgC0B,MAAhC,EAAwCC,KAAxC;;EACA,IAAIhC,IAAI,CAACmC,aAAL,CAAmBH,KAAnB,MAA8B,CAAlC,EAAqC;IACjC,OAAOxB,OAAO,CAACM,cAAR,CAAuBkB,KAAvB,EAA8B3B,CAAC,CAACU,KAAhC,EAAuC,EAAvC,CAAP;EACH,CARuB,CASxB;EACA;EACA;EACA;EACA;EACA;;;EACA,IAAIP,OAAO,CAAC4B,kBAAR,CAA2B,CAAC/B,CAAD,CAA3B,KAAmCA,CAAC,CAACU,KAAF,KAAY,QAAnD,EAA6D;IACzD,MAAMN,QAAQ,GAAGD,OAAO,CAACE,OAAR,CAAgBC,GAAhB,CAAoBN,CAAC,CAACO,MAAtB,CAAjB;IACA,MAAMyB,SAAS,GAAGpC,YAAY,CAACQ,QAAQ,CAAC6B,MAAV,EAAkBP,MAAlB,EAA0BC,KAA1B,EAAiC3B,CAAC,CAACe,KAAnC,EAA0Cf,CAAC,CAACU,KAA5C,CAA9B;IACA,OAAOP,OAAO,CAACM,cAAR,CAAuBkB,KAAvB,EAA8B3B,CAAC,CAACU,KAAhC,EAAuCsB,SAAvC,CAAP;EACH;;EACD,MAAM;IAAEE;EAAF,IAAe/B,OAAO,CAACE,OAAR,CAAgBC,GAAhB,CAAoBN,CAAC,CAACO,MAAtB,CAArB;EACA,MAAM4B,WAAW,GAAGzC,UAAU,CAAC0C,gBAAX,CAA4BpC,CAAC,CAACe,KAA9B,EAAqCW,MAArC,EAA6CC,KAA7C,CAApB;;EACA,IAAIO,QAAQ,IAAI,CAACC,WAAjB,EAA8B;IAC1B,MAAME,OAAO,GAAG7C,GAAG,GAAG8C,OAAN,CAAc,6BAAd,IACZ,IAAIxC,kBAAJ,CAAuB6B,KAAvB,CADY,GAEZ,IAAI9B,YAAJ,CAAiB8B,KAAjB,CAFJ;IAGA,MAAMY,YAAY,GAAG,CAACb,MAAD,CAArB;IACA,OAAOvB,OAAO,CAACqC,eAAR,CAAwBH,OAAxB,EAAiC,CAACrC,CAAD,CAAjC,EAAsCA,CAAC,CAACU,KAAxC,EAA+C6B,YAA/C,CAAP;EACH;;EACDpC,OAAO,CAACsC,WAAR,CAAoBzC,CAAC,CAACO,MAAtB;EACA,OAAOR,YAAY,CAACC,CAAD,EAAI0B,MAAJ,EAAYC,KAAZ,EAAmBxB,OAAnB,CAAnB;AACH;AACD,OAAO,MAAMuC,WAAW,GAAG;EACvBC,UAAU,EAAElD,KADW;EAEvBmD,WAAW,EAAE,OAFU;EAGvBC,UAAU,EAAE1B;AAHW,CAApB"},"metadata":{},"sourceType":"module"}