{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\n/**\n * Produces GLSL code that derives logical coordinates from a flat\n * index. The code performs integer division with each stride and decrements\n * the index until the index equals the final dimension coordinate.\n */\n\nexport function getLogicalCoordinatesFromFlatIndex(coords, shape, index = 'index') {\n  const strides = util.computeStrides(shape);\n  return strides.map((stride, i) => {\n    const line1 = `int ${coords[i]} = ${index} / ${stride}`;\n    const line2 = i === strides.length - 1 ? `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` : `index -= ${coords[i]} * ${stride}`;\n    return `${line1}; ${line2};`;\n  }).join('');\n}\nexport function getOutputLogicalCoordinatesFromFlatIndexByUniform(coords, shape, index = 'index') {\n  const strides = util.computeStrides(shape);\n  return strides.map((_, i) => {\n    const line1 = `int ${coords[i]} = ${index} / outShapeStrides[${i}]`;\n    const line2 = i === strides.length - 1 ? `int ${coords[i + 1]} = ${index} - ${coords[i]} * outShapeStrides[${i}]` : `index -= ${coords[i]} * outShapeStrides[${i}]`;\n    return `${line1}; ${line2};`;\n  }).join('');\n} // Produces GLSL code that computes strides.\n\nfunction symbolicallyComputeStrides(indicesArr, variableName) {\n  const numCoords = indicesArr.length;\n  const shape = indicesArr.map(d => `${variableName}[${d}]`);\n  const strides = new Array(numCoords - 1);\n  strides[numCoords - 2] = shape[numCoords - 1];\n\n  for (let i = numCoords - 3; i >= 0; --i) {\n    strides[i] = `(${strides[i + 1]} * ${shape[i + 1]})`;\n  }\n\n  return strides;\n}\n\nexport function getLogicalCoordinatesFromFlatIndexByUniform(coords, variableName, index = 'index') {\n  const indicesArray = coords.map((_, i) => i);\n  const strides = symbolicallyComputeStrides(indicesArray, variableName);\n  return strides.map((_, i) => {\n    const line1 = `int ${coords[i]} = ${index} / ${strides[i]}`;\n    const line2 = i === strides.length - 1 ? `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${strides[i]}` : `index -= ${coords[i]} * ${strides[i]}`;\n    return `${line1}; ${line2};`;\n  }).join('');\n}\n\nfunction buildVec(x) {\n  if (x.length === 1) {\n    return `${x[0]}`;\n  }\n\n  return `vec${x.length}(${x.join(',')})`;\n}\n/**\n * Produces GLSL code that computes the dot product of the input x and y\n * vectors. Handles splitting inputs into increments of vec4s when necessary.\n */\n\n\nexport function dotify(x, y) {\n  if (x.length !== y.length) {\n    throw new Error(`Vectors to be dotted must be of the same length -` + `got ${x.length} and ${y.length}`);\n  }\n\n  const slices = [];\n  const nearestVec4 = Math.floor(x.length / 4);\n  const nearestVec4Remainder = x.length % 4;\n\n  for (let i = 0; i < nearestVec4; i++) {\n    const xSlice = x.slice(i * 4, i * 4 + 4);\n    const ySlice = y.slice(i * 4, i * 4 + 4);\n    slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n  }\n\n  if (nearestVec4Remainder !== 0) {\n    let xSlice = x.slice(nearestVec4 * 4);\n    let ySlice = y.slice(nearestVec4 * 4);\n\n    if (xSlice.length === 1) {\n      xSlice = xSlice.map(d => `float(${d})`);\n      ySlice = ySlice.map(d => `float(${d})`);\n    }\n\n    slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n  }\n\n  return slices.map((d, i) => `dot(${d})`).join('+');\n}\n/**\n * Produces GLSL that computes the flat index from 3D coordinates.\n */\n\nexport function getFlatIndexFrom3D(shape) {\n  const strides = util.computeStrides(shape).map(d => d.toString());\n  return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;\n  }\n`;\n}\nexport function getFlatIndexFrom3DOutput() {\n  return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n`;\n}\nexport const ENCODE_FLOAT_SNIPPET = `\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n`;","map":{"version":3,"names":["util","getLogicalCoordinatesFromFlatIndex","coords","shape","index","strides","computeStrides","map","stride","i","line1","line2","length","join","getOutputLogicalCoordinatesFromFlatIndexByUniform","_","symbolicallyComputeStrides","indicesArr","variableName","numCoords","d","Array","getLogicalCoordinatesFromFlatIndexByUniform","indicesArray","buildVec","x","dotify","y","Error","slices","nearestVec4","Math","floor","nearestVec4Remainder","xSlice","slice","ySlice","push","getFlatIndexFrom3D","toString","getFlatIndexFrom3DOutput","ENCODE_FLOAT_SNIPPET"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler_util.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\n/**\n * Produces GLSL code that derives logical coordinates from a flat\n * index. The code performs integer division with each stride and decrements\n * the index until the index equals the final dimension coordinate.\n */\nexport function getLogicalCoordinatesFromFlatIndex(coords, shape, index = 'index') {\n    const strides = util.computeStrides(shape);\n    return strides\n        .map((stride, i) => {\n        const line1 = `int ${coords[i]} = ${index} / ${stride}`;\n        const line2 = i === strides.length - 1 ?\n            `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` :\n            `index -= ${coords[i]} * ${stride}`;\n        return `${line1}; ${line2};`;\n    })\n        .join('');\n}\nexport function getOutputLogicalCoordinatesFromFlatIndexByUniform(coords, shape, index = 'index') {\n    const strides = util.computeStrides(shape);\n    return strides\n        .map((_, i) => {\n        const line1 = `int ${coords[i]} = ${index} / outShapeStrides[${i}]`;\n        const line2 = i === strides.length - 1 ?\n            `int ${coords[i + 1]} = ${index} - ${coords[i]} * outShapeStrides[${i}]` :\n            `index -= ${coords[i]} * outShapeStrides[${i}]`;\n        return `${line1}; ${line2};`;\n    })\n        .join('');\n}\n// Produces GLSL code that computes strides.\nfunction symbolicallyComputeStrides(indicesArr, variableName) {\n    const numCoords = indicesArr.length;\n    const shape = indicesArr.map(d => `${variableName}[${d}]`);\n    const strides = new Array(numCoords - 1);\n    strides[numCoords - 2] = shape[numCoords - 1];\n    for (let i = numCoords - 3; i >= 0; --i) {\n        strides[i] = `(${strides[i + 1]} * ${shape[i + 1]})`;\n    }\n    return strides;\n}\nexport function getLogicalCoordinatesFromFlatIndexByUniform(coords, variableName, index = 'index') {\n    const indicesArray = coords.map((_, i) => i);\n    const strides = symbolicallyComputeStrides(indicesArray, variableName);\n    return strides\n        .map((_, i) => {\n        const line1 = `int ${coords[i]} = ${index} / ${strides[i]}`;\n        const line2 = i === strides.length - 1 ?\n            `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${strides[i]}` :\n            `index -= ${coords[i]} * ${strides[i]}`;\n        return `${line1}; ${line2};`;\n    })\n        .join('');\n}\nfunction buildVec(x) {\n    if (x.length === 1) {\n        return `${x[0]}`;\n    }\n    return `vec${x.length}(${x.join(',')})`;\n}\n/**\n * Produces GLSL code that computes the dot product of the input x and y\n * vectors. Handles splitting inputs into increments of vec4s when necessary.\n */\nexport function dotify(x, y) {\n    if (x.length !== y.length) {\n        throw new Error(`Vectors to be dotted must be of the same length -` +\n            `got ${x.length} and ${y.length}`);\n    }\n    const slices = [];\n    const nearestVec4 = Math.floor(x.length / 4);\n    const nearestVec4Remainder = x.length % 4;\n    for (let i = 0; i < nearestVec4; i++) {\n        const xSlice = x.slice(i * 4, i * 4 + 4);\n        const ySlice = y.slice(i * 4, i * 4 + 4);\n        slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n    }\n    if (nearestVec4Remainder !== 0) {\n        let xSlice = x.slice(nearestVec4 * 4);\n        let ySlice = y.slice(nearestVec4 * 4);\n        if (xSlice.length === 1) {\n            xSlice = xSlice.map(d => `float(${d})`);\n            ySlice = ySlice.map(d => `float(${d})`);\n        }\n        slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n    }\n    return slices.map((d, i) => `dot(${d})`).join('+');\n}\n/**\n * Produces GLSL that computes the flat index from 3D coordinates.\n */\nexport function getFlatIndexFrom3D(shape) {\n    const strides = util.computeStrides(shape).map(d => d.toString());\n    return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;\n  }\n`;\n}\nexport function getFlatIndexFrom3DOutput() {\n    return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n`;\n}\nexport const ENCODE_FLOAT_SNIPPET = `\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n`;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}