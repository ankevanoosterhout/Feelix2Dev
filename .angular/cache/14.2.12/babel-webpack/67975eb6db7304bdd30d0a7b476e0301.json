{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * TensorFlow.js Layers: Pooling Layers.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport { imageDataFormat } from '../backend/common';\nimport * as K from '../backend/tfjs_backend';\nimport { checkDataFormat, checkPaddingMode, checkPoolMode } from '../common';\nimport { InputSpec } from '../engine/topology';\nimport { Layer } from '../engine/topology';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { convOutputLength } from '../utils/conv_utils';\nimport { assertPositiveInteger } from '../utils/generic_utils';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\nimport { preprocessConv2DInput, preprocessConv3DInput } from './convolutional';\n/**\n * 2D pooling.\n * @param x\n * @param poolSize\n * @param stridesdes strides. Defaults to [1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 2D pooling.\n */\n\nexport function pool2d(x, poolSize, strides, padding, dataFormat, poolMode) {\n  return tidy(() => {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n\n    if (strides == null) {\n      strides = [1, 1];\n    }\n\n    if (padding == null) {\n      padding = 'valid';\n    }\n\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n\n    if (poolMode == null) {\n      poolMode = 'max';\n    } // TODO(cais): Remove the preprocessing step once deeplearn.js supports\n    // dataFormat as an input argument.\n\n\n    x = preprocessConv2DInput(x, dataFormat); // x is NHWC after preprocessing.\n\n    let y;\n    const paddingString = padding === 'same' ? 'same' : 'valid';\n\n    if (poolMode === 'max') {\n      // TODO(cais): Rank check?\n      y = tfc.maxPool(x, poolSize, strides, paddingString);\n    } else {\n      // 'avg'\n      // TODO(cais): Check the dtype and rank of x and give clear error message\n      //   if those are incorrect.\n      y = tfc.avgPool( // TODO(cais): Rank check?\n      x, poolSize, strides, paddingString);\n    }\n\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 3, 1, 2]); // NHWC -> NCHW.\n    }\n\n    return y;\n  });\n}\n/**\n * 3D pooling.\n * @param x\n * @param poolSize. Default to [1, 1, 1].\n * @param strides strides. Defaults to [1, 1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 3D pooling.\n */\n\nexport function pool3d(x, poolSize, strides, padding, dataFormat, poolMode) {\n  return tidy(() => {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n\n    if (strides == null) {\n      strides = [1, 1, 1];\n    }\n\n    if (padding == null) {\n      padding = 'valid';\n    }\n\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n\n    if (poolMode == null) {\n      poolMode = 'max';\n    } // x is NDHWC after preprocessing.\n\n\n    x = preprocessConv3DInput(x, dataFormat);\n    let y;\n    const paddingString = padding === 'same' ? 'same' : 'valid';\n\n    if (poolMode === 'max') {\n      y = tfc.maxPool3d(x, poolSize, strides, paddingString);\n    } else {\n      // 'avg'\n      y = tfc.avgPool3d(x, poolSize, strides, paddingString);\n    }\n\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 4, 1, 2, 3]); // NDHWC -> NCDHW.\n    }\n\n    return y;\n  });\n}\n/**\n * Abstract class for different pooling 1D layers.\n */\n\nexport class Pooling1D extends Layer {\n  /**\n   *\n   * @param args Parameters for the Pooling layer.\n   *\n   * config.poolSize defaults to 2.\n   */\n  constructor(args) {\n    if (args.poolSize == null) {\n      args.poolSize = 2;\n    }\n\n    super(args);\n\n    if (typeof args.poolSize === 'number') {\n      this.poolSize = [args.poolSize];\n    } else if (Array.isArray(args.poolSize) && args.poolSize.length === 1 && typeof args.poolSize[0] === 'number') {\n      this.poolSize = args.poolSize;\n    } else {\n      throw new ValueError(`poolSize for 1D convolutional layer must be a number or an ` + `Array of a single number, but received ` + `${JSON.stringify(args.poolSize)}`);\n    }\n\n    assertPositiveInteger(this.poolSize, 'poolSize');\n\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else {\n      if (typeof args.strides === 'number') {\n        this.strides = [args.strides];\n      } else if (Array.isArray(args.strides) && args.strides.length === 1 && typeof args.strides[0] === 'number') {\n        this.strides = args.strides;\n      } else {\n        throw new ValueError(`strides for 1D convolutional layer must be a number or an ` + `Array of a single number, but received ` + `${JSON.stringify(args.strides)}`);\n      }\n    }\n\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({\n      ndim: 3\n    })];\n  }\n\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    const length = convOutputLength(inputShape[1], this.poolSize[0], this.padding, this.strides[0]);\n    return [inputShape[0], length, inputShape[2]];\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs); // Add dummy last dimension.\n\n      inputs = K.expandDims(getExactlyOneTensor(inputs), 2);\n      const output = this.poolingFunction(getExactlyOneTensor(inputs), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, 'channelsLast'); // Remove dummy last dimension.\n\n      return tfc.squeeze(output, [2]);\n    });\n  }\n\n  getConfig() {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n}\nexport class MaxPooling1D extends Pooling1D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n\n}\n/** @nocollapse */\n\nMaxPooling1D.className = 'MaxPooling1D';\nserialization.registerClass(MaxPooling1D);\nexport class AveragePooling1D extends Pooling1D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n\n}\n/** @nocollapse */\n\nAveragePooling1D.className = 'AveragePooling1D';\nserialization.registerClass(AveragePooling1D);\n/**\n * Abstract class for different pooling 2D layers.\n */\n\nexport class Pooling2D extends Layer {\n  constructor(args) {\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2];\n    }\n\n    super(args);\n    this.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize];\n\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 2) {\n        throw new ValueError(`If the strides property of a 2D pooling layer is an Array, ` + `it is expected to have a length of 2, but received length ` + `${args.strides.length}.`);\n      }\n\n      this.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      this.strides = [args.strides, args.strides];\n    }\n\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    this.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({\n      ndim: 4\n    })];\n  }\n\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    let rows = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n    let cols = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n    rows = convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);\n    cols = convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);\n\n    if (this.dataFormat === 'channelsFirst') {\n      return [inputShape[0], inputShape[1], rows, cols];\n    } else {\n      return [inputShape[0], rows, cols, inputShape[3]];\n    }\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);\n    });\n  }\n\n  getConfig() {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n}\nexport class MaxPooling2D extends Pooling2D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n\n}\n/** @nocollapse */\n\nMaxPooling2D.className = 'MaxPooling2D';\nserialization.registerClass(MaxPooling2D);\nexport class AveragePooling2D extends Pooling2D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n\n}\n/** @nocollapse */\n\nAveragePooling2D.className = 'AveragePooling2D';\nserialization.registerClass(AveragePooling2D);\n/**\n * Abstract class for different pooling 3D layers.\n */\n\nexport class Pooling3D extends Layer {\n  constructor(args) {\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2, 2];\n    }\n\n    super(args);\n    this.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize, args.poolSize];\n\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 3) {\n        throw new ValueError(`If the strides property of a 3D pooling layer is an Array, ` + `it is expected to have a length of 3, but received length ` + `${args.strides.length}.`);\n      }\n\n      this.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      this.strides = [args.strides, args.strides, args.strides];\n    }\n\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    this.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({\n      ndim: 5\n    })];\n  }\n\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    let depths = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n    let rows = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n    let cols = this.dataFormat === 'channelsFirst' ? inputShape[4] : inputShape[3];\n    depths = convOutputLength(depths, this.poolSize[0], this.padding, this.strides[0]);\n    rows = convOutputLength(rows, this.poolSize[1], this.padding, this.strides[1]);\n    cols = convOutputLength(cols, this.poolSize[2], this.padding, this.strides[2]);\n\n    if (this.dataFormat === 'channelsFirst') {\n      return [inputShape[0], inputShape[1], depths, rows, cols];\n    } else {\n      return [inputShape[0], depths, rows, cols, inputShape[4]];\n    }\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);\n    });\n  }\n\n  getConfig() {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n}\nexport class MaxPooling3D extends Pooling3D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool3d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n\n}\n/** @nocollapse */\n\nMaxPooling3D.className = 'MaxPooling3D';\nserialization.registerClass(MaxPooling3D);\nexport class AveragePooling3D extends Pooling3D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool3d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n\n}\n/** @nocollapse */\n\nAveragePooling3D.className = 'AveragePooling3D';\nserialization.registerClass(AveragePooling3D);\n/**\n * Abstract class for different global pooling 1D layers.\n */\n\nexport class GlobalPooling1D extends Layer {\n  constructor(args) {\n    super(args);\n    this.inputSpec = [new InputSpec({\n      ndim: 3\n    })];\n  }\n\n  computeOutputShape(inputShape) {\n    return [inputShape[0], inputShape[2]];\n  }\n\n  call(inputs, kwargs) {\n    throw new NotImplementedError();\n  }\n\n}\nexport class GlobalAveragePooling1D extends GlobalPooling1D {\n  constructor(args) {\n    super(args || {});\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      return tfc.mean(input, 1);\n    });\n  }\n\n}\n/** @nocollapse */\n\nGlobalAveragePooling1D.className = 'GlobalAveragePooling1D';\nserialization.registerClass(GlobalAveragePooling1D);\nexport class GlobalMaxPooling1D extends GlobalPooling1D {\n  constructor(args) {\n    super(args || {});\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      return tfc.max(input, 1);\n    });\n  }\n\n}\n/** @nocollapse */\n\nGlobalMaxPooling1D.className = 'GlobalMaxPooling1D';\nserialization.registerClass(GlobalMaxPooling1D);\n/**\n * Abstract class for different global pooling 2D layers.\n */\n\nexport class GlobalPooling2D extends Layer {\n  constructor(args) {\n    super(args);\n    this.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    this.inputSpec = [new InputSpec({\n      ndim: 4\n    })];\n  }\n\n  computeOutputShape(inputShape) {\n    inputShape = inputShape;\n\n    if (this.dataFormat === 'channelsLast') {\n      return [inputShape[0], inputShape[3]];\n    } else {\n      return [inputShape[0], inputShape[1]];\n    }\n  }\n\n  call(inputs, kwargs) {\n    throw new NotImplementedError();\n  }\n\n  getConfig() {\n    const config = {\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n}\nexport class GlobalAveragePooling2D extends GlobalPooling2D {\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n\n      if (this.dataFormat === 'channelsLast') {\n        return tfc.mean(input, [1, 2]);\n      } else {\n        return tfc.mean(input, [2, 3]);\n      }\n    });\n  }\n\n}\n/** @nocollapse */\n\nGlobalAveragePooling2D.className = 'GlobalAveragePooling2D';\nserialization.registerClass(GlobalAveragePooling2D);\nexport class GlobalMaxPooling2D extends GlobalPooling2D {\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n\n      if (this.dataFormat === 'channelsLast') {\n        return tfc.max(input, [1, 2]);\n      } else {\n        return tfc.max(input, [2, 3]);\n      }\n    });\n  }\n\n}\n/** @nocollapse */\n\nGlobalMaxPooling2D.className = 'GlobalMaxPooling2D';\nserialization.registerClass(GlobalMaxPooling2D);","map":{"version":3,"names":["tfc","serialization","tidy","imageDataFormat","K","checkDataFormat","checkPaddingMode","checkPoolMode","InputSpec","Layer","NotImplementedError","ValueError","convOutputLength","assertPositiveInteger","getExactlyOneShape","getExactlyOneTensor","preprocessConv2DInput","preprocessConv3DInput","pool2d","x","poolSize","strides","padding","dataFormat","poolMode","y","paddingString","maxPool","avgPool","transpose","pool3d","maxPool3d","avgPool3d","Pooling1D","constructor","args","Array","isArray","length","JSON","stringify","inputSpec","ndim","computeOutputShape","inputShape","call","inputs","kwargs","invokeCallHook","expandDims","output","poolingFunction","squeeze","getConfig","config","baseConfig","Object","assign","MaxPooling1D","className","registerClass","AveragePooling1D","Pooling2D","rows","cols","MaxPooling2D","AveragePooling2D","Pooling3D","depths","MaxPooling3D","AveragePooling3D","GlobalPooling1D","GlobalAveragePooling1D","input","mean","GlobalMaxPooling1D","max","GlobalPooling2D","GlobalAveragePooling2D","GlobalMaxPooling2D"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-layers/dist/layers/pooling.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * TensorFlow.js Layers: Pooling Layers.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport { imageDataFormat } from '../backend/common';\nimport * as K from '../backend/tfjs_backend';\nimport { checkDataFormat, checkPaddingMode, checkPoolMode } from '../common';\nimport { InputSpec } from '../engine/topology';\nimport { Layer } from '../engine/topology';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { convOutputLength } from '../utils/conv_utils';\nimport { assertPositiveInteger } from '../utils/generic_utils';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\nimport { preprocessConv2DInput, preprocessConv3DInput } from './convolutional';\n/**\n * 2D pooling.\n * @param x\n * @param poolSize\n * @param stridesdes strides. Defaults to [1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 2D pooling.\n */\nexport function pool2d(x, poolSize, strides, padding, dataFormat, poolMode) {\n    return tidy(() => {\n        checkDataFormat(dataFormat);\n        checkPoolMode(poolMode);\n        checkPaddingMode(padding);\n        if (strides == null) {\n            strides = [1, 1];\n        }\n        if (padding == null) {\n            padding = 'valid';\n        }\n        if (dataFormat == null) {\n            dataFormat = imageDataFormat();\n        }\n        if (poolMode == null) {\n            poolMode = 'max';\n        }\n        // TODO(cais): Remove the preprocessing step once deeplearn.js supports\n        // dataFormat as an input argument.\n        x = preprocessConv2DInput(x, dataFormat); // x is NHWC after preprocessing.\n        let y;\n        const paddingString = (padding === 'same') ? 'same' : 'valid';\n        if (poolMode === 'max') {\n            // TODO(cais): Rank check?\n            y = tfc.maxPool(x, poolSize, strides, paddingString);\n        }\n        else { // 'avg'\n            // TODO(cais): Check the dtype and rank of x and give clear error message\n            //   if those are incorrect.\n            y = tfc.avgPool(\n            // TODO(cais): Rank check?\n            x, poolSize, strides, paddingString);\n        }\n        if (dataFormat === 'channelsFirst') {\n            y = tfc.transpose(y, [0, 3, 1, 2]); // NHWC -> NCHW.\n        }\n        return y;\n    });\n}\n/**\n * 3D pooling.\n * @param x\n * @param poolSize. Default to [1, 1, 1].\n * @param strides strides. Defaults to [1, 1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 3D pooling.\n */\nexport function pool3d(x, poolSize, strides, padding, dataFormat, poolMode) {\n    return tidy(() => {\n        checkDataFormat(dataFormat);\n        checkPoolMode(poolMode);\n        checkPaddingMode(padding);\n        if (strides == null) {\n            strides = [1, 1, 1];\n        }\n        if (padding == null) {\n            padding = 'valid';\n        }\n        if (dataFormat == null) {\n            dataFormat = imageDataFormat();\n        }\n        if (poolMode == null) {\n            poolMode = 'max';\n        }\n        // x is NDHWC after preprocessing.\n        x = preprocessConv3DInput(x, dataFormat);\n        let y;\n        const paddingString = (padding === 'same') ? 'same' : 'valid';\n        if (poolMode === 'max') {\n            y = tfc.maxPool3d(x, poolSize, strides, paddingString);\n        }\n        else { // 'avg'\n            y = tfc.avgPool3d(x, poolSize, strides, paddingString);\n        }\n        if (dataFormat === 'channelsFirst') {\n            y = tfc.transpose(y, [0, 4, 1, 2, 3]); // NDHWC -> NCDHW.\n        }\n        return y;\n    });\n}\n/**\n * Abstract class for different pooling 1D layers.\n */\nexport class Pooling1D extends Layer {\n    /**\n     *\n     * @param args Parameters for the Pooling layer.\n     *\n     * config.poolSize defaults to 2.\n     */\n    constructor(args) {\n        if (args.poolSize == null) {\n            args.poolSize = 2;\n        }\n        super(args);\n        if (typeof args.poolSize === 'number') {\n            this.poolSize = [args.poolSize];\n        }\n        else if (Array.isArray(args.poolSize) &&\n            args.poolSize.length === 1 &&\n            typeof args.poolSize[0] === 'number') {\n            this.poolSize = args.poolSize;\n        }\n        else {\n            throw new ValueError(`poolSize for 1D convolutional layer must be a number or an ` +\n                `Array of a single number, but received ` +\n                `${JSON.stringify(args.poolSize)}`);\n        }\n        assertPositiveInteger(this.poolSize, 'poolSize');\n        if (args.strides == null) {\n            this.strides = this.poolSize;\n        }\n        else {\n            if (typeof args.strides === 'number') {\n                this.strides = [args.strides];\n            }\n            else if (Array.isArray(args.strides) &&\n                args.strides.length === 1 &&\n                typeof args.strides[0] === 'number') {\n                this.strides = args.strides;\n            }\n            else {\n                throw new ValueError(`strides for 1D convolutional layer must be a number or an ` +\n                    `Array of a single number, but received ` +\n                    `${JSON.stringify(args.strides)}`);\n            }\n        }\n        assertPositiveInteger(this.strides, 'strides');\n        this.padding = args.padding == null ? 'valid' : args.padding;\n        checkPaddingMode(this.padding);\n        this.inputSpec = [new InputSpec({ ndim: 3 })];\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        const length = convOutputLength(inputShape[1], this.poolSize[0], this.padding, this.strides[0]);\n        return [inputShape[0], length, inputShape[2]];\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            this.invokeCallHook(inputs, kwargs);\n            // Add dummy last dimension.\n            inputs = K.expandDims(getExactlyOneTensor(inputs), 2);\n            const output = this.poolingFunction(getExactlyOneTensor(inputs), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, 'channelsLast');\n            // Remove dummy last dimension.\n            return tfc.squeeze(output, [2]);\n        });\n    }\n    getConfig() {\n        const config = {\n            poolSize: this.poolSize,\n            padding: this.padding,\n            strides: this.strides,\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\nexport class MaxPooling1D extends Pooling1D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n    }\n}\n/** @nocollapse */\nMaxPooling1D.className = 'MaxPooling1D';\nserialization.registerClass(MaxPooling1D);\nexport class AveragePooling1D extends Pooling1D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n    }\n}\n/** @nocollapse */\nAveragePooling1D.className = 'AveragePooling1D';\nserialization.registerClass(AveragePooling1D);\n/**\n * Abstract class for different pooling 2D layers.\n */\nexport class Pooling2D extends Layer {\n    constructor(args) {\n        if (args.poolSize == null) {\n            args.poolSize = [2, 2];\n        }\n        super(args);\n        this.poolSize = Array.isArray(args.poolSize) ?\n            args.poolSize :\n            [args.poolSize, args.poolSize];\n        if (args.strides == null) {\n            this.strides = this.poolSize;\n        }\n        else if (Array.isArray(args.strides)) {\n            if (args.strides.length !== 2) {\n                throw new ValueError(`If the strides property of a 2D pooling layer is an Array, ` +\n                    `it is expected to have a length of 2, but received length ` +\n                    `${args.strides.length}.`);\n            }\n            this.strides = args.strides;\n        }\n        else {\n            // `config.strides` is a number.\n            this.strides = [args.strides, args.strides];\n        }\n        assertPositiveInteger(this.poolSize, 'poolSize');\n        assertPositiveInteger(this.strides, 'strides');\n        this.padding = args.padding == null ? 'valid' : args.padding;\n        this.dataFormat =\n            args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n        checkDataFormat(this.dataFormat);\n        checkPaddingMode(this.padding);\n        this.inputSpec = [new InputSpec({ ndim: 4 })];\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        let rows = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n        let cols = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n        rows =\n            convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);\n        cols =\n            convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);\n        if (this.dataFormat === 'channelsFirst') {\n            return [inputShape[0], inputShape[1], rows, cols];\n        }\n        else {\n            return [inputShape[0], rows, cols, inputShape[3]];\n        }\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            this.invokeCallHook(inputs, kwargs);\n            return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);\n        });\n    }\n    getConfig() {\n        const config = {\n            poolSize: this.poolSize,\n            padding: this.padding,\n            strides: this.strides,\n            dataFormat: this.dataFormat\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\nexport class MaxPooling2D extends Pooling2D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n    }\n}\n/** @nocollapse */\nMaxPooling2D.className = 'MaxPooling2D';\nserialization.registerClass(MaxPooling2D);\nexport class AveragePooling2D extends Pooling2D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n    }\n}\n/** @nocollapse */\nAveragePooling2D.className = 'AveragePooling2D';\nserialization.registerClass(AveragePooling2D);\n/**\n * Abstract class for different pooling 3D layers.\n */\nexport class Pooling3D extends Layer {\n    constructor(args) {\n        if (args.poolSize == null) {\n            args.poolSize = [2, 2, 2];\n        }\n        super(args);\n        this.poolSize = Array.isArray(args.poolSize) ?\n            args.poolSize :\n            [args.poolSize, args.poolSize, args.poolSize];\n        if (args.strides == null) {\n            this.strides = this.poolSize;\n        }\n        else if (Array.isArray(args.strides)) {\n            if (args.strides.length !== 3) {\n                throw new ValueError(`If the strides property of a 3D pooling layer is an Array, ` +\n                    `it is expected to have a length of 3, but received length ` +\n                    `${args.strides.length}.`);\n            }\n            this.strides = args.strides;\n        }\n        else {\n            // `config.strides` is a number.\n            this.strides = [args.strides, args.strides, args.strides];\n        }\n        assertPositiveInteger(this.poolSize, 'poolSize');\n        assertPositiveInteger(this.strides, 'strides');\n        this.padding = args.padding == null ? 'valid' : args.padding;\n        this.dataFormat =\n            args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n        checkDataFormat(this.dataFormat);\n        checkPaddingMode(this.padding);\n        this.inputSpec = [new InputSpec({ ndim: 5 })];\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        let depths = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n        let rows = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n        let cols = this.dataFormat === 'channelsFirst' ? inputShape[4] : inputShape[3];\n        depths = convOutputLength(depths, this.poolSize[0], this.padding, this.strides[0]);\n        rows =\n            convOutputLength(rows, this.poolSize[1], this.padding, this.strides[1]);\n        cols =\n            convOutputLength(cols, this.poolSize[2], this.padding, this.strides[2]);\n        if (this.dataFormat === 'channelsFirst') {\n            return [inputShape[0], inputShape[1], depths, rows, cols];\n        }\n        else {\n            return [inputShape[0], depths, rows, cols, inputShape[4]];\n        }\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            this.invokeCallHook(inputs, kwargs);\n            return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);\n        });\n    }\n    getConfig() {\n        const config = {\n            poolSize: this.poolSize,\n            padding: this.padding,\n            strides: this.strides,\n            dataFormat: this.dataFormat\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\nexport class MaxPooling3D extends Pooling3D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool3d(inputs, poolSize, strides, padding, dataFormat, 'max');\n    }\n}\n/** @nocollapse */\nMaxPooling3D.className = 'MaxPooling3D';\nserialization.registerClass(MaxPooling3D);\nexport class AveragePooling3D extends Pooling3D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool3d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n    }\n}\n/** @nocollapse */\nAveragePooling3D.className = 'AveragePooling3D';\nserialization.registerClass(AveragePooling3D);\n/**\n * Abstract class for different global pooling 1D layers.\n */\nexport class GlobalPooling1D extends Layer {\n    constructor(args) {\n        super(args);\n        this.inputSpec = [new InputSpec({ ndim: 3 })];\n    }\n    computeOutputShape(inputShape) {\n        return [inputShape[0], inputShape[2]];\n    }\n    call(inputs, kwargs) {\n        throw new NotImplementedError();\n    }\n}\nexport class GlobalAveragePooling1D extends GlobalPooling1D {\n    constructor(args) {\n        super(args || {});\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            const input = getExactlyOneTensor(inputs);\n            return tfc.mean(input, 1);\n        });\n    }\n}\n/** @nocollapse */\nGlobalAveragePooling1D.className = 'GlobalAveragePooling1D';\nserialization.registerClass(GlobalAveragePooling1D);\nexport class GlobalMaxPooling1D extends GlobalPooling1D {\n    constructor(args) {\n        super(args || {});\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            const input = getExactlyOneTensor(inputs);\n            return tfc.max(input, 1);\n        });\n    }\n}\n/** @nocollapse */\nGlobalMaxPooling1D.className = 'GlobalMaxPooling1D';\nserialization.registerClass(GlobalMaxPooling1D);\n/**\n * Abstract class for different global pooling 2D layers.\n */\nexport class GlobalPooling2D extends Layer {\n    constructor(args) {\n        super(args);\n        this.dataFormat =\n            args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n        checkDataFormat(this.dataFormat);\n        this.inputSpec = [new InputSpec({ ndim: 4 })];\n    }\n    computeOutputShape(inputShape) {\n        inputShape = inputShape;\n        if (this.dataFormat === 'channelsLast') {\n            return [inputShape[0], inputShape[3]];\n        }\n        else {\n            return [inputShape[0], inputShape[1]];\n        }\n    }\n    call(inputs, kwargs) {\n        throw new NotImplementedError();\n    }\n    getConfig() {\n        const config = { dataFormat: this.dataFormat };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\nexport class GlobalAveragePooling2D extends GlobalPooling2D {\n    call(inputs, kwargs) {\n        return tidy(() => {\n            const input = getExactlyOneTensor(inputs);\n            if (this.dataFormat === 'channelsLast') {\n                return tfc.mean(input, [1, 2]);\n            }\n            else {\n                return tfc.mean(input, [2, 3]);\n            }\n        });\n    }\n}\n/** @nocollapse */\nGlobalAveragePooling2D.className = 'GlobalAveragePooling2D';\nserialization.registerClass(GlobalAveragePooling2D);\nexport class GlobalMaxPooling2D extends GlobalPooling2D {\n    call(inputs, kwargs) {\n        return tidy(() => {\n            const input = getExactlyOneTensor(inputs);\n            if (this.dataFormat === 'channelsLast') {\n                return tfc.max(input, [1, 2]);\n            }\n            else {\n                return tfc.max(input, [2, 3]);\n            }\n        });\n    }\n}\n/** @nocollapse */\nGlobalMaxPooling2D.className = 'GlobalMaxPooling2D';\nserialization.registerClass(GlobalMaxPooling2D);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}