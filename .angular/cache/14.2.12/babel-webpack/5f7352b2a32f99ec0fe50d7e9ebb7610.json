{"ast":null,"code":"import { vec3, vec4 } from 'gl-matrix';\nimport { DOF } from '../Joint.js';\nconst tempPos = new Float64Array(3);\nconst tempQuat = new Float64Array(4);\nconst tempEuler = new Float64Array(3);\nexport function accumulateClosureError(solver, joint, startIndex, errorVector = null, result = {\n  isConverged: false,\n  rowCount: 7,\n  totalError: 0\n}) {\n  const {\n    translationConvergeThreshold,\n    rotationConvergeThreshold,\n    translationErrorClamp,\n    rotationErrorClamp,\n    translationFactor,\n    rotationFactor\n  } = solver;\n  const {\n    translationDoFCount,\n    rotationDoFCount,\n    dofFlags,\n    dof\n  } = joint; // Get the error from child towards the closure target\n\n  joint.getClosureError(tempPos, tempQuat);\n  let rowCount = 7;\n\n  if (joint.isGoal) {\n    tempPos[0] *= dofFlags[0];\n    tempPos[1] *= dofFlags[1];\n    tempPos[2] *= dofFlags[2];\n    rowCount = translationDoFCount;\n\n    if (rotationDoFCount === 0) {\n      tempQuat[0] = 0;\n      tempQuat[1] = 0;\n      tempQuat[2] = 0;\n      tempQuat[3] = 0;\n    } else {\n      rowCount += 4;\n    }\n  }\n\n  let isConverged = false;\n  let totalError = 0;\n  const posMag = vec3.length(tempPos);\n  const rotMag = vec4.length(tempQuat);\n\n  if (posMag < translationConvergeThreshold && rotMag < rotationConvergeThreshold) {\n    isConverged = true;\n  }\n\n  totalError += posMag + rotMag;\n\n  if (errorVector) {\n    if (posMag > translationErrorClamp) {\n      vec3.scale(tempPos, tempPos, translationErrorClamp / posMag);\n    }\n\n    vec4.scale(tempPos, tempPos, translationFactor);\n\n    if (rotMag > rotationErrorClamp) {\n      vec4.scale(tempQuat, tempQuat, rotationErrorClamp / rotMag);\n    }\n\n    vec4.scale(tempQuat, tempQuat, rotationFactor);\n\n    if (joint.isGoal) {\n      for (let i = 0; i < translationDoFCount; i++) {\n        const d = dof[i];\n        errorVector[startIndex + i][0] = tempPos[d];\n      }\n\n      if (joint.rotationDoFCount === 3) {\n        errorVector[startIndex + translationDoFCount + 0][0] = tempQuat[0];\n        errorVector[startIndex + translationDoFCount + 1][0] = tempQuat[1];\n        errorVector[startIndex + translationDoFCount + 2][0] = tempQuat[2];\n        errorVector[startIndex + translationDoFCount + 3][0] = tempQuat[3];\n      }\n    } else {\n      errorVector[startIndex + 0][0] = tempPos[0];\n      errorVector[startIndex + 1][0] = tempPos[1];\n      errorVector[startIndex + 2][0] = tempPos[2];\n      errorVector[startIndex + 3][0] = tempQuat[0];\n      errorVector[startIndex + 4][0] = tempQuat[1];\n      errorVector[startIndex + 5][0] = tempQuat[2];\n      errorVector[startIndex + 6][0] = tempQuat[3];\n    }\n  }\n\n  result.totalError = totalError;\n  result.isConverged = isConverged;\n  result.rowCount = rowCount;\n  return result;\n}\nexport function accumulateTargetError(solver, joint, startIndex, errorVector = null, result = {\n  isConverged: false,\n  rowCount: 7,\n  totalError: 0\n}) {\n  // Find whether or not the target has converged or not\n  const {\n    translationConvergeThreshold,\n    rotationConvergeThreshold,\n    lockedJointDoFCount,\n    translationErrorClamp,\n    rotationErrorClamp,\n    lockedJointDoF\n  } = solver;\n  const {\n    dofTarget,\n    dofValues,\n    translationDoFCount,\n    rotationDoFCount,\n    translationFactor,\n    rotationFactor,\n    dofList\n  } = joint; // get the position delta\n\n  const posDelta = vec3.distance(dofValues, dofTarget); // TODO: if three euler angles are being used we should set this to a quaternion to measure\n  // error rather than euler angles. We should instead just always use quaternions for targets\n  // for now.\n  // Before running this solver we try to ensure the target and restPose are minimized\n\n  let rotDelta = dofTarget[DOF.EX] - dofValues[DOF.EX] + dofTarget[DOF.EY] - dofValues[DOF.EY] + dofTarget[DOF.EZ] - dofValues[DOF.EZ]; // Get the row count\n\n  const lockedDoFCount = lockedJointDoFCount.get(joint) || 0;\n  result.rowCount = translationDoFCount + rotationDoFCount - lockedDoFCount;\n  result.isConverged = posDelta < translationConvergeThreshold && rotDelta < rotationConvergeThreshold;\n  result.totalError = posDelta + rotDelta;\n\n  if (errorVector) {\n    const lockedDoF = lockedJointDoF.get(joint);\n    const isLocked = lockedDoFCount !== 0;\n    let rowIndex = 0; // error from current state to target\n\n    tempPos[0] = dofTarget[0] - dofValues[0];\n    tempPos[1] = dofTarget[1] - dofValues[1];\n    tempPos[2] = dofTarget[2] - dofValues[2]; // clamp the position delta to the max error step\n\n    const posMag = vec3.length(tempPos);\n    vec3.scale(tempPos, tempPos, translationFactor * translationErrorClamp / posMag);\n\n    for (let i = 0, l = translationDoFCount; i < l; i++) {\n      const dof = dofList[i]; // skip this degree of freedom if it's locked\n\n      if (isLocked && lockedDoF[dof]) {\n        continue;\n      }\n\n      errorVector[startIndex + rowIndex][0] = tempPos[dof];\n      rowIndex++;\n    } // get the euler differences\n    // before running this solver we minimize the euler targets\n\n\n    tempEuler[0] = joint.dofTarget[3] - joint.dofValues[3];\n    tempEuler[1] = joint.dofTarget[4] - joint.dofValues[4];\n    tempEuler[2] = joint.dofTarget[5] - joint.dofValues[5]; // clamp the euler difference to the error step magnitude\n\n    const eulerMag = vec3.length(tempEuler);\n    vec3.scale(tempEuler, tempEuler, rotationFactor * rotationErrorClamp / eulerMag);\n\n    for (let i = translationDoFCount, l = translationDoFCount + rotationDoFCount; i < l; i++) {\n      const dof = dofList[i]; // skip this degree of freedom if it's locked\n\n      if (isLocked && lockedDoF[dof]) {\n        continue;\n      }\n\n      errorVector[startIndex + rowIndex][0] = tempEuler[dof];\n      rowIndex++;\n    }\n  }\n}","map":{"version":3,"names":["vec3","vec4","DOF","tempPos","Float64Array","tempQuat","tempEuler","accumulateClosureError","solver","joint","startIndex","errorVector","result","isConverged","rowCount","totalError","translationConvergeThreshold","rotationConvergeThreshold","translationErrorClamp","rotationErrorClamp","translationFactor","rotationFactor","translationDoFCount","rotationDoFCount","dofFlags","dof","getClosureError","isGoal","posMag","length","rotMag","scale","i","d","accumulateTargetError","lockedJointDoFCount","lockedJointDoF","dofTarget","dofValues","dofList","posDelta","distance","rotDelta","EX","EY","EZ","lockedDoFCount","get","lockedDoF","isLocked","rowIndex","l","eulerMag"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/closed-chain-ik/src/core/utils/solver.js"],"sourcesContent":["import { vec3, vec4 } from 'gl-matrix';\r\nimport { DOF } from '../Joint.js';\r\n\r\nconst tempPos = new Float64Array( 3 );\r\nconst tempQuat = new Float64Array( 4 );\r\nconst tempEuler = new Float64Array( 3 );\r\nexport function accumulateClosureError(\r\n\tsolver,\r\n\tjoint,\r\n\tstartIndex,\r\n\terrorVector = null,\r\n\tresult = { isConverged: false, rowCount: 7, totalError: 0 }\r\n) {\r\n\r\n\tconst {\r\n\t\ttranslationConvergeThreshold,\r\n\t\trotationConvergeThreshold,\r\n\t\ttranslationErrorClamp,\r\n\t\trotationErrorClamp,\r\n\t\ttranslationFactor,\r\n\t\trotationFactor,\r\n\t} = solver;\r\n\r\n\tconst {\r\n\t\ttranslationDoFCount,\r\n\t\trotationDoFCount,\r\n\t\tdofFlags,\r\n\t\tdof,\r\n\t} = joint;\r\n\r\n\t// Get the error from child towards the closure target\r\n\tjoint.getClosureError( tempPos, tempQuat );\r\n\r\n\tlet rowCount = 7;\r\n\tif ( joint.isGoal ) {\r\n\r\n\t\ttempPos[ 0 ] *= dofFlags[ 0 ];\r\n\t\ttempPos[ 1 ] *= dofFlags[ 1 ];\r\n\t\ttempPos[ 2 ] *= dofFlags[ 2 ];\r\n\t\trowCount = translationDoFCount;\r\n\r\n\t\tif ( rotationDoFCount === 0 ) {\r\n\r\n\t\t\ttempQuat[ 0 ] = 0;\r\n\t\t\ttempQuat[ 1 ] = 0;\r\n\t\t\ttempQuat[ 2 ] = 0;\r\n\t\t\ttempQuat[ 3 ] = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\trowCount += 4;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tlet isConverged = false;\r\n\tlet totalError = 0;\r\n\tconst posMag = vec3.length( tempPos );\r\n\tconst rotMag = vec4.length( tempQuat );\r\n\tif (\r\n\t\tposMag < translationConvergeThreshold &&\r\n\t\trotMag < rotationConvergeThreshold\r\n\t) {\r\n\r\n\t\tisConverged = true;\r\n\r\n\t}\r\n\r\n\ttotalError += posMag + rotMag;\r\n\r\n\tif ( errorVector ) {\r\n\r\n\t\tif ( posMag > translationErrorClamp ) {\r\n\r\n\t\t\tvec3.scale( tempPos, tempPos, translationErrorClamp / posMag );\r\n\r\n\t\t}\r\n\r\n\t\tvec4.scale( tempPos, tempPos, translationFactor );\r\n\r\n\t\tif ( rotMag > rotationErrorClamp ) {\r\n\r\n\t\t\tvec4.scale( tempQuat, tempQuat, rotationErrorClamp / rotMag );\r\n\r\n\t\t}\r\n\r\n\t\tvec4.scale( tempQuat, tempQuat, rotationFactor );\r\n\r\n\t\tif ( joint.isGoal ) {\r\n\r\n\t\t\tfor ( let i = 0; i < translationDoFCount; i ++ ) {\r\n\r\n\t\t\t\tconst d = dof[ i ];\r\n\t\t\t\terrorVector[ startIndex + i ][ 0 ] = tempPos[ d ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( joint.rotationDoFCount === 3 ) {\r\n\r\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 0 ][ 0 ] = tempQuat[ 0 ];\r\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 1 ][ 0 ] = tempQuat[ 1 ];\r\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 2 ][ 0 ] = tempQuat[ 2 ];\r\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 3 ][ 0 ] = tempQuat[ 3 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\terrorVector[ startIndex + 0 ][ 0 ] = tempPos[ 0 ];\r\n\t\t\terrorVector[ startIndex + 1 ][ 0 ] = tempPos[ 1 ];\r\n\t\t\terrorVector[ startIndex + 2 ][ 0 ] = tempPos[ 2 ];\r\n\r\n\t\t\terrorVector[ startIndex + 3 ][ 0 ] = tempQuat[ 0 ];\r\n\t\t\terrorVector[ startIndex + 4 ][ 0 ] = tempQuat[ 1 ];\r\n\t\t\terrorVector[ startIndex + 5 ][ 0 ] = tempQuat[ 2 ];\r\n\t\t\terrorVector[ startIndex + 6 ][ 0 ] = tempQuat[ 3 ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tresult.totalError = totalError;\r\n\tresult.isConverged = isConverged;\r\n\tresult.rowCount = rowCount;\r\n\treturn result;\r\n\r\n}\r\n\r\nexport function accumulateTargetError(\r\n\tsolver,\r\n\tjoint,\r\n\tstartIndex,\r\n\terrorVector = null,\r\n\tresult = { isConverged: false, rowCount: 7, totalError: 0 }\r\n) {\r\n\r\n\t// Find whether or not the target has converged or not\r\n\tconst {\r\n\t\ttranslationConvergeThreshold,\r\n\t\trotationConvergeThreshold,\r\n\t\tlockedJointDoFCount,\r\n\t\ttranslationErrorClamp,\r\n\t\trotationErrorClamp,\r\n\t\tlockedJointDoF,\r\n\t} = solver;\r\n\r\n\tconst {\r\n\t\tdofTarget,\r\n\t\tdofValues,\r\n\t\ttranslationDoFCount,\r\n\t\trotationDoFCount,\r\n\t\ttranslationFactor,\r\n\t\trotationFactor,\r\n\t\tdofList,\r\n\t} = joint;\r\n\r\n\t// get the position delta\r\n\tconst posDelta = vec3.distance( dofValues, dofTarget );\r\n\r\n\t// TODO: if three euler angles are being used we should set this to a quaternion to measure\r\n\t// error rather than euler angles. We should instead just always use quaternions for targets\r\n\t// for now.\r\n\t// Before running this solver we try to ensure the target and restPose are minimized\r\n\tlet rotDelta =\r\n\t\tdofTarget[ DOF.EX ] - dofValues[ DOF.EX ] +\r\n\t\tdofTarget[ DOF.EY ] - dofValues[ DOF.EY ] +\r\n\t\tdofTarget[ DOF.EZ ] - dofValues[ DOF.EZ ];\r\n\r\n\t// Get the row count\r\n\tconst lockedDoFCount = lockedJointDoFCount.get( joint ) || 0;\r\n\tresult.rowCount = translationDoFCount + rotationDoFCount - lockedDoFCount;\r\n\tresult.isConverged = posDelta < translationConvergeThreshold && rotDelta < rotationConvergeThreshold;\r\n\tresult.totalError = posDelta + rotDelta;\r\n\r\n\tif ( errorVector ) {\r\n\r\n\t\tconst lockedDoF = lockedJointDoF.get( joint );\r\n\t\tconst isLocked = lockedDoFCount !== 0;\r\n\r\n\t\tlet rowIndex = 0;\r\n\r\n\t\t// error from current state to target\r\n\t\ttempPos[ 0 ] = dofTarget[ 0 ] - dofValues[ 0 ];\r\n\t\ttempPos[ 1 ] = dofTarget[ 1 ] - dofValues[ 1 ];\r\n\t\ttempPos[ 2 ] = dofTarget[ 2 ] - dofValues[ 2 ];\r\n\r\n\t\t// clamp the position delta to the max error step\r\n\t\tconst posMag = vec3.length( tempPos );\r\n\t\tvec3.scale( tempPos, tempPos, translationFactor * translationErrorClamp / posMag );\r\n\t\tfor ( let i = 0, l = translationDoFCount; i < l; i ++ ) {\r\n\r\n\t\t\tconst dof = dofList[ i ];\r\n\r\n\t\t\t// skip this degree of freedom if it's locked\r\n\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\terrorVector[ startIndex + rowIndex ][ 0 ] = tempPos[ dof ];\r\n\t\t\trowIndex ++;\r\n\r\n\t\t}\r\n\r\n\t\t// get the euler differences\r\n\t\t// before running this solver we minimize the euler targets\r\n\t\ttempEuler[ 0 ] = joint.dofTarget[ 3 ] - joint.dofValues[ 3 ];\r\n\t\ttempEuler[ 1 ] = joint.dofTarget[ 4 ] - joint.dofValues[ 4 ];\r\n\t\ttempEuler[ 2 ] = joint.dofTarget[ 5 ] - joint.dofValues[ 5 ];\r\n\r\n\t\t// clamp the euler difference to the error step magnitude\r\n\t\tconst eulerMag = vec3.length( tempEuler );\r\n\t\tvec3.scale( tempEuler, tempEuler, rotationFactor * rotationErrorClamp / eulerMag );\r\n\t\tfor ( let i = translationDoFCount, l = translationDoFCount + rotationDoFCount; i < l; i ++ ) {\r\n\r\n\t\t\tconst dof = dofList[ i ];\r\n\r\n\t\t\t// skip this degree of freedom if it's locked\r\n\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\terrorVector[ startIndex + rowIndex ][ 0 ] = tempEuler[ dof ];\r\n\t\t\trowIndex ++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}