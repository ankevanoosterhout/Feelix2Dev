{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, broadcastTo, reshape, tidy, util } from '@tensorflow/tfjs-core';\nvar RowPartitionType = backend_util.RowPartitionType; // Based on\n// https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc\n\nclass RaggedTensorToTensorOp {\n  constructor(shape, shapeShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypeStrings) {\n    this.shape = shape;\n    this.shapeShape = shapeShape;\n    this.values = values;\n    this.valuesShape = valuesShape;\n    this.valuesDType = valuesDType;\n    this.defaultValue = defaultValue;\n    this.defaultValueShape = defaultValueShape;\n    this.rowPartitionValues = rowPartitionValues;\n    this.rowPartitionValuesShapes = rowPartitionValuesShapes;\n    this.rowPartitionTypes = backend_util.getRowPartitionTypesHelper(rowPartitionTypeStrings);\n    this.raggedRank = backend_util.getRaggedRank(this.rowPartitionTypes);\n  }\n\n  getRowPartitionTypeByDimension(dimension) {\n    if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n      return this.rowPartitionTypes[dimension + 1];\n    } else {\n      return this.rowPartitionTypes[dimension];\n    }\n  } // Returns the relationship between dimension and dimension + 1.\n\n\n  getRowPartitionTensor(dimension) {\n    if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n      return this.rowPartitionValues[dimension + 1];\n    } else {\n      return this.rowPartitionValues[dimension];\n    }\n  }\n\n  getMaxWidth(dimension) {\n    const rowPartitionTensor = this.getRowPartitionTensor(dimension - 1);\n\n    switch (this.getRowPartitionTypeByDimension(dimension - 1)) {\n      case RowPartitionType.VALUE_ROWIDS:\n        return RaggedTensorToTensorOp.getMaxWidthValueRowID(rowPartitionTensor);\n\n      case RowPartitionType.ROW_SPLITS:\n        return RaggedTensorToTensorOp.getMaxWidthRowSplit(rowPartitionTensor);\n\n      default:\n        throw new Error(`Cannot handle partition type ${RowPartitionType[this.getRowPartitionTypeByDimension(dimension - 1)]}`);\n    }\n  }\n\n  static getMaxWidthRowSplit(rowSplit) {\n    const tensorLength = rowSplit.length;\n\n    if (tensorLength === 0 || tensorLength === 1) {\n      return 0;\n    }\n\n    let maxWidth = 0;\n\n    for (let i = 0; i < tensorLength - 1; ++i) {\n      const currentWidth = rowSplit[i + 1] - rowSplit[i];\n\n      if (currentWidth > maxWidth) {\n        maxWidth = currentWidth;\n      }\n    }\n\n    return maxWidth;\n  }\n\n  static getMaxWidthValueRowID(valueRowIds) {\n    const indexLength = valueRowIds.length;\n\n    if (indexLength === 0) {\n      return 0;\n    }\n\n    let firstEqualIndex = 0;\n    let firstEqualIndexValue = valueRowIds[0];\n    let maxWidth = 0;\n\n    for (let i = 1; i < indexLength; ++i) {\n      const value = valueRowIds[i];\n\n      if (value !== firstEqualIndexValue) {\n        firstEqualIndexValue = value;\n        maxWidth = Math.max(i - firstEqualIndex, maxWidth);\n        firstEqualIndex = i;\n      }\n    }\n\n    return Math.max(indexLength - firstEqualIndex, maxWidth);\n  }\n\n  tensorShapeFromTensor(t, tShape, isPartial = true) {\n    if (tShape.length === 0) {\n      if (t[0] === -1) {\n        return [];\n      }\n\n      throw new Error(`The only valid scalar shape tensor is the fully unknown shape specified as -1.`);\n    } // MakePartialShape/MakeShapeHelper.\n\n\n    return makeShape(t, isPartial);\n  }\n\n  calculateOutputSize(firstDim) {\n    const valueShape = this.valuesShape;\n    const defaultValueShape = this.defaultValueShape;\n    backend_util.validateDefaultValueShape(defaultValueShape, valueShape);\n    const shape = this.tensorShapeFromTensor(this.shape, this.shapeShape);\n    const outputShape = backend_util.combineRaggedTensorToTensorShapes(this.raggedRank, shape, valueShape);\n    const result = outputShape;\n\n    if (result[0] < 0) {\n      result[0] = firstDim;\n    }\n\n    for (let i = 1; i <= this.raggedRank; ++i) {\n      if (result[i] < 0) {\n        result[i] = this.getMaxWidth(i);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * The outputIndex represents the index in the output tensor\n   * where the first element of a particular dimension would be written.\n   * If it is -1, it indicates that the index is out of scope.\n   * Example, given firstDimension = 10, firstDimensionOutput = 6,\n   * and outputIndexMultiplier = 100:\n   * result = [0 100 200 300 400 500 -1 -1 -1 -1]\n   * If firstDimensionOutput = 11 instead, then:\n   * result = [0 100 200 300 400 500 600 700 800 900]\n   */\n\n\n  calculateFirstParentOutputIndex(firstDimension, outputIndexMultiplier, firstDimensionOutput) {\n    const minDimension = Math.min(firstDimension, firstDimensionOutput);\n    const result = [];\n    let currentOutputIndex = 0;\n\n    for (let i = 0; i < minDimension; ++i, currentOutputIndex += outputIndexMultiplier) {\n      result.push(currentOutputIndex);\n    }\n\n    for (let i = minDimension; i < firstDimension; ++i) {\n      result.push(-1);\n    }\n\n    util.assert(result.length === firstDimension, () => 'Final length of result must be equal to firstDimension.');\n    return result;\n  }\n\n  calculateOutputIndexRowSplit(rowSplit, parentOutputIndex, outputIndexMultiplier, outputSize) {\n    const rowSplitSize = rowSplit.length;\n    const result = [];\n\n    for (let i = 0; i < rowSplitSize - 1; ++i) {\n      const rowLength = rowSplit[i + 1] - rowSplit[i];\n      let realLength = Math.min(outputSize, rowLength);\n      let parentOutputIndexCurrent = parentOutputIndex[i];\n\n      if (parentOutputIndexCurrent === -1) {\n        realLength = 0;\n      }\n\n      for (let j = 0; j < realLength; ++j) {\n        result.push(parentOutputIndexCurrent);\n        parentOutputIndexCurrent += outputIndexMultiplier;\n      }\n\n      for (let j = 0; j < rowLength - realLength; ++j) {\n        result.push(-1);\n      }\n    }\n\n    if (rowSplitSize > 0 && result.length !== rowSplit[rowSplitSize - 1]) {\n      throw new Error('Invalid row split size.');\n    }\n\n    return result;\n  } // Calculate the output index of the first element of a list.\n  // The parentOutputIndex is the same computation for the previous list.\n  // -1 indicates an element or list that is out of range.\n  // The outputIndexMultiplier is the number of output indices one moves\n  // forward for each column.\n  // E.g., given:\n  // valueRowIds:[0 1 2 2 2 3 5 5 6]\n  // parentOutputIndex:[1000 1100 2000 2100 -1 3000 4000]\n  // outputIndexMultiplier: 10\n  // outputSize: 2\n  // You get:\n  // result = [1000 1100 2000 2010 -1 2100 -1 -1 3000]\n  // result[0] = parentOutputIndex[valueRowIds[0]]\n  // result[1] = parentOutputIndex[valueRowIds[1]]\n  // result[2] = parentOutputIndex[valueRowIds[2]]\n  // result[3] = parentOutputIndex[valueRowIds[2] + 10]\n  // result[4] = -1 because it is the third element the size is 2.\n  // result[5] = parentOutputIndex[valueRowIds[3]]\n  // result[6] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n  // result[7] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n  // result[8] = parentOutputIndex[valueRowIds[7]]\n\n\n  calculateOutputIndexValueRowID(valueRowIds, parentOutputIndex, outputIndexMultiplier, outputSize) {\n    const indexSize = valueRowIds.length;\n    const result = [];\n\n    if (indexSize === 0) {\n      return [];\n    }\n\n    let currentOutputColumn = 0;\n    let currentValueRowId = valueRowIds[0];\n\n    if (currentValueRowId >= parentOutputIndex.length) {\n      throw new Error(`Got currentValueRowId=${currentValueRowId}, which is not less than ${parentOutputIndex.length}`);\n    }\n\n    let currentOutputIndex = parentOutputIndex[currentValueRowId];\n    result.push(currentOutputIndex);\n\n    for (let i = 1; i < indexSize; ++i) {\n      const nextValueRowId = valueRowIds[i];\n\n      if (nextValueRowId === currentValueRowId) {\n        if (currentOutputIndex >= 0) {\n          ++currentOutputColumn;\n\n          if (currentOutputColumn < outputSize) {\n            currentOutputIndex += outputIndexMultiplier;\n          } else {\n            currentOutputIndex = -1;\n          }\n        }\n      } else {\n        currentOutputColumn = 0;\n        currentValueRowId = nextValueRowId;\n\n        if (nextValueRowId >= parentOutputIndex.length) {\n          throw new Error(`Got nextValueRowId=${nextValueRowId} which is not less than ${parentOutputIndex.length}`);\n        }\n\n        currentOutputIndex = parentOutputIndex[nextValueRowId];\n      }\n\n      result.push(currentOutputIndex);\n    }\n\n    if (result.length !== valueRowIds.length) {\n      throw new Error('Invalid row ids.');\n    }\n\n    return result;\n  }\n\n  calculateOutputIndex(dimension, parentOutputIndex, outputIndexMultiplier, outputSize) {\n    const rowPartitionTensor = this.getRowPartitionTensor(dimension);\n    const partitionType = this.getRowPartitionTypeByDimension(dimension);\n\n    switch (partitionType) {\n      case RowPartitionType.VALUE_ROWIDS:\n        return this.calculateOutputIndexValueRowID(rowPartitionTensor, parentOutputIndex, outputIndexMultiplier, outputSize);\n\n      case RowPartitionType.ROW_SPLITS:\n        if (rowPartitionTensor.length - 1 > parentOutputIndex.length) {\n          throw new Error(`Row partition size is greater than output size: ${rowPartitionTensor.length - 1} > ${parentOutputIndex.length}`);\n        }\n\n        return this.calculateOutputIndexRowSplit(rowPartitionTensor, parentOutputIndex, outputIndexMultiplier, outputSize);\n\n      default:\n        throw new Error(`Unsupported partition type: ${RowPartitionType[partitionType]}`);\n    }\n  }\n\n  getFirstDimensionSize() {\n    const firstPartitionTensor = this.rowPartitionValues[0];\n\n    if (this.rowPartitionTypes.length === 0) {\n      throw new Error('No row_partition_types given.');\n    }\n\n    const firstPartitionType = this.rowPartitionTypes[0];\n\n    switch (firstPartitionType) {\n      case RowPartitionType.FIRST_DIM_SIZE:\n        return firstPartitionTensor[0];\n\n      case RowPartitionType.VALUE_ROWIDS:\n        throw new Error('Cannot handle VALUE_ROWIDS in first dimension.');\n\n      case RowPartitionType.ROW_SPLITS:\n        return this.rowPartitionValuesShapes[0][0] - 1;\n\n      default:\n        throw new Error(`Cannot handle type ${RowPartitionType[firstPartitionType]}`);\n    }\n  }\n\n  compute() {\n    const firstPartitionTensor = this.rowPartitionValues[0];\n\n    if (firstPartitionTensor.length <= 0) {\n      throw new Error('Invalid first partition input. ' + 'Tensor requires at least one element.');\n    }\n\n    const firstDimension = this.getFirstDimensionSize();\n    const outputSize = this.calculateOutputSize(firstDimension);\n    const multiplier = new Array(this.raggedRank + 1);\n    multiplier[multiplier.length - 1] = 1;\n\n    for (let i = multiplier.length - 2; i >= 0; --i) {\n      multiplier[i] = multiplier[i + 1] * outputSize[i + 1];\n    } // Full size of the tensor.\n\n\n    const outputShape = makeShape(outputSize, false);\n    const outputTensor = util.getArrayFromDType(this.valuesDType, util.sizeFromShape(outputShape));\n    const fullSize = multiplier[0] * outputSize[0];\n\n    if (fullSize > 0) {\n      let outputIndex = this.calculateFirstParentOutputIndex(firstDimension, multiplier[0], outputSize[0]);\n\n      for (let i = 1; i <= this.raggedRank; ++i) {\n        const newOutputIndex = this.calculateOutputIndex(i - 1, outputIndex, multiplier[i], outputSize[i]);\n        outputIndex = newOutputIndex;\n      }\n\n      this.setOutput(this.raggedRank, outputIndex, outputTensor, outputShape);\n    }\n\n    return [outputShape, outputTensor];\n  }\n\n  setOutput(raggedRank, outputIndex, outputTensor, outputShape) {\n    if (outputTensor.length === 0) {\n      return;\n    }\n\n    const valuesBase = this.values;\n    const outputBase = outputTensor;\n    let elementShape = outputShape.slice();\n    elementShape = elementShape.slice(raggedRank + 1);\n    const valueElementSize = util.sizeFromShape(elementShape);\n    const outputIndexSize = outputIndex.length; // Broadcast the default value to value_element_size.  (We can skip this\n    // if defaultValueTensor.size == 1, since we use fill when that's true.)\n\n    let defaultValue = this.defaultValue;\n\n    if (defaultValue.length !== valueElementSize && defaultValue.length !== 1) {\n      const srcShape = this.defaultValueShape;\n      tidy(() => {\n        const defaultValueTensor = reshape(defaultValue, srcShape);\n        const bCastDefault = broadcastTo(defaultValueTensor, elementShape);\n        defaultValue = bCastDefault.dataSync();\n      });\n    } // Loop through the outputIndex array, finding contiguous regions that\n    // should be copied.  Once we find the end of a contiguous region, copy it\n    // and add any necessary padding (with defaultValue).\n\n\n    let srcStart = 0; // Start of contiguous region (in values)\n\n    let dstStart = 0; // Destination for contiguous region (in output)\n\n    let dstEnd = 0; // Destination for contiguous region (in output)\n\n    for (let srcI = 0; srcI <= outputIndexSize; ++srcI) {\n      // dstI is the destination where the value at srcI should be copied.\n      let dstI = srcI < outputIndexSize ? outputIndex[srcI] : -1; // If we're still in a contiguous region, then update dstEnd go to the\n      // next srcI.\n\n      if (dstI === dstEnd) {\n        ++dstEnd;\n        continue;\n      } // We found the end of contiguous region.  This can be because we found\n      // a gap (dstI > dstEnd), or a source value that shouldn't be copied\n      // because it's out-of-bounds (dstI == -1), or the end of the tensor\n      // (dstI === -1).\n\n\n      if (dstStart < dstEnd) {\n        // Copy the contiguous region.\n        const src = valuesBase.subarray(srcStart * valueElementSize);\n        const dst = outputBase.subarray(dstStart * valueElementSize);\n        const nVals = (dstEnd - dstStart) * valueElementSize;\n        copyArray(dst, src, nVals);\n      } // Add any necessary padding (w/ defaultValue).\n\n\n      if (srcI >= outputIndexSize) {\n        // We reached the end of values: pad to the end of output.\n        const outputSize = outputTensor.length;\n        dstI = Math.floor(outputSize / valueElementSize);\n      }\n\n      if (dstI > dstEnd) {\n        if (this.defaultValue.length === 1) {\n          outputBase.subarray(dstEnd * valueElementSize, dstI * valueElementSize).fill(this.defaultValue[0]);\n          dstEnd = dstI;\n        } else {\n          while (dstI > dstEnd) {\n            const dst = outputBase.slice(dstEnd * valueElementSize);\n            copyArray(dst, defaultValue, valueElementSize);\n            ++dstEnd;\n          }\n        }\n      } // Update indices.\n\n\n      if (dstI < 0) {\n        // srcI should be skipped -- leave it out of the contiguous region.\n        srcStart = srcI + 1;\n        dstStart = dstEnd;\n      } else {\n        // srcI should be copied -- include it in the contiguous region.\n        srcStart = srcI;\n        dstStart = dstEnd;\n        dstEnd = dstStart + 1;\n      }\n    }\n  }\n\n}\n\nfunction copyArray(dst, src, size) {\n  for (let i = 0; i < size; i++) {\n    dst[i] = src[i];\n  }\n}\n\nfunction makeShape(shape, isPartial) {\n  const out = [];\n\n  for (let dim of shape) {\n    if (dim < 0) {\n      if (!isPartial) {\n        throw new Error(`Dimension ${dim} must be >= 0`);\n      }\n\n      if (dim < -1) {\n        throw new Error(`Dimension ${dim} must be >= -1`);\n      }\n\n      dim = -1;\n    }\n\n    out.push(dim);\n  }\n\n  return out;\n}\n\nexport function raggedTensorToTensorImpl(shape, shapesShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes) {\n  return new RaggedTensorToTensorOp(shape, shapesShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes).compute();\n}","map":{"version":3,"names":["backend_util","broadcastTo","reshape","tidy","util","RowPartitionType","RaggedTensorToTensorOp","constructor","shape","shapeShape","values","valuesShape","valuesDType","defaultValue","defaultValueShape","rowPartitionValues","rowPartitionValuesShapes","rowPartitionTypeStrings","rowPartitionTypes","getRowPartitionTypesHelper","raggedRank","getRaggedRank","getRowPartitionTypeByDimension","dimension","FIRST_DIM_SIZE","getRowPartitionTensor","getMaxWidth","rowPartitionTensor","VALUE_ROWIDS","getMaxWidthValueRowID","ROW_SPLITS","getMaxWidthRowSplit","Error","rowSplit","tensorLength","length","maxWidth","i","currentWidth","valueRowIds","indexLength","firstEqualIndex","firstEqualIndexValue","value","Math","max","tensorShapeFromTensor","t","tShape","isPartial","makeShape","calculateOutputSize","firstDim","valueShape","validateDefaultValueShape","outputShape","combineRaggedTensorToTensorShapes","result","calculateFirstParentOutputIndex","firstDimension","outputIndexMultiplier","firstDimensionOutput","minDimension","min","currentOutputIndex","push","assert","calculateOutputIndexRowSplit","parentOutputIndex","outputSize","rowSplitSize","rowLength","realLength","parentOutputIndexCurrent","j","calculateOutputIndexValueRowID","indexSize","currentOutputColumn","currentValueRowId","nextValueRowId","calculateOutputIndex","partitionType","getFirstDimensionSize","firstPartitionTensor","firstPartitionType","compute","multiplier","Array","outputTensor","getArrayFromDType","sizeFromShape","fullSize","outputIndex","newOutputIndex","setOutput","valuesBase","outputBase","elementShape","slice","valueElementSize","outputIndexSize","srcShape","defaultValueTensor","bCastDefault","dataSync","srcStart","dstStart","dstEnd","srcI","dstI","src","subarray","dst","nVals","copyArray","floor","fill","size","out","dim","raggedTensorToTensorImpl","shapesShape"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedTensorToTensor_impl.js"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, broadcastTo, reshape, tidy, util } from '@tensorflow/tfjs-core';\nvar RowPartitionType = backend_util.RowPartitionType;\n// Based on\n// https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc\nclass RaggedTensorToTensorOp {\n    constructor(shape, shapeShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypeStrings) {\n        this.shape = shape;\n        this.shapeShape = shapeShape;\n        this.values = values;\n        this.valuesShape = valuesShape;\n        this.valuesDType = valuesDType;\n        this.defaultValue = defaultValue;\n        this.defaultValueShape = defaultValueShape;\n        this.rowPartitionValues = rowPartitionValues;\n        this.rowPartitionValuesShapes = rowPartitionValuesShapes;\n        this.rowPartitionTypes =\n            backend_util.getRowPartitionTypesHelper(rowPartitionTypeStrings);\n        this.raggedRank = backend_util.getRaggedRank(this.rowPartitionTypes);\n    }\n    getRowPartitionTypeByDimension(dimension) {\n        if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n            return this.rowPartitionTypes[dimension + 1];\n        }\n        else {\n            return this.rowPartitionTypes[dimension];\n        }\n    }\n    // Returns the relationship between dimension and dimension + 1.\n    getRowPartitionTensor(dimension) {\n        if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n            return this.rowPartitionValues[dimension + 1];\n        }\n        else {\n            return this.rowPartitionValues[dimension];\n        }\n    }\n    getMaxWidth(dimension) {\n        const rowPartitionTensor = this.getRowPartitionTensor(dimension - 1);\n        switch (this.getRowPartitionTypeByDimension(dimension - 1)) {\n            case RowPartitionType.VALUE_ROWIDS:\n                return RaggedTensorToTensorOp.getMaxWidthValueRowID(rowPartitionTensor);\n            case RowPartitionType.ROW_SPLITS:\n                return RaggedTensorToTensorOp.getMaxWidthRowSplit(rowPartitionTensor);\n            default:\n                throw new Error(`Cannot handle partition type ${RowPartitionType[this.getRowPartitionTypeByDimension(dimension - 1)]}`);\n        }\n    }\n    static getMaxWidthRowSplit(rowSplit) {\n        const tensorLength = rowSplit.length;\n        if (tensorLength === 0 || tensorLength === 1) {\n            return 0;\n        }\n        let maxWidth = 0;\n        for (let i = 0; i < tensorLength - 1; ++i) {\n            const currentWidth = rowSplit[i + 1] - rowSplit[i];\n            if (currentWidth > maxWidth) {\n                maxWidth = currentWidth;\n            }\n        }\n        return maxWidth;\n    }\n    static getMaxWidthValueRowID(valueRowIds) {\n        const indexLength = valueRowIds.length;\n        if (indexLength === 0) {\n            return 0;\n        }\n        let firstEqualIndex = 0;\n        let firstEqualIndexValue = valueRowIds[0];\n        let maxWidth = 0;\n        for (let i = 1; i < indexLength; ++i) {\n            const value = valueRowIds[i];\n            if (value !== firstEqualIndexValue) {\n                firstEqualIndexValue = value;\n                maxWidth = Math.max(i - firstEqualIndex, maxWidth);\n                firstEqualIndex = i;\n            }\n        }\n        return Math.max(indexLength - firstEqualIndex, maxWidth);\n    }\n    tensorShapeFromTensor(t, tShape, isPartial = true) {\n        if (tShape.length === 0) {\n            if (t[0] === -1) {\n                return [];\n            }\n            throw new Error(`The only valid scalar shape tensor is the fully unknown shape specified as -1.`);\n        }\n        // MakePartialShape/MakeShapeHelper.\n        return makeShape(t, isPartial);\n    }\n    calculateOutputSize(firstDim) {\n        const valueShape = this.valuesShape;\n        const defaultValueShape = this.defaultValueShape;\n        backend_util.validateDefaultValueShape(defaultValueShape, valueShape);\n        const shape = this.tensorShapeFromTensor(this.shape, this.shapeShape);\n        const outputShape = backend_util.combineRaggedTensorToTensorShapes(this.raggedRank, shape, valueShape);\n        const result = outputShape;\n        if (result[0] < 0) {\n            result[0] = firstDim;\n        }\n        for (let i = 1; i <= this.raggedRank; ++i) {\n            if (result[i] < 0) {\n                result[i] = this.getMaxWidth(i);\n            }\n        }\n        return result;\n    }\n    /**\n     * The outputIndex represents the index in the output tensor\n     * where the first element of a particular dimension would be written.\n     * If it is -1, it indicates that the index is out of scope.\n     * Example, given firstDimension = 10, firstDimensionOutput = 6,\n     * and outputIndexMultiplier = 100:\n     * result = [0 100 200 300 400 500 -1 -1 -1 -1]\n     * If firstDimensionOutput = 11 instead, then:\n     * result = [0 100 200 300 400 500 600 700 800 900]\n     */\n    calculateFirstParentOutputIndex(firstDimension, outputIndexMultiplier, firstDimensionOutput) {\n        const minDimension = Math.min(firstDimension, firstDimensionOutput);\n        const result = [];\n        let currentOutputIndex = 0;\n        for (let i = 0; i < minDimension; ++i, currentOutputIndex += outputIndexMultiplier) {\n            result.push(currentOutputIndex);\n        }\n        for (let i = minDimension; i < firstDimension; ++i) {\n            result.push(-1);\n        }\n        util.assert(result.length === firstDimension, () => 'Final length of result must be equal to firstDimension.');\n        return result;\n    }\n    calculateOutputIndexRowSplit(rowSplit, parentOutputIndex, outputIndexMultiplier, outputSize) {\n        const rowSplitSize = rowSplit.length;\n        const result = [];\n        for (let i = 0; i < rowSplitSize - 1; ++i) {\n            const rowLength = rowSplit[i + 1] - rowSplit[i];\n            let realLength = Math.min(outputSize, rowLength);\n            let parentOutputIndexCurrent = parentOutputIndex[i];\n            if (parentOutputIndexCurrent === -1) {\n                realLength = 0;\n            }\n            for (let j = 0; j < realLength; ++j) {\n                result.push(parentOutputIndexCurrent);\n                parentOutputIndexCurrent += outputIndexMultiplier;\n            }\n            for (let j = 0; j < rowLength - realLength; ++j) {\n                result.push(-1);\n            }\n        }\n        if (rowSplitSize > 0 && result.length !== rowSplit[rowSplitSize - 1]) {\n            throw new Error('Invalid row split size.');\n        }\n        return result;\n    }\n    // Calculate the output index of the first element of a list.\n    // The parentOutputIndex is the same computation for the previous list.\n    // -1 indicates an element or list that is out of range.\n    // The outputIndexMultiplier is the number of output indices one moves\n    // forward for each column.\n    // E.g., given:\n    // valueRowIds:[0 1 2 2 2 3 5 5 6]\n    // parentOutputIndex:[1000 1100 2000 2100 -1 3000 4000]\n    // outputIndexMultiplier: 10\n    // outputSize: 2\n    // You get:\n    // result = [1000 1100 2000 2010 -1 2100 -1 -1 3000]\n    // result[0] = parentOutputIndex[valueRowIds[0]]\n    // result[1] = parentOutputIndex[valueRowIds[1]]\n    // result[2] = parentOutputIndex[valueRowIds[2]]\n    // result[3] = parentOutputIndex[valueRowIds[2] + 10]\n    // result[4] = -1 because it is the third element the size is 2.\n    // result[5] = parentOutputIndex[valueRowIds[3]]\n    // result[6] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n    // result[7] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n    // result[8] = parentOutputIndex[valueRowIds[7]]\n    calculateOutputIndexValueRowID(valueRowIds, parentOutputIndex, outputIndexMultiplier, outputSize) {\n        const indexSize = valueRowIds.length;\n        const result = [];\n        if (indexSize === 0) {\n            return [];\n        }\n        let currentOutputColumn = 0;\n        let currentValueRowId = valueRowIds[0];\n        if (currentValueRowId >= parentOutputIndex.length) {\n            throw new Error(`Got currentValueRowId=${currentValueRowId}, which is not less than ${parentOutputIndex.length}`);\n        }\n        let currentOutputIndex = parentOutputIndex[currentValueRowId];\n        result.push(currentOutputIndex);\n        for (let i = 1; i < indexSize; ++i) {\n            const nextValueRowId = valueRowIds[i];\n            if (nextValueRowId === currentValueRowId) {\n                if (currentOutputIndex >= 0) {\n                    ++currentOutputColumn;\n                    if (currentOutputColumn < outputSize) {\n                        currentOutputIndex += outputIndexMultiplier;\n                    }\n                    else {\n                        currentOutputIndex = -1;\n                    }\n                }\n            }\n            else {\n                currentOutputColumn = 0;\n                currentValueRowId = nextValueRowId;\n                if (nextValueRowId >= parentOutputIndex.length) {\n                    throw new Error(`Got nextValueRowId=${nextValueRowId} which is not less than ${parentOutputIndex.length}`);\n                }\n                currentOutputIndex = parentOutputIndex[nextValueRowId];\n            }\n            result.push(currentOutputIndex);\n        }\n        if (result.length !== valueRowIds.length) {\n            throw new Error('Invalid row ids.');\n        }\n        return result;\n    }\n    calculateOutputIndex(dimension, parentOutputIndex, outputIndexMultiplier, outputSize) {\n        const rowPartitionTensor = this.getRowPartitionTensor(dimension);\n        const partitionType = this.getRowPartitionTypeByDimension(dimension);\n        switch (partitionType) {\n            case RowPartitionType.VALUE_ROWIDS:\n                return this.calculateOutputIndexValueRowID(rowPartitionTensor, parentOutputIndex, outputIndexMultiplier, outputSize);\n            case RowPartitionType.ROW_SPLITS:\n                if (rowPartitionTensor.length - 1 > parentOutputIndex.length) {\n                    throw new Error(`Row partition size is greater than output size: ${rowPartitionTensor.length - 1} > ${parentOutputIndex.length}`);\n                }\n                return this.calculateOutputIndexRowSplit(rowPartitionTensor, parentOutputIndex, outputIndexMultiplier, outputSize);\n            default:\n                throw new Error(`Unsupported partition type: ${RowPartitionType[partitionType]}`);\n        }\n    }\n    getFirstDimensionSize() {\n        const firstPartitionTensor = this.rowPartitionValues[0];\n        if (this.rowPartitionTypes.length === 0) {\n            throw new Error('No row_partition_types given.');\n        }\n        const firstPartitionType = this.rowPartitionTypes[0];\n        switch (firstPartitionType) {\n            case RowPartitionType.FIRST_DIM_SIZE:\n                return firstPartitionTensor[0];\n            case RowPartitionType.VALUE_ROWIDS:\n                throw new Error('Cannot handle VALUE_ROWIDS in first dimension.');\n            case RowPartitionType.ROW_SPLITS:\n                return this.rowPartitionValuesShapes[0][0] - 1;\n            default:\n                throw new Error(`Cannot handle type ${RowPartitionType[firstPartitionType]}`);\n        }\n    }\n    compute() {\n        const firstPartitionTensor = this.rowPartitionValues[0];\n        if (firstPartitionTensor.length <= 0) {\n            throw new Error('Invalid first partition input. ' +\n                'Tensor requires at least one element.');\n        }\n        const firstDimension = this.getFirstDimensionSize();\n        const outputSize = this.calculateOutputSize(firstDimension);\n        const multiplier = new Array(this.raggedRank + 1);\n        multiplier[multiplier.length - 1] = 1;\n        for (let i = multiplier.length - 2; i >= 0; --i) {\n            multiplier[i] = multiplier[i + 1] * outputSize[i + 1];\n        }\n        // Full size of the tensor.\n        const outputShape = makeShape(outputSize, false);\n        const outputTensor = util.getArrayFromDType(this.valuesDType, util.sizeFromShape(outputShape));\n        const fullSize = multiplier[0] * outputSize[0];\n        if (fullSize > 0) {\n            let outputIndex = this.calculateFirstParentOutputIndex(firstDimension, multiplier[0], outputSize[0]);\n            for (let i = 1; i <= this.raggedRank; ++i) {\n                const newOutputIndex = this.calculateOutputIndex(i - 1, outputIndex, multiplier[i], outputSize[i]);\n                outputIndex = newOutputIndex;\n            }\n            this.setOutput(this.raggedRank, outputIndex, outputTensor, outputShape);\n        }\n        return [outputShape, outputTensor];\n    }\n    setOutput(raggedRank, outputIndex, outputTensor, outputShape) {\n        if (outputTensor.length === 0) {\n            return;\n        }\n        const valuesBase = this.values;\n        const outputBase = outputTensor;\n        let elementShape = outputShape.slice();\n        elementShape = elementShape.slice(raggedRank + 1);\n        const valueElementSize = util.sizeFromShape(elementShape);\n        const outputIndexSize = outputIndex.length;\n        // Broadcast the default value to value_element_size.  (We can skip this\n        // if defaultValueTensor.size == 1, since we use fill when that's true.)\n        let defaultValue = this.defaultValue;\n        if (defaultValue.length !== valueElementSize && defaultValue.length !== 1) {\n            const srcShape = this.defaultValueShape;\n            tidy(() => {\n                const defaultValueTensor = reshape(defaultValue, srcShape);\n                const bCastDefault = broadcastTo(defaultValueTensor, elementShape);\n                defaultValue = bCastDefault.dataSync();\n            });\n        }\n        // Loop through the outputIndex array, finding contiguous regions that\n        // should be copied.  Once we find the end of a contiguous region, copy it\n        // and add any necessary padding (with defaultValue).\n        let srcStart = 0; // Start of contiguous region (in values)\n        let dstStart = 0; // Destination for contiguous region (in output)\n        let dstEnd = 0; // Destination for contiguous region (in output)\n        for (let srcI = 0; srcI <= outputIndexSize; ++srcI) {\n            // dstI is the destination where the value at srcI should be copied.\n            let dstI = srcI < outputIndexSize ? outputIndex[srcI] : -1;\n            // If we're still in a contiguous region, then update dstEnd go to the\n            // next srcI.\n            if (dstI === dstEnd) {\n                ++dstEnd;\n                continue;\n            }\n            // We found the end of contiguous region.  This can be because we found\n            // a gap (dstI > dstEnd), or a source value that shouldn't be copied\n            // because it's out-of-bounds (dstI == -1), or the end of the tensor\n            // (dstI === -1).\n            if (dstStart < dstEnd) {\n                // Copy the contiguous region.\n                const src = valuesBase.subarray(srcStart * valueElementSize);\n                const dst = outputBase.subarray(dstStart * valueElementSize);\n                const nVals = (dstEnd - dstStart) * valueElementSize;\n                copyArray(dst, src, nVals);\n            }\n            // Add any necessary padding (w/ defaultValue).\n            if (srcI >= outputIndexSize) {\n                // We reached the end of values: pad to the end of output.\n                const outputSize = outputTensor.length;\n                dstI = Math.floor(outputSize / valueElementSize);\n            }\n            if (dstI > dstEnd) {\n                if (this.defaultValue.length === 1) {\n                    outputBase\n                        .subarray(dstEnd * valueElementSize, dstI * valueElementSize)\n                        .fill(this.defaultValue[0]);\n                    dstEnd = dstI;\n                }\n                else {\n                    while (dstI > dstEnd) {\n                        const dst = outputBase.slice(dstEnd * valueElementSize);\n                        copyArray(dst, defaultValue, valueElementSize);\n                        ++dstEnd;\n                    }\n                }\n            }\n            // Update indices.\n            if (dstI < 0) {\n                // srcI should be skipped -- leave it out of the contiguous region.\n                srcStart = srcI + 1;\n                dstStart = dstEnd;\n            }\n            else {\n                // srcI should be copied -- include it in the contiguous region.\n                srcStart = srcI;\n                dstStart = dstEnd;\n                dstEnd = dstStart + 1;\n            }\n        }\n    }\n}\nfunction copyArray(dst, src, size) {\n    for (let i = 0; i < size; i++) {\n        dst[i] = src[i];\n    }\n}\nfunction makeShape(shape, isPartial) {\n    const out = [];\n    for (let dim of shape) {\n        if (dim < 0) {\n            if (!isPartial) {\n                throw new Error(`Dimension ${dim} must be >= 0`);\n            }\n            if (dim < -1) {\n                throw new Error(`Dimension ${dim} must be >= -1`);\n            }\n            dim = -1;\n        }\n        out.push(dim);\n    }\n    return out;\n}\nexport function raggedTensorToTensorImpl(shape, shapesShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes) {\n    return new RaggedTensorToTensorOp(shape, shapesShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes)\n        .compute();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}