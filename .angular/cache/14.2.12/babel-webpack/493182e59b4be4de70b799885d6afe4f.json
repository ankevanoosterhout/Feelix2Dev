{"ast":null,"code":"import { mat4, quat } from 'gl-matrix';\nimport { Frame } from './Frame.js';\nimport { getClosestEulerRepresentation, toSmallestEulerValueDistance } from './utils/euler.js';\nimport { getEuler, getMatrixDifference } from './utils/glmatrix.js';\nimport { RAD2DEG, DEG2RAD } from './utils/constants.js'; // degrees of freedom axes\n\nexport const DOF = {\n  X: 0,\n  Y: 1,\n  Z: 2,\n  EX: 3,\n  EY: 4,\n  EZ: 5\n};\nexport const DOF_NAMES = Object.entries(DOF).sort((a, b) => a[1] - b[1]).map(e => e[0]);\nconst tempInverse = new Float32Array(16);\nconst tempMatrix = new Float32Array(16);\nconst tempQuat = new Float32Array(4);\nconst tempEuler = new Float32Array(3);\nconst tempValueEuler = new Float32Array(3);\nconst quatEuler = new Float32Array(3);\nconst tempDoFValues = new Float32Array(6); // generate a matrix from a set of degrees of freedom\n\nfunction dofToMatrix(out, dof) {\n  quat.fromEuler(tempQuat, dof[DOF.EX] * RAD2DEG, dof[DOF.EY] * RAD2DEG, dof[DOF.EZ] * RAD2DEG);\n  mat4.fromRotationTranslation(out, tempQuat, dof);\n}\n\nexport class Joint extends Frame {\n  constructor() {\n    super();\n    this.isJoint = true;\n    this.child = null;\n    this.isClosure = false;\n    this.trackJointWrap = false;\n    this.rotationDoFCount = 0;\n    this.translationDoFCount = 0; // TODO: should we make DoF Flags a bit mask flag?\n\n    this.dof = [];\n    this.dofFlags = new Uint8Array(6);\n    this.dofValues = new Float32Array(6);\n    this.dofTarget = new Float32Array(6);\n    this.dofRestPose = new Float32Array(6);\n    this.minDoFLimit = new Float32Array(6).fill(-Infinity);\n    this.maxDoFLimit = new Float32Array(6).fill(Infinity);\n    this.targetSet = false;\n    this.restPoseSet = false;\n    this.matrixDoFNeedsUpdate = false;\n    this.matrixDoF = new Float32Array(16);\n    mat4.identity(this.matrixDoF);\n    this.cachedIdentityDoFMatrixWorld = new Float32Array(16);\n    mat4.identity(this.cachedIdentityDoFMatrixWorld); // TODO: Consider affording control over rotation order\n    // TODO: Create pre built joint types\n  } // private helpers\n\n\n  _getQuaternion(target, outQuat) {\n    quat.fromEuler(outQuat, target[DOF.EX], target[DOF.EY], target[DOF.EZ]);\n  }\n\n  _getEuler(target, outEuler) {\n    outEuler[0] = target[DOF.EX];\n    outEuler[1] = target[DOF.EY];\n    outEuler[2] = target[DOF.EZ];\n  }\n\n  _getPosition(target, outPos) {\n    outPos[0] = target[DOF.X];\n    outPos[1] = target[DOF.Y];\n    outPos[2] = target[DOF.Z];\n  }\n\n  _setValue(target, dof, value) {\n    if (target === this.minDoFLimit || target == this.maxDoFLimit) {\n      throw new Error('Joint: Cannot set minDoFLimit or maxDoFLimit with _setValue.');\n    }\n\n    if (dof < 0 || dof > 6 || typeof dof !== 'number') {\n      throw new Error('Joint: Invalid DoF.');\n    }\n\n    if (!this.dofFlags[dof]) {\n      return false;\n    }\n\n    const minVal = this.minDoFLimit[dof];\n    const maxVal = this.maxDoFLimit[dof];\n\n    if (value < minVal) {\n      value = minVal;\n    }\n\n    if (value > maxVal) {\n      value = maxVal;\n    }\n\n    target[dof] = value;\n    return value === maxVal || value === minVal;\n  }\n\n  _setValues(target, values) {\n    const dof = this.dof;\n\n    for (let i = 0, l = values.length; i < l; i++) {\n      this._setValue(target, dof[i], values[i]);\n    }\n  } // TODO: these functions are unused\n\n\n  _setViaFullPosition(target, values) {\n    const dofFlags = this.dofFlags;\n\n    for (let i = 0; i < 3; i++) {\n      target[i] = dofFlags[i] * values[i];\n    }\n  }\n\n  _setViaFullEuler(target, values) {\n    const dofFlags = this.dofFlags;\n\n    for (let i = 3; i < 6; i++) {\n      target[i] = dofFlags[i] * values[i - 3];\n    }\n\n    this.tryMinimizeEulerAngles();\n  }\n\n  _setViaQuaternion(target, values) {\n    getEuler(quatEuler, values);\n    quatEuler[0] *= DEG2RAD;\n    quatEuler[1] *= DEG2RAD;\n    quatEuler[2] *= DEG2RAD;\n\n    if (this.trackJointWrap) {\n      // if we're tracking joint wrap then set this to be as close as possible to\n      // the current dof settings.\n      // TODO: How should restPose work here? Should it always be the shortest distance?\n      const dofValues = this.dofValues;\n      tempEuler[0] = dofValues[DOF.EX];\n      tempEuler[1] = dofValues[DOF.EY];\n      tempEuler[2] = dofValues[DOF.EZ];\n      getClosestEulerRepresentation(quatEuler, tempEuler, quatEuler);\n    }\n\n    this._setViaFullEuler(target, quatEuler);\n  } // Set the degrees of freedom\n\n\n  clearDoF() {\n    this.setDoF();\n  }\n\n  setDoF(...args) {\n    args.forEach((dof, i) => {\n      if (dof < 0 || dof >= 6) {\n        throw new Error('Joint: Invalid degree of freedom enum ' + dof + '.');\n      }\n\n      if (args.includes(dof, i + 1)) {\n        throw new Error('Joint: Duplicate degree of freedom ' + DOF_NAMES[dof] + 'specified.');\n      }\n\n      if (i !== 0 && args[i - 1] > dof) {\n        throw new Error('Joint: Joints degrees of freedom must be specified in position then rotation, XYZ order');\n      }\n    });\n    this.dof = args;\n    this.dofValues.fill(0);\n    this.dofTarget.fill(0);\n    this.dofRestPose.fill(0);\n    this.minDoFLimit.fill(-Infinity);\n    this.maxDoFLimit.fill(Infinity);\n    this.setMatrixDoFNeedsUpdate();\n\n    for (let i = 0; i < 6; i++) {\n      this.dofFlags[i] = Number(args.includes(i));\n    }\n\n    this.rotationDoFCount = this.dofFlags[DOF.EX] + this.dofFlags[DOF.EY] + this.dofFlags[DOF.EZ];\n    this.translationDoFCount = this.dofFlags[DOF.X] + this.dofFlags[DOF.Y] + this.dofFlags[DOF.Z];\n  } // Get and set the values of the different degrees of freedom\n\n\n  setDoFValues(...values) {\n    this.setMatrixDoFNeedsUpdate();\n\n    this._setValues(this.dofValues, values);\n  }\n\n  setDoFValue(dof, value) {\n    this.setMatrixDoFNeedsUpdate();\n    return this._setValue(this.dofValues, dof, value);\n  }\n\n  getDoFValue(dof) {\n    return this.dofValues[dof];\n  }\n\n  getDoFQuaternion(outQuat) {\n    this._getQuaternion(this.dofValues, outQuat);\n  }\n\n  getDoFEuler(outEuler) {\n    this._getEuler(this.dofValues, outEuler);\n  }\n\n  getDoFPosition(outPos) {\n    this._getPosition(this.dofValues, outPos);\n  } // Get and set the restPose values of the different degrees of freedom\n\n\n  setRestPoseValues(...values) {\n    this._setValues(this.dofRestPose, values);\n  }\n\n  setRestPoseValue(dof, value) {\n    return this._setValue(this.dofRestPose, dof, value);\n  }\n\n  getRestPoseValue(dof) {\n    return this.dofRestPose[dof];\n  }\n\n  getRestPoseQuaternion(outQuat) {\n    this._getQuaternion(this.dofRestPose, outQuat);\n  }\n\n  getRestPoseEuler(outEuler) {\n    this._getEuler(this.dofRestPose, outEuler);\n  }\n\n  getRestPosePosition(outPos) {\n    this._getPosition(this.dofRestPose, outPos);\n  } // Get and set the restPose values of the different degrees of freedom\n\n\n  setTargetValues(...values) {\n    this._setValues(this.dofTarget, values);\n  }\n\n  setTargetValue(dof, value) {\n    this._setValue(this.dofTarget, dof, value);\n  }\n\n  getTargetValue(dof) {\n    return this.dofTarget[dof];\n  }\n\n  getTargetQuaternion(outQuat) {\n    this._getQuaternion(this.dofTarget, outQuat);\n  }\n\n  getTargetEuler(outEuler) {\n    this._getEuler(this.dofTarget, outEuler);\n  }\n\n  getTargetPosition(outPos) {\n    this._getPosition(this.dofTarget, outPos);\n  } // Joint Limits\n\n\n  setMinLimits(...values) {\n    const {\n      dof\n    } = this;\n\n    for (const i in values) {\n      const d = dof[i];\n      this.setMinLimit(d, values[i]);\n    }\n  }\n\n  setMinLimit(dof, value) {\n    this.minDoFLimit[dof] = value;\n    this.setDoFValue(dof, this.dofValues[dof]);\n  }\n\n  getMinLimit(dof) {\n    return this.minDoFLimit[dof];\n  }\n\n  setMaxLimits(...values) {\n    const {\n      dof\n    } = this;\n\n    for (const i in values) {\n      const d = dof[i];\n      this.setMaxLimit(d, values[i]);\n    }\n  }\n\n  setMaxLimit(dof, value) {\n    this.maxDoFLimit[dof] = value;\n    this.setDoFValue(dof, this.dofValues[dof]);\n  }\n\n  getMaxLimit(dof) {\n    return this.maxDoFLimit[dof];\n  } // Returns the error between this joint and the next link if this is a closure.\n  // TODO: remove this and put it in solver\n\n\n  getClosureError(outPos, outQuat) {\n    if (!this.isClosure) {\n      throw new Error('Joint: Cannot get closure error on non closure Joint.');\n    }\n\n    this.updateMatrixWorld();\n    this.child.updateMatrixWorld(); // error from this position to child\n\n    getMatrixDifference(this.matrixWorld, this.child.matrixWorld, outPos, outQuat);\n  } // Update matrix overrides\n  // TODO: it might be best if we skip this and try to characterize joint error with quats in\n  // the error vector\n\n\n  tryMinimizeEulerAngles() {\n    const {\n      trackJointWrap,\n      rotationDoFCount,\n      dofRestPose,\n      dofTarget,\n      dofValues\n    } = this;\n\n    if (!trackJointWrap) {\n      if (rotationDoFCount < 3) {\n        for (let i = DOF.EX; i <= DOF.EZ; i++) {\n          dofTarget[i] = toSmallestEulerValueDistance(dofValues[i], dofTarget[i]);\n          dofRestPose[i] = toSmallestEulerValueDistance(dofValues[i], dofRestPose[i]);\n        }\n      } else {\n        tempValueEuler[0] = dofValues[DOF.EX];\n        tempValueEuler[1] = dofValues[DOF.EY];\n        tempValueEuler[2] = dofValues[DOF.EZ]; // update target\n\n        tempEuler[0] = dofTarget[DOF.EX];\n        tempEuler[1] = dofTarget[DOF.EY];\n        tempEuler[2] = dofTarget[DOF.EZ];\n        getClosestEulerRepresentation(tempEuler, tempValueEuler, tempEuler);\n        dofTarget[DOF.EX] = tempEuler[0];\n        dofTarget[DOF.EY] = tempEuler[1];\n        dofTarget[DOF.EZ] = tempEuler[2]; // update restPose\n\n        tempEuler[0] = dofRestPose[DOF.EX];\n        tempEuler[1] = dofRestPose[DOF.EY];\n        tempEuler[2] = dofRestPose[DOF.EZ];\n        getClosestEulerRepresentation(tempEuler, tempValueEuler, tempEuler);\n        dofRestPose[DOF.EX] = tempEuler[0];\n        dofRestPose[DOF.EY] = tempEuler[1];\n        dofRestPose[DOF.EZ] = tempEuler[2];\n      }\n    }\n  }\n\n  getDeltaWorldMatrix(dof, delta, outMatrix) {\n    const {\n      dofValues,\n      minDoFLimit,\n      maxDoFLimit,\n      cachedIdentityDoFMatrixWorld\n    } = this;\n    this.updateMatrixWorld(); // copy out set of dof values\n\n    tempDoFValues.set(dofValues); // get the state\n\n    const min = minDoFLimit[dof];\n    const max = maxDoFLimit[dof];\n    const currVal = tempDoFValues[dof]; // check what our slack is\n\n    const minSlack = currVal - min;\n    const maxSlack = max - currVal; // If we're constrained by either limit then move in the other direction then\n    // use the direction with the most slack.\n\n    let newVal = currVal + delta;\n    const isMaxConstrained = delta > 0 && newVal > max;\n    const isMinConstrained = delta < 0 && newVal < min;\n    const doInvert = isMaxConstrained && minSlack > maxSlack || isMinConstrained && maxSlack > minSlack;\n\n    if (doInvert) {\n      newVal = currVal - delta;\n    } // update our dof array and compute the matrix\n\n\n    tempDoFValues[dof] = newVal;\n    dofToMatrix(tempMatrix, tempDoFValues);\n    mat4.multiply(outMatrix, cachedIdentityDoFMatrixWorld, tempMatrix);\n    return doInvert;\n  } // matrix updates\n\n\n  setMatrixDoFNeedsUpdate() {\n    if (this.matrixDoFNeedsUpdate === false) {\n      this.matrixDoFNeedsUpdate = true;\n      this.setMatrixWorldNeedsUpdate();\n    }\n  }\n\n  updateDoFMatrix() {\n    if (this.matrixDoFNeedsUpdate) {\n      dofToMatrix(this.matrixDoF, this.dofValues);\n      this.matrixDoFNeedsUpdate = false;\n    }\n  }\n\n  computeMatrixWorld() {\n    const {\n      parent,\n      matrixWorld,\n      matrix,\n      matrixDoF,\n      cachedIdentityDoFMatrixWorld\n    } = this;\n    this.updateDoFMatrix();\n    mat4.multiply(matrixWorld, matrix, matrixDoF);\n\n    if (parent) {\n      mat4.multiply(matrixWorld, parent.matrixWorld, matrixWorld);\n      mat4.multiply(cachedIdentityDoFMatrixWorld, parent.matrixWorld, matrix);\n    } else {\n      mat4.copy(cachedIdentityDoFMatrixWorld, matrix);\n    }\n  } // Add child overrides\n\n\n  makeClosure(child) {\n    if (!child.isLink || this.child || child.parent === this) {\n      throw new Error('Joint: Given child cannot be used to make closure.');\n    } else {\n      // don't store the closure child in the children array to avoid\n      // implicit traversal.\n      this.child = child;\n      this.isClosure = true;\n      child.closureJoints.push(this);\n    }\n  }\n\n  addChild(child) {\n    if (!child.isLink || this.child || child.parent === this) {\n      throw new Error('Joint: Given child cannot be added to Joint.');\n    } else {\n      super.addChild(child);\n      this.child = child;\n      this.isClosure = false;\n    }\n  }\n\n  removeChild(child) {\n    if (this.isClosure) {\n      if (this.child !== child) {\n        throw new Error('Frame: Child to be removed is not a child of this Joint.');\n      } else {\n        this.child = null;\n        this.isClosure = false;\n        const index = child.closureJoints.indexOf(this);\n        child.closureJoints.splice(index, 1);\n      }\n    } else {\n      super.removeChild(child);\n    }\n  }\n\n  attachChild(child) {\n    super.attachChild(child); // remove the dof rotation afterward\n\n    mat4.invert(tempInverse, this.matrixDoF);\n    mat4.multiply(child.matrix, tempInverse, child.matrix);\n    mat4.getTranslation(child.position, child.matrix);\n    mat4.getRotation(child.quaternion, child.matrix);\n  }\n\n  detachChild(child) {\n    super.detachChild(child); // remove the dof rotation afterward\n\n    mat4.invert(tempInverse, this.matrixDoF);\n    mat4.multiply(child.matrix, tempInverse, child.matrix);\n    mat4.getTranslation(child.position, child.matrix);\n    mat4.getRotation(child.quaternion, child.matrix);\n  }\n\n}","map":{"version":3,"names":["mat4","quat","Frame","getClosestEulerRepresentation","toSmallestEulerValueDistance","getEuler","getMatrixDifference","RAD2DEG","DEG2RAD","DOF","X","Y","Z","EX","EY","EZ","DOF_NAMES","Object","entries","sort","a","b","map","e","tempInverse","Float32Array","tempMatrix","tempQuat","tempEuler","tempValueEuler","quatEuler","tempDoFValues","dofToMatrix","out","dof","fromEuler","fromRotationTranslation","Joint","constructor","isJoint","child","isClosure","trackJointWrap","rotationDoFCount","translationDoFCount","dofFlags","Uint8Array","dofValues","dofTarget","dofRestPose","minDoFLimit","fill","Infinity","maxDoFLimit","targetSet","restPoseSet","matrixDoFNeedsUpdate","matrixDoF","identity","cachedIdentityDoFMatrixWorld","_getQuaternion","target","outQuat","_getEuler","outEuler","_getPosition","outPos","_setValue","value","Error","minVal","maxVal","_setValues","values","i","l","length","_setViaFullPosition","_setViaFullEuler","tryMinimizeEulerAngles","_setViaQuaternion","clearDoF","setDoF","args","forEach","includes","setMatrixDoFNeedsUpdate","Number","setDoFValues","setDoFValue","getDoFValue","getDoFQuaternion","getDoFEuler","getDoFPosition","setRestPoseValues","setRestPoseValue","getRestPoseValue","getRestPoseQuaternion","getRestPoseEuler","getRestPosePosition","setTargetValues","setTargetValue","getTargetValue","getTargetQuaternion","getTargetEuler","getTargetPosition","setMinLimits","d","setMinLimit","getMinLimit","setMaxLimits","setMaxLimit","getMaxLimit","getClosureError","updateMatrixWorld","matrixWorld","getDeltaWorldMatrix","delta","outMatrix","set","min","max","currVal","minSlack","maxSlack","newVal","isMaxConstrained","isMinConstrained","doInvert","multiply","setMatrixWorldNeedsUpdate","updateDoFMatrix","computeMatrixWorld","parent","matrix","copy","makeClosure","isLink","closureJoints","push","addChild","removeChild","index","indexOf","splice","attachChild","invert","getTranslation","position","getRotation","quaternion","detachChild"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/closed-chain-ik/src/core/Joint.js"],"sourcesContent":["import { mat4, quat } from 'gl-matrix';\r\nimport { Frame } from './Frame.js';\r\nimport { getClosestEulerRepresentation, toSmallestEulerValueDistance } from './utils/euler.js';\r\nimport { getEuler, getMatrixDifference } from './utils/glmatrix.js';\r\nimport { RAD2DEG, DEG2RAD } from './utils/constants.js';\r\n\r\n// degrees of freedom axes\r\nexport const DOF = {\r\n\tX: 0,\r\n\tY: 1,\r\n\tZ: 2,\r\n\tEX: 3,\r\n\tEY: 4,\r\n\tEZ: 5,\r\n};\r\n\r\nexport const DOF_NAMES = Object.entries( DOF ).sort( ( a, b ) => a[ 1 ] - b[ 1 ] ).map( e => e[ 0 ] );\r\n\r\nconst tempInverse = new Float32Array( 16 );\r\nconst tempMatrix = new Float32Array( 16 );\r\nconst tempQuat = new Float32Array( 4 );\r\nconst tempEuler = new Float32Array( 3 );\r\nconst tempValueEuler = new Float32Array( 3 );\r\nconst quatEuler = new Float32Array( 3 );\r\nconst tempDoFValues = new Float32Array( 6 );\r\n\r\n// generate a matrix from a set of degrees of freedom\r\nfunction dofToMatrix( out, dof ) {\r\n\r\n\tquat.fromEuler( tempQuat, dof[ DOF.EX ] * RAD2DEG, dof[ DOF.EY ] * RAD2DEG, dof[ DOF.EZ ] * RAD2DEG );\r\n\tmat4.fromRotationTranslation( out, tempQuat, dof );\r\n\r\n}\r\n\r\nexport class Joint extends Frame {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\t\tthis.isJoint = true;\r\n\r\n\t\tthis.child = null;\r\n\t\tthis.isClosure = false;\r\n\r\n\t\tthis.trackJointWrap = false;\r\n\t\tthis.rotationDoFCount = 0;\r\n\t\tthis.translationDoFCount = 0;\r\n\r\n\t\t// TODO: should we make DoF Flags a bit mask flag?\r\n\t\tthis.dof = [];\r\n\t\tthis.dofFlags = new Uint8Array( 6 );\r\n\t\tthis.dofValues = new Float32Array( 6 );\r\n\t\tthis.dofTarget = new Float32Array( 6 );\r\n\t\tthis.dofRestPose = new Float32Array( 6 );\r\n\r\n\t\tthis.minDoFLimit = new Float32Array( 6 ).fill( - Infinity );\r\n\t\tthis.maxDoFLimit = new Float32Array( 6 ).fill( Infinity );\r\n\r\n\t\tthis.targetSet = false;\r\n\t\tthis.restPoseSet = false;\r\n\r\n\t\tthis.matrixDoFNeedsUpdate = false;\r\n\t\tthis.matrixDoF = new Float32Array( 16 );\r\n\t\tmat4.identity( this.matrixDoF );\r\n\r\n\t\tthis.cachedIdentityDoFMatrixWorld = new Float32Array( 16 );\r\n\t\tmat4.identity( this.cachedIdentityDoFMatrixWorld );\r\n\r\n\t\t// TODO: Consider affording control over rotation order\r\n\t\t// TODO: Create pre built joint types\r\n\r\n\t}\r\n\r\n\t// private helpers\r\n\t_getQuaternion( target, outQuat ) {\r\n\r\n\t\tquat.fromEuler( outQuat, target[ DOF.EX ], target[ DOF.EY ], target[ DOF.EZ ] );\r\n\r\n\t}\r\n\r\n\t_getEuler( target, outEuler ) {\r\n\r\n\t\toutEuler[ 0 ] = target[ DOF.EX ];\r\n\t\toutEuler[ 1 ] = target[ DOF.EY ];\r\n\t\toutEuler[ 2 ] = target[ DOF.EZ ];\r\n\r\n\t}\r\n\r\n\t_getPosition( target, outPos ) {\r\n\r\n\t\toutPos[ 0 ] = target[ DOF.X ];\r\n\t\toutPos[ 1 ] = target[ DOF.Y ];\r\n\t\toutPos[ 2 ] = target[ DOF.Z ];\r\n\r\n\t}\r\n\r\n\t_setValue( target, dof, value ) {\r\n\r\n\t\tif ( target === this.minDoFLimit || target == this.maxDoFLimit ) {\r\n\r\n\t\t\tthrow new Error( 'Joint: Cannot set minDoFLimit or maxDoFLimit with _setValue.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dof < 0 || dof > 6 || typeof dof !== 'number' ) {\r\n\r\n\t\t\tthrow new Error( 'Joint: Invalid DoF.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! this.dofFlags[ dof ] ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\tconst minVal = this.minDoFLimit[ dof ];\r\n\t\tconst maxVal = this.maxDoFLimit[ dof ];\r\n\r\n\t\tif ( value < minVal ) {\r\n\r\n\t\t\tvalue = minVal;\r\n\r\n\t\t}\r\n\r\n\t\tif ( value > maxVal ) {\r\n\r\n\t\t\tvalue = maxVal;\r\n\r\n\t\t}\r\n\r\n\t\ttarget[ dof ] = value;\r\n\t\treturn value === maxVal || value === minVal;\r\n\r\n\t}\r\n\r\n\t_setValues( target, values ) {\r\n\r\n\t\tconst dof = this.dof;\r\n\t\tfor ( let i = 0, l = values.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis._setValue( target, dof[ i ], values[ i ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// TODO: these functions are unused\r\n\t_setViaFullPosition( target, values ) {\r\n\r\n\t\tconst dofFlags = this.dofFlags;\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\ttarget[ i ] = dofFlags[ i ] * values[ i ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_setViaFullEuler( target, values ) {\r\n\r\n\t\tconst dofFlags = this.dofFlags;\r\n\t\tfor ( let i = 3; i < 6; i ++ ) {\r\n\r\n\t\t\ttarget[ i ] = dofFlags[ i ] * values[ i - 3 ];\r\n\r\n\t\t}\r\n\r\n\t\tthis.tryMinimizeEulerAngles();\r\n\r\n\t}\r\n\r\n\t_setViaQuaternion( target, values ) {\r\n\r\n\t\tgetEuler( quatEuler, values );\r\n\t\tquatEuler[ 0 ] *= DEG2RAD;\r\n\t\tquatEuler[ 1 ] *= DEG2RAD;\r\n\t\tquatEuler[ 2 ] *= DEG2RAD;\r\n\r\n\t\tif ( this.trackJointWrap ) {\r\n\r\n\t\t\t// if we're tracking joint wrap then set this to be as close as possible to\r\n\t\t\t// the current dof settings.\r\n\t\t\t// TODO: How should restPose work here? Should it always be the shortest distance?\r\n\t\t\tconst dofValues = this.dofValues;\r\n\t\t\ttempEuler[ 0 ] = dofValues[ DOF.EX ];\r\n\t\t\ttempEuler[ 1 ] = dofValues[ DOF.EY ];\r\n\t\t\ttempEuler[ 2 ] = dofValues[ DOF.EZ ];\r\n\t\t\tgetClosestEulerRepresentation( quatEuler, tempEuler, quatEuler );\r\n\r\n\t\t}\r\n\r\n\t\tthis._setViaFullEuler( target, quatEuler );\r\n\r\n\t}\r\n\r\n\t// Set the degrees of freedom\r\n\tclearDoF() {\r\n\r\n\t\tthis.setDoF();\r\n\r\n\t}\r\n\r\n\tsetDoF( ...args ) {\r\n\r\n\t\targs.forEach( ( dof, i ) => {\r\n\r\n\t\t\tif ( dof < 0 || dof >= 6 ) {\r\n\r\n\t\t\t\tthrow new Error( 'Joint: Invalid degree of freedom enum ' + dof + '.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( args.includes( dof, i + 1 ) ) {\r\n\r\n\t\t\t\tthrow new Error( 'Joint: Duplicate degree of freedom ' + DOF_NAMES[ dof ] + 'specified.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( i !== 0 && args[ i - 1 ] > dof ) {\r\n\r\n\t\t\t\tthrow new Error( 'Joint: Joints degrees of freedom must be specified in position then rotation, XYZ order' );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tthis.dof = args;\r\n\t\tthis.dofValues.fill( 0 );\r\n\t\tthis.dofTarget.fill( 0 );\r\n\t\tthis.dofRestPose.fill( 0 );\r\n\r\n\t\tthis.minDoFLimit.fill( - Infinity );\r\n\t\tthis.maxDoFLimit.fill( Infinity );\r\n\t\tthis.setMatrixDoFNeedsUpdate();\r\n\r\n\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tthis.dofFlags[ i ] = Number( args.includes( i ) );\r\n\r\n\t\t}\r\n\r\n\t\tthis.rotationDoFCount =\r\n\t\t\tthis.dofFlags[ DOF.EX ] +\r\n\t\t\tthis.dofFlags[ DOF.EY ] +\r\n\t\t\tthis.dofFlags[ DOF.EZ ];\r\n\t\tthis.translationDoFCount =\r\n\t\t\tthis.dofFlags[ DOF.X ] +\r\n\t\t\tthis.dofFlags[ DOF.Y ] +\r\n\t\t\tthis.dofFlags[ DOF.Z ];\r\n\r\n\t}\r\n\r\n\t// Get and set the values of the different degrees of freedom\r\n\tsetDoFValues( ...values ) {\r\n\r\n\t\tthis.setMatrixDoFNeedsUpdate();\r\n\t\tthis._setValues( this.dofValues, values );\r\n\r\n\t}\r\n\r\n\tsetDoFValue( dof, value ) {\r\n\r\n\t\tthis.setMatrixDoFNeedsUpdate();\r\n\t\treturn this._setValue( this.dofValues, dof, value );\r\n\r\n\t}\r\n\r\n\tgetDoFValue( dof ) {\r\n\r\n\t\treturn this.dofValues[ dof ];\r\n\r\n\t}\r\n\r\n\tgetDoFQuaternion( outQuat ) {\r\n\r\n\t\tthis._getQuaternion( this.dofValues, outQuat );\r\n\r\n\t}\r\n\r\n\tgetDoFEuler( outEuler ) {\r\n\r\n\t\tthis._getEuler( this.dofValues, outEuler );\r\n\r\n\t}\r\n\r\n\tgetDoFPosition( outPos ) {\r\n\r\n\t\tthis._getPosition( this.dofValues, outPos );\r\n\r\n\t}\r\n\r\n\t// Get and set the restPose values of the different degrees of freedom\r\n\tsetRestPoseValues( ...values ) {\r\n\r\n\t\tthis._setValues( this.dofRestPose, values );\r\n\r\n\t}\r\n\r\n\tsetRestPoseValue( dof, value ) {\r\n\r\n\t\treturn this._setValue( this.dofRestPose, dof, value );\r\n\r\n\t}\r\n\r\n\tgetRestPoseValue( dof ) {\r\n\r\n\t\treturn this.dofRestPose[ dof ];\r\n\r\n\t}\r\n\r\n\tgetRestPoseQuaternion( outQuat ) {\r\n\r\n\t\tthis._getQuaternion( this.dofRestPose, outQuat );\r\n\r\n\t}\r\n\r\n\tgetRestPoseEuler( outEuler ) {\r\n\r\n\t\tthis._getEuler( this.dofRestPose, outEuler );\r\n\r\n\t}\r\n\r\n\tgetRestPosePosition( outPos ) {\r\n\r\n\t\tthis._getPosition( this.dofRestPose, outPos );\r\n\r\n\t}\r\n\r\n\t// Get and set the restPose values of the different degrees of freedom\r\n\tsetTargetValues( ...values ) {\r\n\r\n\t\tthis._setValues( this.dofTarget, values );\r\n\r\n\t}\r\n\r\n\tsetTargetValue( dof, value ) {\r\n\r\n\t\tthis._setValue( this.dofTarget, dof, value );\r\n\r\n\t}\r\n\r\n\tgetTargetValue( dof ) {\r\n\r\n\t\treturn this.dofTarget[ dof ];\r\n\r\n\t}\r\n\r\n\tgetTargetQuaternion( outQuat ) {\r\n\r\n\t\tthis._getQuaternion( this.dofTarget, outQuat );\r\n\r\n\t}\r\n\r\n\tgetTargetEuler( outEuler ) {\r\n\r\n\t\tthis._getEuler( this.dofTarget, outEuler );\r\n\r\n\t}\r\n\r\n\tgetTargetPosition( outPos ) {\r\n\r\n\t\tthis._getPosition( this.dofTarget, outPos );\r\n\r\n\t}\r\n\r\n\t// Joint Limits\r\n\tsetMinLimits( ...values ) {\r\n\r\n\t\tconst { dof } = this;\r\n\t\tfor ( const i in values ) {\r\n\r\n\t\t\tconst d = dof[ i ];\r\n\t\t\tthis.setMinLimit( d, values[ i ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tsetMinLimit( dof, value ) {\r\n\r\n\t\tthis.minDoFLimit[ dof ] = value;\r\n\t\tthis.setDoFValue( dof, this.dofValues[ dof ] );\r\n\r\n\t}\r\n\r\n\tgetMinLimit( dof ) {\r\n\r\n\t\treturn this.minDoFLimit[ dof ];\r\n\r\n\t}\r\n\r\n\tsetMaxLimits( ...values ) {\r\n\r\n\t\tconst { dof } = this;\r\n\t\tfor ( const i in values ) {\r\n\r\n\t\t\tconst d = dof[ i ];\r\n\t\t\tthis.setMaxLimit( d, values[ i ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tsetMaxLimit( dof, value ) {\r\n\r\n\t\tthis.maxDoFLimit[ dof ] = value;\r\n\t\tthis.setDoFValue( dof, this.dofValues[ dof ] );\r\n\r\n\t}\r\n\r\n\tgetMaxLimit( dof ) {\r\n\r\n\t\treturn this.maxDoFLimit[ dof ];\r\n\r\n\t}\r\n\r\n\t// Returns the error between this joint and the next link if this is a closure.\r\n\t// TODO: remove this and put it in solver\r\n\tgetClosureError( outPos, outQuat ) {\r\n\r\n\t\tif ( ! this.isClosure ) {\r\n\r\n\t\t\tthrow new Error( 'Joint: Cannot get closure error on non closure Joint.' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.updateMatrixWorld();\r\n\t\tthis.child.updateMatrixWorld();\r\n\r\n\t\t// error from this position to child\r\n\t\tgetMatrixDifference( this.matrixWorld, this.child.matrixWorld, outPos, outQuat );\r\n\r\n\t}\r\n\r\n\t// Update matrix overrides\r\n\t// TODO: it might be best if we skip this and try to characterize joint error with quats in\r\n\t// the error vector\r\n\ttryMinimizeEulerAngles() {\r\n\r\n\t\tconst {\r\n\t\t\ttrackJointWrap,\r\n\t\t\trotationDoFCount,\r\n\t\t\tdofRestPose,\r\n\t\t\tdofTarget,\r\n\t\t\tdofValues,\r\n\t\t} = this;\r\n\r\n\t\tif ( ! trackJointWrap ) {\r\n\r\n\t\t\tif ( rotationDoFCount < 3 ) {\r\n\r\n\t\t\t\tfor ( let i = DOF.EX; i <= DOF.EZ; i ++ ) {\r\n\r\n\t\t\t\t\tdofTarget[ i ] = toSmallestEulerValueDistance( dofValues[ i ], dofTarget[ i ] );\r\n\t\t\t\t\tdofRestPose[ i ] = toSmallestEulerValueDistance( dofValues[ i ], dofRestPose[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttempValueEuler[ 0 ] = dofValues[ DOF.EX ];\r\n\t\t\t\ttempValueEuler[ 1 ] = dofValues[ DOF.EY ];\r\n\t\t\t\ttempValueEuler[ 2 ] = dofValues[ DOF.EZ ];\r\n\r\n\t\t\t\t// update target\r\n\t\t\t\ttempEuler[ 0 ] = dofTarget[ DOF.EX ];\r\n\t\t\t\ttempEuler[ 1 ] = dofTarget[ DOF.EY ];\r\n\t\t\t\ttempEuler[ 2 ] = dofTarget[ DOF.EZ ];\r\n\r\n\t\t\t\tgetClosestEulerRepresentation( tempEuler, tempValueEuler, tempEuler );\r\n\r\n\t\t\t\tdofTarget[ DOF.EX ] = tempEuler[ 0 ];\r\n\t\t\t\tdofTarget[ DOF.EY ] = tempEuler[ 1 ];\r\n\t\t\t\tdofTarget[ DOF.EZ ] = tempEuler[ 2 ];\r\n\r\n\t\t\t\t// update restPose\r\n\t\t\t\ttempEuler[ 0 ] = dofRestPose[ DOF.EX ];\r\n\t\t\t\ttempEuler[ 1 ] = dofRestPose[ DOF.EY ];\r\n\t\t\t\ttempEuler[ 2 ] = dofRestPose[ DOF.EZ ];\r\n\r\n\t\t\t\tgetClosestEulerRepresentation( tempEuler, tempValueEuler, tempEuler );\r\n\r\n\t\t\t\tdofRestPose[ DOF.EX ] = tempEuler[ 0 ];\r\n\t\t\t\tdofRestPose[ DOF.EY ] = tempEuler[ 1 ];\r\n\t\t\t\tdofRestPose[ DOF.EZ ] = tempEuler[ 2 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetDeltaWorldMatrix( dof, delta, outMatrix ) {\r\n\r\n\t\tconst {\r\n\t\t\tdofValues,\r\n\t\t\tminDoFLimit,\r\n\t\t\tmaxDoFLimit,\r\n\t\t\tcachedIdentityDoFMatrixWorld,\r\n\t\t} = this;\r\n\r\n\t\tthis.updateMatrixWorld();\r\n\r\n\t\t// copy out set of dof values\r\n\t\ttempDoFValues.set( dofValues );\r\n\r\n\t\t// get the state\r\n\t\tconst min = minDoFLimit[ dof ];\r\n\t\tconst max = maxDoFLimit[ dof ];\r\n\t\tconst currVal = tempDoFValues[ dof ];\r\n\r\n\t\t// check what our slack is\r\n\t\tconst minSlack = currVal - min;\r\n\t\tconst maxSlack = max - currVal;\r\n\r\n\t\t// If we're constrained by either limit then move in the other direction then\r\n\t\t// use the direction with the most slack.\r\n\t\tlet newVal = currVal + delta;\r\n\t\tconst isMaxConstrained = delta > 0 && newVal > max;\r\n\t\tconst isMinConstrained = delta < 0 && newVal < min;\r\n\t\tconst doInvert = ( isMaxConstrained && minSlack > maxSlack ) || ( isMinConstrained && maxSlack > minSlack );\r\n\t\tif ( doInvert ) {\r\n\r\n\t\t\tnewVal = currVal - delta;\r\n\r\n\t\t}\r\n\r\n\t\t// update our dof array and compute the matrix\r\n\t\ttempDoFValues[ dof ] = newVal;\r\n\r\n\t\tdofToMatrix( tempMatrix, tempDoFValues );\r\n\r\n\t\tmat4.multiply( outMatrix, cachedIdentityDoFMatrixWorld, tempMatrix );\r\n\r\n\t\treturn doInvert;\r\n\r\n\t}\r\n\r\n\t// matrix updates\r\n\tsetMatrixDoFNeedsUpdate() {\r\n\r\n\t\tif ( this.matrixDoFNeedsUpdate === false ) {\r\n\r\n\t\t\tthis.matrixDoFNeedsUpdate = true;\r\n\t\t\tthis.setMatrixWorldNeedsUpdate();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateDoFMatrix() {\r\n\r\n\t\tif ( this.matrixDoFNeedsUpdate ) {\r\n\r\n\t\t\tdofToMatrix( this.matrixDoF, this.dofValues );\r\n\t\t\tthis.matrixDoFNeedsUpdate = false;\r\n\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tcomputeMatrixWorld() {\r\n\r\n\t\tconst {\r\n\t\t\tparent,\r\n\t\t\tmatrixWorld,\r\n\t\t\tmatrix,\r\n\t\t\tmatrixDoF,\r\n\t\t\tcachedIdentityDoFMatrixWorld\r\n\t\t} = this;\r\n\r\n\t\tthis.updateDoFMatrix();\r\n\r\n\t\tmat4.multiply( matrixWorld, matrix, matrixDoF );\r\n\t\tif ( parent ) {\r\n\r\n\t\t\tmat4.multiply( matrixWorld, parent.matrixWorld, matrixWorld );\r\n\t\t\tmat4.multiply( cachedIdentityDoFMatrixWorld, parent.matrixWorld, matrix );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmat4.copy( cachedIdentityDoFMatrixWorld, matrix );\r\n\r\n\t\t}\r\n\r\n\r\n\r\n\t}\r\n\r\n\t// Add child overrides\r\n\tmakeClosure( child ) {\r\n\r\n\t\tif ( ! child.isLink || this.child || child.parent === this ) {\r\n\r\n\t\t\tthrow new Error( 'Joint: Given child cannot be used to make closure.' );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// don't store the closure child in the children array to avoid\r\n\t\t\t// implicit traversal.\r\n\t\t\tthis.child = child;\r\n\t\t\tthis.isClosure = true;\r\n\t\t\tchild.closureJoints.push( this );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\taddChild( child ) {\r\n\r\n\t\tif ( ! child.isLink || this.child || child.parent === this ) {\r\n\r\n\t\t\tthrow new Error( 'Joint: Given child cannot be added to Joint.' );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tsuper.addChild( child );\r\n\t\t\tthis.child = child;\r\n\t\t\tthis.isClosure = false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tremoveChild( child ) {\r\n\r\n\t\tif ( this.isClosure ) {\r\n\r\n\t\t\tif ( this.child !== child ) {\r\n\r\n\t\t\t\tthrow new Error( 'Frame: Child to be removed is not a child of this Joint.' );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.child = null;\r\n\t\t\t\tthis.isClosure = false;\r\n\r\n\t\t\t\tconst index = child.closureJoints.indexOf( this );\r\n\t\t\t\tchild.closureJoints.splice( index, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tsuper.removeChild( child );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tattachChild( child ) {\r\n\r\n\t\tsuper.attachChild( child );\r\n\r\n\t\t// remove the dof rotation afterward\r\n\t\tmat4.invert( tempInverse, this.matrixDoF );\r\n\t\tmat4.multiply( child.matrix, tempInverse, child.matrix );\r\n\t\tmat4.getTranslation( child.position, child.matrix );\r\n\t\tmat4.getRotation( child.quaternion, child.matrix );\r\n\r\n\t}\r\n\r\n\tdetachChild( child ) {\r\n\r\n\t\tsuper.detachChild( child );\r\n\r\n\t\t// remove the dof rotation afterward\r\n\t\tmat4.invert( tempInverse, this.matrixDoF );\r\n\t\tmat4.multiply( child.matrix, tempInverse, child.matrix );\r\n\t\tmat4.getTranslation( child.position, child.matrix );\r\n\t\tmat4.getRotation( child.quaternion, child.matrix );\r\n\r\n\t}\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}