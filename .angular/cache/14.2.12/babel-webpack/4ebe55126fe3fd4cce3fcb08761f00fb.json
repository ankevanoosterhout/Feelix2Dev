{"ast":null,"code":"import { vec3 } from 'gl-matrix';\nimport { PI, PI2, HALF_PI } from './constants.js'; // Clamp the given angle to ( - PI, PI ]\n\nfunction clampEulerValue(value) {\n  let result = value % PI2;\n\n  if (result > PI) {\n    result -= PI2;\n  } else if (result <= -PI) {\n    result += PI2;\n  }\n\n  return result;\n} // Convert `toAdjust` to be the equivalent rotation that is closest to target.\n\n\nfunction toSmallestEulerValueDistance(target, toAdjust) {\n  const wholeRotation = Math.round(target / PI2) * PI2;\n  const clampedValue = clampEulerValue(toAdjust);\n  let result = wholeRotation + clampedValue;\n  const delta = result - target;\n\n  if (Math.abs(delta) > PI) {\n    result -= Math.sign(delta) * PI2;\n  }\n\n  return result;\n} // Convert the set of euler angles toAdjust to the smallest equivalent rotation\n// that is closest to target.\n\n\nfunction toSmallestEulerDistance(output, target, toAdjust) {\n  output[0] = toSmallestEulerValueDistance(target[0], toAdjust[0]);\n  output[1] = toSmallestEulerValueDistance(target[1], toAdjust[1]);\n  output[2] = toSmallestEulerValueDistance(target[2], toAdjust[2]);\n} // Return the total diff between euler values\n\n\nfunction diffEulerDistance(a, b) {\n  // if `a` or `b` is a redundant twist representation then we convert them to the\n  // closest twist variation\n  let result = Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]) + Math.abs(a[2] - b[2]);\n  return result;\n} // Convert the given euler angles to an equivalent rotation\n\n\nfunction getRedundantEulerRepresentation(output, input) {\n  output[0] = input[0] + PI;\n  output[1] = PI - input[1];\n  output[2] = input[2] + PI;\n}\n\nfunction isRedundantTwist(euler) {\n  const pivotAngle = clampEulerValue(euler[1]);\n\n  if (Math.abs(Math.abs(pivotAngle) - HALF_PI) > 1e-7) {\n    return false;\n  }\n\n  return true;\n} // If toAdjust has a redundant rotation axis then find the representation that's closest to\n// the target set of angles.\n\n\nfunction toSmallestRedundantTwistRepresentation(output, target, toAdjust) {\n  if (!isRedundantTwist(toAdjust)) {\n    return false;\n  }\n\n  const pivotAngle = clampEulerValue(toAdjust[1]); // we have a redundant axis\n\n  const zRotationSign = -1 * Math.sign(pivotAngle);\n  const combinedXRotation = toAdjust[0] + zRotationSign * toAdjust[2];\n  output[0] = target[0];\n  output[1] = toSmallestEulerValueDistance(target[1], toAdjust[1]);\n  output[2] = toSmallestEulerValueDistance(target[2], zRotationSign * (combinedXRotation - target[0]));\n  toSmallestEulerDistance(output, target, output);\n  return true;\n} // Returns the closest euler representation\n\n\nconst tempEuler1 = new Float64Array(3);\nconst tempEuler2 = new Float64Array(3);\n\nfunction getClosestEulerRepresentation(output, target, input) {\n  let score = Infinity;\n\n  if (isRedundantTwist(input)) {\n    toSmallestRedundantTwistRepresentation(tempEuler1, target, input); // TODO: is checking the redundant direction necessary here?\n\n    getRedundantEulerRepresentation(tempEuler2, input);\n    toSmallestRedundantTwistRepresentation(tempEuler2, target, tempEuler2);\n    const d1 = diffEulerDistance(target, tempEuler1);\n    const d2 = diffEulerDistance(target, tempEuler2);\n\n    if (d1 < d2) {\n      vec3.copy(output, tempEuler1);\n      score = d1;\n    } else {\n      vec3.copy(output, tempEuler2);\n      score = d2;\n    }\n  } // There seems to be a chance that these representations are \"closer\" than the twist ones\n  // in the twist case. Possibly due to numerical precision?\n\n\n  toSmallestEulerDistance(tempEuler1, target, input);\n  getRedundantEulerRepresentation(tempEuler2, input);\n  toSmallestEulerDistance(tempEuler2, target, tempEuler2);\n  const d1 = diffEulerDistance(target, tempEuler1);\n  const d2 = diffEulerDistance(target, tempEuler2);\n\n  if (d1 < score || d2 < score) {\n    if (d1 < d2) {\n      vec3.copy(output, tempEuler1);\n    } else {\n      vec3.copy(output, tempEuler2);\n    }\n  }\n}\n\nexport { clampEulerValue, toSmallestEulerValueDistance, toSmallestEulerDistance, diffEulerDistance, getRedundantEulerRepresentation, toSmallestRedundantTwistRepresentation, getClosestEulerRepresentation, isRedundantTwist };","map":{"version":3,"names":["vec3","PI","PI2","HALF_PI","clampEulerValue","value","result","toSmallestEulerValueDistance","target","toAdjust","wholeRotation","Math","round","clampedValue","delta","abs","sign","toSmallestEulerDistance","output","diffEulerDistance","a","b","getRedundantEulerRepresentation","input","isRedundantTwist","euler","pivotAngle","toSmallestRedundantTwistRepresentation","zRotationSign","combinedXRotation","tempEuler1","Float64Array","tempEuler2","getClosestEulerRepresentation","score","Infinity","d1","d2","copy"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/closed-chain-ik/src/core/utils/euler.js"],"sourcesContent":["import { vec3 } from 'gl-matrix';\r\nimport { PI, PI2, HALF_PI } from './constants.js';\r\n\r\n// Clamp the given angle to ( - PI, PI ]\r\nfunction clampEulerValue( value ) {\r\n\r\n\tlet result = value % PI2;\r\n\tif ( result > PI ) {\r\n\r\n\t\tresult -= PI2;\r\n\r\n\t} else if ( result <= - PI ) {\r\n\r\n\t\tresult += PI2;\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\n// Convert `toAdjust` to be the equivalent rotation that is closest to target.\r\nfunction toSmallestEulerValueDistance( target, toAdjust ) {\r\n\r\n\tconst wholeRotation = Math.round( target / PI2 ) * PI2;\r\n\tconst clampedValue = clampEulerValue( toAdjust );\r\n\r\n\tlet result = wholeRotation + clampedValue;\r\n\tconst delta = result - target;\r\n\tif ( Math.abs( delta ) > PI ) {\r\n\r\n\t\tresult -= Math.sign( delta ) * PI2;\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\n// Convert the set of euler angles toAdjust to the smallest equivalent rotation\r\n// that is closest to target.\r\nfunction toSmallestEulerDistance( output, target, toAdjust ) {\r\n\r\n\toutput[ 0 ] = toSmallestEulerValueDistance( target[ 0 ], toAdjust[ 0 ] );\r\n\toutput[ 1 ] = toSmallestEulerValueDistance( target[ 1 ], toAdjust[ 1 ] );\r\n\toutput[ 2 ] = toSmallestEulerValueDistance( target[ 2 ], toAdjust[ 2 ] );\r\n\r\n}\r\n\r\n// Return the total diff between euler values\r\nfunction diffEulerDistance( a, b ) {\r\n\r\n\t// if `a` or `b` is a redundant twist representation then we convert them to the\r\n\t// closest twist variation\r\n\r\n\tlet result =\r\n\t\tMath.abs( a[ 0 ] - b[ 0 ] ) +\r\n\t\tMath.abs( a[ 1 ] - b[ 1 ] ) +\r\n\t\tMath.abs( a[ 2 ] - b[ 2 ] );\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\n// Convert the given euler angles to an equivalent rotation\r\nfunction getRedundantEulerRepresentation( output, input ) {\r\n\r\n\toutput[ 0 ] = input[ 0 ] + PI;\r\n\toutput[ 1 ] = PI - input[ 1 ];\r\n\toutput[ 2 ] = input[ 2 ] + PI;\r\n\r\n}\r\n\r\nfunction isRedundantTwist( euler ) {\r\n\r\n\tconst pivotAngle = clampEulerValue( euler[ 1 ] );\r\n\tif ( Math.abs( Math.abs( pivotAngle ) - HALF_PI ) > 1e-7 ) {\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n\r\n// If toAdjust has a redundant rotation axis then find the representation that's closest to\r\n// the target set of angles.\r\nfunction toSmallestRedundantTwistRepresentation( output, target, toAdjust ) {\r\n\r\n\tif ( ! isRedundantTwist( toAdjust ) ) {\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tconst pivotAngle = clampEulerValue( toAdjust[ 1 ] );\r\n\r\n\t// we have a redundant axis\r\n\tconst zRotationSign = - 1 * Math.sign( pivotAngle );\r\n\tconst combinedXRotation = toAdjust[ 0 ] + zRotationSign * toAdjust[ 2 ];\r\n\r\n\toutput[ 0 ] = target[ 0 ];\r\n\toutput[ 1 ] = toSmallestEulerValueDistance( target[ 1 ], toAdjust[ 1 ] );\r\n\toutput[ 2 ] = toSmallestEulerValueDistance( target[ 2 ], zRotationSign * ( combinedXRotation - target[ 0 ] ) );\r\n\r\n\ttoSmallestEulerDistance( output, target, output );\r\n\r\n\treturn true;\r\n\r\n}\r\n\r\n// Returns the closest euler representation\r\nconst tempEuler1 = new Float64Array( 3 );\r\nconst tempEuler2 = new Float64Array( 3 );\r\nfunction getClosestEulerRepresentation( output, target, input ) {\r\n\r\n\tlet score = Infinity;\r\n\tif ( isRedundantTwist( input ) ) {\r\n\r\n\t\ttoSmallestRedundantTwistRepresentation( tempEuler1, target, input );\r\n\r\n\t\t// TODO: is checking the redundant direction necessary here?\r\n\t\tgetRedundantEulerRepresentation( tempEuler2, input );\r\n\t\ttoSmallestRedundantTwistRepresentation( tempEuler2, target, tempEuler2 );\r\n\r\n\t\tconst d1 = diffEulerDistance( target, tempEuler1 );\r\n\t\tconst d2 = diffEulerDistance( target, tempEuler2 );\r\n\t\tif ( d1 < d2 ) {\r\n\r\n\t\t\tvec3.copy( output, tempEuler1 );\r\n\t\t\tscore = d1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvec3.copy( output, tempEuler2 );\r\n\t\t\tscore = d2;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// There seems to be a chance that these representations are \"closer\" than the twist ones\r\n\t// in the twist case. Possibly due to numerical precision?\r\n\ttoSmallestEulerDistance( tempEuler1, target, input );\r\n\r\n\tgetRedundantEulerRepresentation( tempEuler2, input );\r\n\ttoSmallestEulerDistance( tempEuler2, target, tempEuler2 );\r\n\r\n\tconst d1 = diffEulerDistance( target, tempEuler1 );\r\n\tconst d2 = diffEulerDistance( target, tempEuler2 );\r\n\tif ( d1 < score || d2 < score ) {\r\n\r\n\t\tif ( d1 < d2 ) {\r\n\r\n\t\t\tvec3.copy( output, tempEuler1 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvec3.copy( output, tempEuler2 );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n}\r\n\r\nexport {\r\n\tclampEulerValue,\r\n\ttoSmallestEulerValueDistance,\r\n\ttoSmallestEulerDistance,\r\n\tdiffEulerDistance,\r\n\tgetRedundantEulerRepresentation,\r\n\ttoSmallestRedundantTwistRepresentation,\r\n\tgetClosestEulerRepresentation,\r\n\tisRedundantTwist,\r\n};\r\n\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}