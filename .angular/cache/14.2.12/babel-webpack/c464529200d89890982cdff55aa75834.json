{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, SparseToDense, util } from '@tensorflow/tfjs-core';\nimport { scatterImpl } from './Scatter_impl';\nexport function sparseToDense(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    sparseIndices,\n    sparseValues,\n    defaultValue\n  } = inputs;\n  const {\n    outputShape\n  } = attrs;\n  const {\n    sliceRank,\n    numUpdates,\n    sliceSize,\n    strides,\n    outputSize\n  } = backend_util.calculateShapes(sparseValues, sparseIndices, outputShape);\n  const sumDupeIndices = false;\n  const indicesBuf = backend.bufferSync(sparseIndices);\n  let outBuf;\n\n  switch (sparseValues.dtype) {\n    case 'bool':\n      {\n        const updatesBuf = backend.bufferSync(sparseValues);\n        const $defaultValue = Boolean(backend.data.get(defaultValue.dataId).values[0]);\n        outBuf = scatterImpl(indicesBuf, updatesBuf, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, $defaultValue, sumDupeIndices);\n        break;\n      }\n\n    case 'float32':\n      {\n        const updatesBuf = backend.bufferSync(sparseValues);\n        const $defaultValue = backend.data.get(defaultValue.dataId).values[0];\n        outBuf = scatterImpl(indicesBuf, updatesBuf, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, $defaultValue, sumDupeIndices);\n        break;\n      }\n\n    case 'int32':\n      {\n        const updatesBuf = backend.bufferSync(sparseValues);\n        const $defaultValue = backend.data.get(defaultValue.dataId).values[0];\n        outBuf = scatterImpl(indicesBuf, updatesBuf, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, $defaultValue, sumDupeIndices);\n        break;\n      }\n\n    case 'string':\n      {\n        const updatesBuf = backend.bufferSync(sparseValues);\n        const $defaultValue = util.decodeString(backend.data.get(defaultValue.dataId).values[0]);\n        outBuf = scatterImpl(indicesBuf, updatesBuf, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, $defaultValue, sumDupeIndices);\n        break;\n      }\n\n    default:\n      throw new Error(`Unsupported type ${sparseValues.dtype}`);\n  }\n\n  return backend.makeTensorInfo(outputShape, outBuf.dtype, outBuf.values);\n}\nexport const sparseToDenseConfig = {\n  kernelName: SparseToDense,\n  backendName: 'cpu',\n  kernelFunc: sparseToDense\n};","map":{"version":3,"names":["backend_util","SparseToDense","util","scatterImpl","sparseToDense","args","inputs","backend","attrs","sparseIndices","sparseValues","defaultValue","outputShape","sliceRank","numUpdates","sliceSize","strides","outputSize","calculateShapes","sumDupeIndices","indicesBuf","bufferSync","outBuf","dtype","updatesBuf","$defaultValue","Boolean","data","get","dataId","values","decodeString","Error","makeTensorInfo","sparseToDenseConfig","kernelName","backendName","kernelFunc"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseToDense.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, SparseToDense, util } from '@tensorflow/tfjs-core';\nimport { scatterImpl } from './Scatter_impl';\nexport function sparseToDense(args) {\n    const { inputs, backend, attrs } = args;\n    const { sparseIndices, sparseValues, defaultValue } = inputs;\n    const { outputShape } = attrs;\n    const { sliceRank, numUpdates, sliceSize, strides, outputSize } = backend_util.calculateShapes(sparseValues, sparseIndices, outputShape);\n    const sumDupeIndices = false;\n    const indicesBuf = backend.bufferSync(sparseIndices);\n    let outBuf;\n    switch (sparseValues.dtype) {\n        case 'bool': {\n            const updatesBuf = backend.bufferSync(sparseValues);\n            const $defaultValue = Boolean(backend.data.get(defaultValue.dataId).values[0]);\n            outBuf = scatterImpl(indicesBuf, updatesBuf, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, $defaultValue, sumDupeIndices);\n            break;\n        }\n        case 'float32': {\n            const updatesBuf = backend.bufferSync(sparseValues);\n            const $defaultValue = backend.data.get(defaultValue.dataId).values[0];\n            outBuf = scatterImpl(indicesBuf, updatesBuf, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, $defaultValue, sumDupeIndices);\n            break;\n        }\n        case 'int32': {\n            const updatesBuf = backend.bufferSync(sparseValues);\n            const $defaultValue = backend.data.get(defaultValue.dataId).values[0];\n            outBuf = scatterImpl(indicesBuf, updatesBuf, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, $defaultValue, sumDupeIndices);\n            break;\n        }\n        case 'string': {\n            const updatesBuf = backend.bufferSync(sparseValues);\n            const $defaultValue = util.decodeString(backend.data.get(defaultValue.dataId).values[0]);\n            outBuf = scatterImpl(indicesBuf, updatesBuf, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, $defaultValue, sumDupeIndices);\n            break;\n        }\n        default:\n            throw new Error(`Unsupported type ${sparseValues.dtype}`);\n    }\n    return backend.makeTensorInfo(outputShape, outBuf.dtype, outBuf.values);\n}\nexport const sparseToDenseConfig = {\n    kernelName: SparseToDense,\n    backendName: 'cpu',\n    kernelFunc: sparseToDense\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}