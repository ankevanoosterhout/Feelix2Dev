{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { binaryInsert } from './non_max_suppression_util';\nexport function nonMaxSuppressionV3Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {\n  return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0\n  /* softNmsSigma */\n  );\n}\nexport function nonMaxSuppressionV4Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize) {\n  return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0\n  /* softNmsSigma */\n  , false\n  /* returnScoresTensor */\n  , padToMaxOutputSize\n  /* padToMaxOutputSize */\n  , true\n  /* returnValidOutputs */\n  );\n}\nexport function nonMaxSuppressionV5Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {\n  return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, true\n  /* returnScoresTensor */\n  );\n}\n\nfunction nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, returnScoresTensor = false, padToMaxOutputSize = false, returnValidOutputs = false) {\n  // The list is sorted in ascending order, so that we can always pop the\n  // candidate with the largest score in O(1) time.\n  const candidates = [];\n\n  for (let i = 0; i < scores.length; i++) {\n    if (scores[i] > scoreThreshold) {\n      candidates.push({\n        score: scores[i],\n        boxIndex: i,\n        suppressBeginIndex: 0\n      });\n    }\n  }\n\n  candidates.sort(ascendingComparator); // If softNmsSigma is 0, the outcome of this algorithm is exactly same as\n  // before.\n\n  const scale = softNmsSigma > 0 ? -0.5 / softNmsSigma : 0.0;\n  const selectedIndices = [];\n  const selectedScores = [];\n\n  while (selectedIndices.length < maxOutputSize && candidates.length > 0) {\n    const candidate = candidates.pop();\n    const {\n      score: originalScore,\n      boxIndex,\n      suppressBeginIndex\n    } = candidate;\n\n    if (originalScore < scoreThreshold) {\n      break;\n    } // Overlapping boxes are likely to have similar scores, therefore we\n    // iterate through the previously selected boxes backwards in order to\n    // see if candidate's score should be suppressed. We use\n    // suppressBeginIndex to track and ensure a candidate can be suppressed\n    // by a selected box no more than once. Also, if the overlap exceeds\n    // iouThreshold, we simply ignore the candidate.\n\n\n    let ignoreCandidate = false;\n\n    for (let j = selectedIndices.length - 1; j >= suppressBeginIndex; --j) {\n      const iou = intersectionOverUnion(boxes, boxIndex, selectedIndices[j]);\n\n      if (iou >= iouThreshold) {\n        ignoreCandidate = true;\n        break;\n      }\n\n      candidate.score = candidate.score * suppressWeight(iouThreshold, scale, iou);\n\n      if (candidate.score <= scoreThreshold) {\n        break;\n      }\n    } // At this point, if `candidate.score` has not dropped below\n    // `scoreThreshold`, then we know that we went through all of the\n    // previous selections and can safely update `suppressBeginIndex` to the\n    // end of the selected array. Then we can re-insert the candidate with\n    // the updated score and suppressBeginIndex back in the candidate list.\n    // If on the other hand, `candidate.score` has dropped below the score\n    // threshold, we will not add it back to the candidates list.\n\n\n    candidate.suppressBeginIndex = selectedIndices.length;\n\n    if (!ignoreCandidate) {\n      // Candidate has passed all the tests, and is not suppressed, so\n      // select the candidate.\n      if (candidate.score === originalScore) {\n        selectedIndices.push(boxIndex);\n        selectedScores.push(candidate.score);\n      } else if (candidate.score > scoreThreshold) {\n        // Candidate's score is suppressed but is still high enough to be\n        // considered, so add back to the candidates list.\n        binaryInsert(candidates, candidate, ascendingComparator);\n      }\n    }\n  } // NonMaxSuppressionV4 feature: padding output to maxOutputSize.\n\n\n  const validOutputs = selectedIndices.length;\n  const elemsToPad = maxOutputSize - validOutputs;\n\n  if (padToMaxOutputSize && elemsToPad > 0) {\n    selectedIndices.push(...new Array(elemsToPad).fill(0));\n    selectedScores.push(...new Array(elemsToPad).fill(0.0));\n  }\n\n  const result = {\n    selectedIndices\n  };\n\n  if (returnScoresTensor) {\n    result['selectedScores'] = selectedScores;\n  }\n\n  if (returnValidOutputs) {\n    result['validOutputs'] = validOutputs;\n  }\n\n  return result;\n}\n\nfunction intersectionOverUnion(boxes, i, j) {\n  const iCoord = boxes.subarray(i * 4, i * 4 + 4);\n  const jCoord = boxes.subarray(j * 4, j * 4 + 4);\n  const yminI = Math.min(iCoord[0], iCoord[2]);\n  const xminI = Math.min(iCoord[1], iCoord[3]);\n  const ymaxI = Math.max(iCoord[0], iCoord[2]);\n  const xmaxI = Math.max(iCoord[1], iCoord[3]);\n  const yminJ = Math.min(jCoord[0], jCoord[2]);\n  const xminJ = Math.min(jCoord[1], jCoord[3]);\n  const ymaxJ = Math.max(jCoord[0], jCoord[2]);\n  const xmaxJ = Math.max(jCoord[1], jCoord[3]);\n  const areaI = (ymaxI - yminI) * (xmaxI - xminI);\n  const areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);\n\n  if (areaI <= 0 || areaJ <= 0) {\n    return 0.0;\n  }\n\n  const intersectionYmin = Math.max(yminI, yminJ);\n  const intersectionXmin = Math.max(xminI, xminJ);\n  const intersectionYmax = Math.min(ymaxI, ymaxJ);\n  const intersectionXmax = Math.min(xmaxI, xmaxJ);\n  const intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0.0) * Math.max(intersectionXmax - intersectionXmin, 0.0);\n  return intersectionArea / (areaI + areaJ - intersectionArea);\n} // A Gaussian penalty function, this method always returns values in [0, 1].\n// The weight is a function of similarity, the more overlap two boxes are, the\n// smaller the weight is, meaning highly overlapping boxe will be significantly\n// penalized. On the other hand, a non-overlapping box will not be penalized.\n\n\nfunction suppressWeight(iouThreshold, scale, iou) {\n  const weight = Math.exp(scale * iou * iou);\n  return iou <= iouThreshold ? weight : 0.0;\n}\n\nfunction ascendingComparator(c1, c2) {\n  // For objects with same scores, we make the object with the larger index go\n  // first. In an array that pops from the end, this means that the object with\n  // the smaller index will be popped first. This ensures the same output as\n  // the TensorFlow python version.\n  return c1.score - c2.score || c1.score === c2.score && c2.boxIndex - c1.boxIndex;\n}","map":{"version":3,"names":["binaryInsert","nonMaxSuppressionV3Impl","boxes","scores","maxOutputSize","iouThreshold","scoreThreshold","nonMaxSuppressionImpl_","nonMaxSuppressionV4Impl","padToMaxOutputSize","nonMaxSuppressionV5Impl","softNmsSigma","returnScoresTensor","returnValidOutputs","candidates","i","length","push","score","boxIndex","suppressBeginIndex","sort","ascendingComparator","scale","selectedIndices","selectedScores","candidate","pop","originalScore","ignoreCandidate","j","iou","intersectionOverUnion","suppressWeight","validOutputs","elemsToPad","Array","fill","result","iCoord","subarray","jCoord","yminI","Math","min","xminI","ymaxI","max","xmaxI","yminJ","xminJ","ymaxJ","xmaxJ","areaI","areaJ","intersectionYmin","intersectionXmin","intersectionYmax","intersectionXmax","intersectionArea","weight","exp","c1","c2"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-core/dist/backends/non_max_suppression_impl.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { binaryInsert } from './non_max_suppression_util';\nexport function nonMaxSuppressionV3Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {\n    return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0 /* softNmsSigma */);\n}\nexport function nonMaxSuppressionV4Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize) {\n    return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0 /* softNmsSigma */, false /* returnScoresTensor */, padToMaxOutputSize /* padToMaxOutputSize */, true\n    /* returnValidOutputs */ );\n}\nexport function nonMaxSuppressionV5Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {\n    return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, true /* returnScoresTensor */);\n}\nfunction nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, returnScoresTensor = false, padToMaxOutputSize = false, returnValidOutputs = false) {\n    // The list is sorted in ascending order, so that we can always pop the\n    // candidate with the largest score in O(1) time.\n    const candidates = [];\n    for (let i = 0; i < scores.length; i++) {\n        if (scores[i] > scoreThreshold) {\n            candidates.push({ score: scores[i], boxIndex: i, suppressBeginIndex: 0 });\n        }\n    }\n    candidates.sort(ascendingComparator);\n    // If softNmsSigma is 0, the outcome of this algorithm is exactly same as\n    // before.\n    const scale = softNmsSigma > 0 ? (-0.5 / softNmsSigma) : 0.0;\n    const selectedIndices = [];\n    const selectedScores = [];\n    while (selectedIndices.length < maxOutputSize && candidates.length > 0) {\n        const candidate = candidates.pop();\n        const { score: originalScore, boxIndex, suppressBeginIndex } = candidate;\n        if (originalScore < scoreThreshold) {\n            break;\n        }\n        // Overlapping boxes are likely to have similar scores, therefore we\n        // iterate through the previously selected boxes backwards in order to\n        // see if candidate's score should be suppressed. We use\n        // suppressBeginIndex to track and ensure a candidate can be suppressed\n        // by a selected box no more than once. Also, if the overlap exceeds\n        // iouThreshold, we simply ignore the candidate.\n        let ignoreCandidate = false;\n        for (let j = selectedIndices.length - 1; j >= suppressBeginIndex; --j) {\n            const iou = intersectionOverUnion(boxes, boxIndex, selectedIndices[j]);\n            if (iou >= iouThreshold) {\n                ignoreCandidate = true;\n                break;\n            }\n            candidate.score =\n                candidate.score * suppressWeight(iouThreshold, scale, iou);\n            if (candidate.score <= scoreThreshold) {\n                break;\n            }\n        }\n        // At this point, if `candidate.score` has not dropped below\n        // `scoreThreshold`, then we know that we went through all of the\n        // previous selections and can safely update `suppressBeginIndex` to the\n        // end of the selected array. Then we can re-insert the candidate with\n        // the updated score and suppressBeginIndex back in the candidate list.\n        // If on the other hand, `candidate.score` has dropped below the score\n        // threshold, we will not add it back to the candidates list.\n        candidate.suppressBeginIndex = selectedIndices.length;\n        if (!ignoreCandidate) {\n            // Candidate has passed all the tests, and is not suppressed, so\n            // select the candidate.\n            if (candidate.score === originalScore) {\n                selectedIndices.push(boxIndex);\n                selectedScores.push(candidate.score);\n            }\n            else if (candidate.score > scoreThreshold) {\n                // Candidate's score is suppressed but is still high enough to be\n                // considered, so add back to the candidates list.\n                binaryInsert(candidates, candidate, ascendingComparator);\n            }\n        }\n    }\n    // NonMaxSuppressionV4 feature: padding output to maxOutputSize.\n    const validOutputs = selectedIndices.length;\n    const elemsToPad = maxOutputSize - validOutputs;\n    if (padToMaxOutputSize && elemsToPad > 0) {\n        selectedIndices.push(...new Array(elemsToPad).fill(0));\n        selectedScores.push(...new Array(elemsToPad).fill(0.0));\n    }\n    const result = { selectedIndices };\n    if (returnScoresTensor) {\n        result['selectedScores'] = selectedScores;\n    }\n    if (returnValidOutputs) {\n        result['validOutputs'] = validOutputs;\n    }\n    return result;\n}\nfunction intersectionOverUnion(boxes, i, j) {\n    const iCoord = boxes.subarray(i * 4, i * 4 + 4);\n    const jCoord = boxes.subarray(j * 4, j * 4 + 4);\n    const yminI = Math.min(iCoord[0], iCoord[2]);\n    const xminI = Math.min(iCoord[1], iCoord[3]);\n    const ymaxI = Math.max(iCoord[0], iCoord[2]);\n    const xmaxI = Math.max(iCoord[1], iCoord[3]);\n    const yminJ = Math.min(jCoord[0], jCoord[2]);\n    const xminJ = Math.min(jCoord[1], jCoord[3]);\n    const ymaxJ = Math.max(jCoord[0], jCoord[2]);\n    const xmaxJ = Math.max(jCoord[1], jCoord[3]);\n    const areaI = (ymaxI - yminI) * (xmaxI - xminI);\n    const areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);\n    if (areaI <= 0 || areaJ <= 0) {\n        return 0.0;\n    }\n    const intersectionYmin = Math.max(yminI, yminJ);\n    const intersectionXmin = Math.max(xminI, xminJ);\n    const intersectionYmax = Math.min(ymaxI, ymaxJ);\n    const intersectionXmax = Math.min(xmaxI, xmaxJ);\n    const intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0.0) *\n        Math.max(intersectionXmax - intersectionXmin, 0.0);\n    return intersectionArea / (areaI + areaJ - intersectionArea);\n}\n// A Gaussian penalty function, this method always returns values in [0, 1].\n// The weight is a function of similarity, the more overlap two boxes are, the\n// smaller the weight is, meaning highly overlapping boxe will be significantly\n// penalized. On the other hand, a non-overlapping box will not be penalized.\nfunction suppressWeight(iouThreshold, scale, iou) {\n    const weight = Math.exp(scale * iou * iou);\n    return iou <= iouThreshold ? weight : 0.0;\n}\nfunction ascendingComparator(c1, c2) {\n    // For objects with same scores, we make the object with the larger index go\n    // first. In an array that pops from the end, this means that the object with\n    // the smaller index will be popped first. This ensures the same output as\n    // the TensorFlow python version.\n    return (c1.score - c2.score) ||\n        ((c1.score === c2.score) && (c2.boxIndex - c1.boxIndex));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}