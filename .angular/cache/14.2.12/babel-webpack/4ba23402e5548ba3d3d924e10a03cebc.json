{"ast":null,"code":"import { Box3, InstancedInterleavedBuffer, InterleavedBufferAttribute, Line3, MathUtils, Matrix4, Mesh, Sphere, Vector3, Vector4 } from 'three';\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nconst _start = new Vector3();\n\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\n\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\n\nconst _ssOrigin3 = new Vector3();\n\nconst _mvMatrix = new Matrix4();\n\nconst _line = new Line3();\n\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\n\nconst _sphere = new Sphere();\n\nconst _clipToWorldVector = new Vector4(); // Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\n\n\nfunction getWorldSpaceHalfWidth(camera, distance, lineWidth, resolution) {\n  // transform into clip space, adjust the x and y values by the pixel width offset, then\n  // transform back into world space to get world offset. Note clip space is [-1, 1] so full\n  // width does not need to be halved.\n  _clipToWorldVector.set(0, 0, -distance, 1.0).applyMatrix4(camera.projectionMatrix);\n\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n  _clipToWorldVector.x = lineWidth / resolution.width;\n  _clipToWorldVector.y = lineWidth / resolution.height;\n\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);\n\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));\n}\n\nclass LineSegments2 extends Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.type = 'LineSegments2';\n  } // for backwards-compatability, but could be a method of LineSegmentsGeometry...\n\n\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n\n      _end.fromBufferAttribute(instanceEnd, i);\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n    geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n    geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n    return this;\n  }\n\n  raycast(raycaster, intersects) {\n    if (raycaster.camera === null) {\n      console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.');\n    }\n\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n    const ray = raycaster.ray;\n    const camera = raycaster.camera;\n    const projectionMatrix = camera.projectionMatrix;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    const resolution = material.resolution;\n    const lineWidth = material.linewidth + threshold;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd; // camera forward is negative\n\n    const near = -camera.near; //\n    // check if we intersect the sphere bounds\n\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n\n    const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(ray.origin)); // increase the sphere bounds by the worst case line screen space width\n\n    const sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, lineWidth, resolution);\n    _sphere.radius += sphereMargin;\n\n    if (raycaster.ray.intersectsSphere(_sphere) === false) {\n      return;\n    } //\n    // check if we intersect the box bounds\n\n\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n\n    const distanceToBox = Math.max(camera.near, _box.distanceToPoint(ray.origin)); // increase the box bounds by the worst case line screen space width\n\n    const boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, lineWidth, resolution);\n    _box.max.x += boxMargin;\n    _box.max.y += boxMargin;\n    _box.max.z += boxMargin;\n    _box.min.x -= boxMargin;\n    _box.min.y -= boxMargin;\n    _box.min.z -= boxMargin;\n\n    if (raycaster.ray.intersectsBox(_box) === false) {\n      return;\n    } //\n    // pick a point 1 unit out along the ray to avoid the ray origin\n    // sitting at the camera origin which will cause \"w\" to be 0 when\n    // applying the projection matrix.\n\n\n    ray.at(1, _ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n    _ssOrigin.w = 1;\n\n    _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n\n    _ssOrigin.applyMatrix4(projectionMatrix);\n\n    _ssOrigin.multiplyScalar(1 / _ssOrigin.w); // screen space\n\n\n    _ssOrigin.x *= resolution.x / 2;\n    _ssOrigin.y *= resolution.y / 2;\n    _ssOrigin.z = 0;\n\n    _ssOrigin3.copy(_ssOrigin);\n\n    _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n\n    for (let i = 0, l = instanceStart.count; i < l; i++) {\n      _start4.fromBufferAttribute(instanceStart, i);\n\n      _end4.fromBufferAttribute(instanceEnd, i);\n\n      _start4.w = 1;\n      _end4.w = 1; // camera space\n\n      _start4.applyMatrix4(_mvMatrix);\n\n      _end4.applyMatrix4(_mvMatrix); // skip the segment if it's entirely behind the camera\n\n\n      const isBehindCameraNear = _start4.z > near && _end4.z > near;\n\n      if (isBehindCameraNear) {\n        continue;\n      } // trim the segment if it extends behind camera near\n\n\n      if (_start4.z > near) {\n        const deltaDist = _start4.z - _end4.z;\n        const t = (_start4.z - near) / deltaDist;\n\n        _start4.lerp(_end4, t);\n      } else if (_end4.z > near) {\n        const deltaDist = _end4.z - _start4.z;\n        const t = (_end4.z - near) / deltaDist;\n\n        _end4.lerp(_start4, t);\n      } // clip space\n\n\n      _start4.applyMatrix4(projectionMatrix);\n\n      _end4.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n\n      _start4.multiplyScalar(1 / _start4.w);\n\n      _end4.multiplyScalar(1 / _end4.w); // screen space\n\n\n      _start4.x *= resolution.x / 2;\n      _start4.y *= resolution.y / 2;\n      _end4.x *= resolution.x / 2;\n      _end4.y *= resolution.y / 2; // create 2d segment\n\n      _line.start.copy(_start4);\n\n      _line.start.z = 0;\n\n      _line.end.copy(_end4);\n\n      _line.end.z = 0; // get closest point on ray to segment\n\n      const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n\n      _line.at(param, _closestPoint); // check if the intersection point is within clip space\n\n\n      const zPos = MathUtils.lerp(_start4.z, _end4.z, param);\n      const isInClipSpace = zPos >= -1 && zPos <= 1;\n      const isInside = _ssOrigin3.distanceTo(_closestPoint) < lineWidth * 0.5;\n\n      if (isInClipSpace && isInside) {\n        _line.start.fromBufferAttribute(instanceStart, i);\n\n        _line.end.fromBufferAttribute(instanceEnd, i);\n\n        _line.start.applyMatrix4(matrixWorld);\n\n        _line.end.applyMatrix4(matrixWorld);\n\n        const pointOnLine = new Vector3();\n        const point = new Vector3();\n        ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n        intersects.push({\n          point: point,\n          pointOnLine: pointOnLine,\n          distance: ray.origin.distanceTo(point),\n          object: this,\n          face: null,\n          faceIndex: i,\n          uv: null,\n          uv2: null\n        });\n      }\n    }\n  }\n\n}\n\nLineSegments2.prototype.isLineSegments2 = true;\nexport { LineSegments2 };","map":{"version":3,"names":["Box3","InstancedInterleavedBuffer","InterleavedBufferAttribute","Line3","MathUtils","Matrix4","Mesh","Sphere","Vector3","Vector4","LineSegmentsGeometry","LineMaterial","_start","_end","_start4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","_line","_closestPoint","_box","_sphere","_clipToWorldVector","getWorldSpaceHalfWidth","camera","distance","lineWidth","resolution","set","applyMatrix4","projectionMatrix","multiplyScalar","w","x","width","y","height","projectionMatrixInverse","Math","abs","max","LineSegments2","constructor","geometry","material","color","random","type","computeLineDistances","instanceStart","attributes","instanceEnd","lineDistances","Float32Array","count","i","j","l","fromBufferAttribute","distanceTo","instanceDistanceBuffer","setAttribute","raycast","raycaster","intersects","console","error","threshold","params","Line2","undefined","ray","matrixWorld","linewidth","near","boundingSphere","computeBoundingSphere","copy","distanceToSphere","distanceToPoint","origin","sphereMargin","radius","intersectsSphere","boundingBox","computeBoundingBox","distanceToBox","boxMargin","z","min","intersectsBox","at","matrixWorldInverse","multiplyMatrices","isBehindCameraNear","deltaDist","t","lerp","start","end","param","closestPointToPointParameter","zPos","isInClipSpace","isInside","pointOnLine","point","distanceSqToSegment","push","object","face","faceIndex","uv","uv2","prototype","isLineSegments2"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/three/examples/jsm/lines/LineSegments2.js"],"sourcesContent":["import {\n\tBox3,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tLine3,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tSphere,\n\tVector3,\n\tVector4\n} from 'three';\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nconst _start = new Vector3();\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\nconst _ssOrigin3 = new Vector3();\nconst _mvMatrix = new Matrix4();\nconst _line = new Line3();\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\nconst _sphere = new Sphere();\nconst _clipToWorldVector = new Vector4();\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth( camera, distance, lineWidth, resolution ) {\n\n\t// transform into clip space, adjust the x and y values by the pixel width offset, then\n\t// transform back into world space to get world offset. Note clip space is [-1, 1] so full\n\t// width does not need to be halved.\n\t_clipToWorldVector.set( 0, 0, - distance, 1.0 ).applyMatrix4( camera.projectionMatrix );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\t_clipToWorldVector.x = lineWidth / resolution.width;\n\t_clipToWorldVector.y = lineWidth / resolution.height;\n\t_clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\n\treturn Math.abs( Math.max( _clipToWorldVector.x, _clipToWorldVector.y ) );\n\n}\n\nclass LineSegments2 extends Mesh {\n\n\tconstructor( geometry = new LineSegmentsGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'LineSegments2';\n\n\t}\n\n\t// for backwards-compatability, but could be a method of LineSegmentsGeometry...\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst instanceStart = geometry.attributes.instanceStart;\n\t\tconst instanceEnd = geometry.attributes.instanceEnd;\n\t\tconst lineDistances = new Float32Array( 2 * instanceStart.count );\n\n\t\tfor ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {\n\n\t\t\t_start.fromBufferAttribute( instanceStart, i );\n\t\t\t_end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\n\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );\n\n\t\t}\n\n\t\tconst instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\n\n\t\tgeometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\n\t\tgeometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tif ( raycaster.camera === null ) {\n\n\t\t\tconsole.error( 'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.' );\n\n\t\t}\n\n\t\tconst threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;\n\n\t\tconst ray = raycaster.ray;\n\t\tconst camera = raycaster.camera;\n\t\tconst projectionMatrix = camera.projectionMatrix;\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\t\tconst resolution = material.resolution;\n\t\tconst lineWidth = material.linewidth + threshold;\n\n\t\tconst instanceStart = geometry.attributes.instanceStart;\n\t\tconst instanceEnd = geometry.attributes.instanceEnd;\n\n\t\t// camera forward is negative\n\t\tconst near = - camera.near;\n\n\t\t//\n\n\t\t// check if we intersect the sphere bounds\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\t_sphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );\n\t\tconst distanceToSphere = Math.max( camera.near, _sphere.distanceToPoint( ray.origin ) );\n\n\t\t// increase the sphere bounds by the worst case line screen space width\n\t\tconst sphereMargin = getWorldSpaceHalfWidth( camera, distanceToSphere, lineWidth, resolution );\n\t\t_sphere.radius += sphereMargin;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t//\n\n\t\t// check if we intersect the box bounds\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\t_box.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );\n\t\tconst distanceToBox = Math.max( camera.near, _box.distanceToPoint( ray.origin ) );\n\n\t\t// increase the box bounds by the worst case line screen space width\n\t\tconst boxMargin = getWorldSpaceHalfWidth( camera, distanceToBox, lineWidth, resolution );\n\t\t_box.max.x += boxMargin;\n\t\t_box.max.y += boxMargin;\n\t\t_box.max.z += boxMargin;\n\t\t_box.min.x -= boxMargin;\n\t\t_box.min.y -= boxMargin;\n\t\t_box.min.z -= boxMargin;\n\n\t\tif ( raycaster.ray.intersectsBox( _box ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t//\n\n\t\t// pick a point 1 unit out along the ray to avoid the ray origin\n\t\t// sitting at the camera origin which will cause \"w\" to be 0 when\n\t\t// applying the projection matrix.\n\t\tray.at( 1, _ssOrigin );\n\n\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t_ssOrigin.w = 1;\n\t\t_ssOrigin.applyMatrix4( camera.matrixWorldInverse );\n\t\t_ssOrigin.applyMatrix4( projectionMatrix );\n\t\t_ssOrigin.multiplyScalar( 1 / _ssOrigin.w );\n\n\t\t// screen space\n\t\t_ssOrigin.x *= resolution.x / 2;\n\t\t_ssOrigin.y *= resolution.y / 2;\n\t\t_ssOrigin.z = 0;\n\n\t\t_ssOrigin3.copy( _ssOrigin );\n\n\t\t_mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );\n\n\t\tfor ( let i = 0, l = instanceStart.count; i < l; i ++ ) {\n\n\t\t\t_start4.fromBufferAttribute( instanceStart, i );\n\t\t\t_end4.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t_start4.w = 1;\n\t\t\t_end4.w = 1;\n\n\t\t\t// camera space\n\t\t\t_start4.applyMatrix4( _mvMatrix );\n\t\t\t_end4.applyMatrix4( _mvMatrix );\n\n\t\t\t// skip the segment if it's entirely behind the camera\n\t\t\tconst isBehindCameraNear = _start4.z > near && _end4.z > near;\n\t\t\tif ( isBehindCameraNear ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// trim the segment if it extends behind camera near\n\t\t\tif ( _start4.z > near ) {\n\n\t\t\t\tconst deltaDist = _start4.z - _end4.z;\n\t\t\t\tconst t = ( _start4.z - near ) / deltaDist;\n\t\t\t\t_start4.lerp( _end4, t );\n\n\t\t\t} else if ( _end4.z > near ) {\n\n\t\t\t\tconst deltaDist = _end4.z - _start4.z;\n\t\t\t\tconst t = ( _end4.z - near ) / deltaDist;\n\t\t\t\t_end4.lerp( _start4, t );\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\t_start4.applyMatrix4( projectionMatrix );\n\t\t\t_end4.applyMatrix4( projectionMatrix );\n\n\t\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t\t_start4.multiplyScalar( 1 / _start4.w );\n\t\t\t_end4.multiplyScalar( 1 / _end4.w );\n\n\t\t\t// screen space\n\t\t\t_start4.x *= resolution.x / 2;\n\t\t\t_start4.y *= resolution.y / 2;\n\n\t\t\t_end4.x *= resolution.x / 2;\n\t\t\t_end4.y *= resolution.y / 2;\n\n\t\t\t// create 2d segment\n\t\t\t_line.start.copy( _start4 );\n\t\t\t_line.start.z = 0;\n\n\t\t\t_line.end.copy( _end4 );\n\t\t\t_line.end.z = 0;\n\n\t\t\t// get closest point on ray to segment\n\t\t\tconst param = _line.closestPointToPointParameter( _ssOrigin3, true );\n\t\t\t_line.at( param, _closestPoint );\n\n\t\t\t// check if the intersection point is within clip space\n\t\t\tconst zPos = MathUtils.lerp( _start4.z, _end4.z, param );\n\t\t\tconst isInClipSpace = zPos >= - 1 && zPos <= 1;\n\n\t\t\tconst isInside = _ssOrigin3.distanceTo( _closestPoint ) < lineWidth * 0.5;\n\n\t\t\tif ( isInClipSpace && isInside ) {\n\n\t\t\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t\t_line.start.applyMatrix4( matrixWorld );\n\t\t\t\t_line.end.applyMatrix4( matrixWorld );\n\n\t\t\t\tconst pointOnLine = new Vector3();\n\t\t\t\tconst point = new Vector3();\n\n\t\t\t\tray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\n\t\t\t\tintersects.push( {\n\n\t\t\t\t\tpoint: point,\n\t\t\t\t\tpointOnLine: pointOnLine,\n\t\t\t\t\tdistance: ray.origin.distanceTo( point ),\n\n\t\t\t\t\tobject: this,\n\t\t\t\t\tface: null,\n\t\t\t\t\tfaceIndex: i,\n\t\t\t\t\tuv: null,\n\t\t\t\t\tuv2: null,\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nLineSegments2.prototype.isLineSegments2 = true;\n\nexport { LineSegments2 };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}