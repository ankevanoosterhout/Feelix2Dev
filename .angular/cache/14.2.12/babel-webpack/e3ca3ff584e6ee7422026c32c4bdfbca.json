{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer } from '@tensorflow/tfjs-core';\nexport function pool(xValues, xShape, dtype, strides, convInfo, poolType) {\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n  const initialValue = poolType === 'max' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  const output = buffer(convInfo.outShape, dtype);\n  const outputVals = output.values;\n  const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3];\n  const outputRowStrides = convInfo.outShape[2] * convInfo.outShape[3];\n  const outputColStrides = convInfo.outShape[3];\n\n  for (let b = 0; b < convInfo.batchSize; ++b) {\n    const outputBatchOffset = b * outputBatchStrides;\n    const inputBatchOffset = b * strides[0];\n\n    for (let d = 0; d < convInfo.inChannels; ++d) {\n      for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n        const xRCorner = yR * strideHeight - padTop;\n        const xRMin = Math.max(0, xRCorner);\n        const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n        const outputRowOffset = outputBatchOffset + yR * outputRowStrides;\n\n        for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n          const xCCorner = yC * strideWidth - padLeft;\n          const xCMin = Math.max(0, xCCorner);\n          const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n          let minMaxValue = initialValue;\n          let avgValue = 0;\n          let count = 0;\n\n          for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {\n            const xROffset = inputBatchOffset + xR * strides[1];\n\n            for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {\n              const xCOffset = xROffset + xC * strides[2];\n              const pixel = xValues[xCOffset + d];\n\n              if (poolType === 'max' && pixel > minMaxValue) {\n                minMaxValue = pixel;\n              } else if (poolType === 'avg') {\n                avgValue += pixel;\n                count++;\n              }\n            }\n\n            if (isNaN(minMaxValue)) {\n              break;\n            }\n          }\n\n          const outputOffset = outputRowOffset + yC * outputColStrides + d;\n          outputVals[outputOffset] = poolType === 'avg' ? avgValue / count : minMaxValue;\n        }\n      }\n    }\n  }\n\n  return output;\n}\nexport function maxPoolPositions(xValues, xShape, dtype, convInfo, flattenPositions = false, includeBatchInIndex = false) {\n  const maxPositions = buffer(convInfo.outShape, 'int32');\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n  const xBuf = buffer(xShape, dtype, xValues);\n\n  for (let b = 0; b < convInfo.batchSize; ++b) {\n    for (let d = 0; d < convInfo.inChannels; ++d) {\n      for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n        const xRCorner = yR * strideHeight - padTop;\n        let xRMin = xRCorner;\n\n        while (xRMin < 0) {\n          xRMin += dilationHeight;\n        } // const xRMin = Math.max(0, xRCorner);\n\n\n        const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n\n        for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n          const xCCorner = yC * strideWidth - padLeft;\n          let xCMin = xCCorner;\n\n          while (xCMin < 0) {\n            xCMin += dilationWidth;\n          }\n\n          const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n          let maxValue = Number.NEGATIVE_INFINITY;\n          let maxPosition = -1;\n\n          for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {\n            const wR = xR - xRCorner;\n\n            for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {\n              const wC = xC - xCCorner;\n              const pixel = xBuf.get(b, xR, xC, d);\n\n              if (pixel > maxValue) {\n                maxValue = pixel;\n\n                if (flattenPositions) {\n                  maxPosition = includeBatchInIndex ? ((b * convInfo.inHeight + xR) * convInfo.inWidth + xC) * convInfo.inChannels + d : (xR * convInfo.inWidth + xC) * convInfo.inChannels + d;\n                } else {\n                  maxPosition = wR * effectiveFilterWidth + wC;\n                }\n              }\n            }\n          }\n\n          maxPositions.set(maxPosition, b, yR, yC, d);\n        }\n      }\n    }\n  }\n\n  return maxPositions;\n}\nexport function pool3d(xValues, xShape, dtype, strides, convInfo, poolType) {\n  const strideDepth = convInfo.strideDepth;\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationDepth = convInfo.dilationDepth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padFront = convInfo.padInfo.front;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n  const initialValue = poolType === 'max' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  const output = buffer(convInfo.outShape, dtype);\n  const outputVals = output.values;\n  const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];\n  const outputDepthStrides = convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];\n  const outputRowStrides = convInfo.outShape[3] * convInfo.outShape[4];\n  const outputColStrides = convInfo.outShape[4];\n\n  for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n    const outputBatchOffset = batch * outputBatchStrides;\n    const inputBatchOffset = batch * strides[0];\n\n    for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n      for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n        const xDepthCorner = yDepth * strideDepth - padFront;\n        let xDepthMin = xDepthCorner;\n\n        while (xDepthMin < 0) {\n          xDepthMin += dilationDepth;\n        }\n\n        const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n        const outputDepthOffset = outputBatchOffset + yDepth * outputDepthStrides;\n\n        for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n          const xRowCorner = yRow * strideHeight - padTop;\n          let xRowMin = xRowCorner;\n\n          while (xRowMin < 0) {\n            xRowMin += dilationHeight;\n          }\n\n          const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n          const outputRowOffset = outputDepthOffset + yRow * outputRowStrides;\n\n          for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n            const xColCorner = yCol * strideWidth - padLeft;\n            let xColMin = xColCorner;\n\n            while (xColMin < 0) {\n              xColMin += dilationWidth;\n            }\n\n            const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner); // Shader code begins\n\n            const outputColOffset = outputRowOffset + yCol * outputColStrides;\n            let minMaxValue = initialValue;\n            let avgValue = 0;\n            let count = 0;\n\n            for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n              const xDepthOffset = inputBatchOffset + xDepth * strides[1];\n\n              for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                const xRowOffset = xDepthOffset + xRow * strides[2];\n\n                for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                  const xColOffset = xRowOffset + xCol * strides[3];\n                  const pixel = xValues[xColOffset + channel];\n\n                  if (poolType === 'max' && pixel > minMaxValue) {\n                    minMaxValue = pixel;\n                  } else if (poolType === 'avg') {\n                    avgValue += pixel;\n                    count++;\n                  }\n\n                  if (isNaN(minMaxValue)) {\n                    break;\n                  }\n                }\n\n                if (isNaN(minMaxValue)) {\n                  break;\n                }\n              }\n\n              if (isNaN(minMaxValue)) {\n                break;\n              }\n            }\n\n            const outputOffset = outputColOffset + channel;\n            outputVals[outputOffset] = poolType === 'avg' ? avgValue / count : minMaxValue;\n          }\n        }\n      }\n    }\n  }\n\n  return output;\n}\nexport function maxPool3dPositions(xBuf, convInfo) {\n  const maxPositions = buffer(convInfo.outShape, 'int32');\n  const strideDepth = convInfo.strideDepth;\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationDepth = convInfo.dilationDepth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padFront = convInfo.padInfo.front;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n\n  for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n    for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n      for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n        const xDepthCorner = yDepth * strideDepth - padFront;\n        let xDepthMin = xDepthCorner;\n\n        while (xDepthMin < 0) {\n          xDepthMin += dilationDepth;\n        }\n\n        const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n\n        for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n          const xRowCorner = yRow * strideHeight - padTop;\n          let xRowMin = xRowCorner;\n\n          while (xRowMin < 0) {\n            xRowMin += dilationHeight;\n          }\n\n          const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n\n          for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n            const xColCorner = yCol * strideWidth - padLeft;\n            let xColMin = xColCorner;\n\n            while (xColMin < 0) {\n              xColMin += dilationWidth;\n            }\n\n            const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner); // Shader code begins\n\n            let maxValue = Number.NEGATIVE_INFINITY;\n            let maxPosition = -1;\n\n            for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n              const wDepth = xDepth - xDepthCorner;\n\n              for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                const wRow = xRow - xRowCorner;\n\n                for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                  const wCol = xCol - xColCorner;\n                  const pixel = xBuf.get(batch, xDepth, xRow, xCol, channel);\n\n                  if (pixel >= maxValue) {\n                    maxValue = pixel;\n                    maxPosition = wDepth * effectiveFilterHeight * effectiveFilterWidth + wRow * effectiveFilterHeight + wCol;\n                  }\n                }\n              }\n            }\n\n            maxPositions.set(maxPosition, batch, yDepth, yRow, yCol, channel);\n          }\n        }\n      }\n    }\n  }\n\n  return maxPositions;\n}","map":{"version":3,"names":["buffer","pool","xValues","xShape","dtype","strides","convInfo","poolType","strideHeight","strideWidth","dilationHeight","dilationWidth","effectiveFilterHeight","effectiveFilterWidth","padTop","padInfo","top","padLeft","left","initialValue","Number","NEGATIVE_INFINITY","POSITIVE_INFINITY","output","outShape","outputVals","values","outputBatchStrides","outputRowStrides","outputColStrides","b","batchSize","outputBatchOffset","inputBatchOffset","d","inChannels","yR","outHeight","xRCorner","xRMin","Math","max","xRMax","min","inHeight","outputRowOffset","yC","outWidth","xCCorner","xCMin","xCMax","inWidth","minMaxValue","avgValue","count","xR","xROffset","xC","xCOffset","pixel","isNaN","outputOffset","maxPoolPositions","flattenPositions","includeBatchInIndex","maxPositions","xBuf","maxValue","maxPosition","wR","wC","get","set","pool3d","strideDepth","dilationDepth","effectiveFilterDepth","padFront","front","outputDepthStrides","batch","channel","yDepth","outDepth","xDepthCorner","xDepthMin","xDepthMax","inDepth","outputDepthOffset","yRow","xRowCorner","xRowMin","xRowMax","yCol","xColCorner","xColMin","xColMax","outputColOffset","xDepth","xDepthOffset","xRow","xRowOffset","xCol","xColOffset","maxPool3dPositions","wDepth","wRow","wCol"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/pool_utils.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer } from '@tensorflow/tfjs-core';\nexport function pool(xValues, xShape, dtype, strides, convInfo, poolType) {\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const initialValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :\n        Number.POSITIVE_INFINITY);\n    const output = buffer(convInfo.outShape, dtype);\n    const outputVals = output.values;\n    const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3];\n    const outputRowStrides = convInfo.outShape[2] * convInfo.outShape[3];\n    const outputColStrides = convInfo.outShape[3];\n    for (let b = 0; b < convInfo.batchSize; ++b) {\n        const outputBatchOffset = b * outputBatchStrides;\n        const inputBatchOffset = b * strides[0];\n        for (let d = 0; d < convInfo.inChannels; ++d) {\n            for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n                const xRCorner = yR * strideHeight - padTop;\n                const xRMin = Math.max(0, xRCorner);\n                const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n                const outputRowOffset = outputBatchOffset + yR * outputRowStrides;\n                for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n                    const xCCorner = yC * strideWidth - padLeft;\n                    const xCMin = Math.max(0, xCCorner);\n                    const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n                    let minMaxValue = initialValue;\n                    let avgValue = 0;\n                    let count = 0;\n                    for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {\n                        const xROffset = inputBatchOffset + xR * strides[1];\n                        for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {\n                            const xCOffset = xROffset + xC * strides[2];\n                            const pixel = xValues[xCOffset + d];\n                            if ((poolType === 'max' && pixel > minMaxValue)) {\n                                minMaxValue = pixel;\n                            }\n                            else if (poolType === 'avg') {\n                                avgValue += pixel;\n                                count++;\n                            }\n                        }\n                        if (isNaN(minMaxValue)) {\n                            break;\n                        }\n                    }\n                    const outputOffset = outputRowOffset + yC * outputColStrides + d;\n                    outputVals[outputOffset] =\n                        poolType === 'avg' ? avgValue / count : minMaxValue;\n                }\n            }\n        }\n    }\n    return output;\n}\nexport function maxPoolPositions(xValues, xShape, dtype, convInfo, flattenPositions = false, includeBatchInIndex = false) {\n    const maxPositions = buffer(convInfo.outShape, 'int32');\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const xBuf = buffer(xShape, dtype, xValues);\n    for (let b = 0; b < convInfo.batchSize; ++b) {\n        for (let d = 0; d < convInfo.inChannels; ++d) {\n            for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n                const xRCorner = yR * strideHeight - padTop;\n                let xRMin = xRCorner;\n                while (xRMin < 0) {\n                    xRMin += dilationHeight;\n                }\n                // const xRMin = Math.max(0, xRCorner);\n                const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n                for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n                    const xCCorner = yC * strideWidth - padLeft;\n                    let xCMin = xCCorner;\n                    while (xCMin < 0) {\n                        xCMin += dilationWidth;\n                    }\n                    const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n                    let maxValue = Number.NEGATIVE_INFINITY;\n                    let maxPosition = -1;\n                    for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {\n                        const wR = xR - xRCorner;\n                        for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {\n                            const wC = xC - xCCorner;\n                            const pixel = xBuf.get(b, xR, xC, d);\n                            if (pixel > maxValue) {\n                                maxValue = pixel;\n                                if (flattenPositions) {\n                                    maxPosition = includeBatchInIndex ?\n                                        ((b * convInfo.inHeight + xR) * convInfo.inWidth + xC) *\n                                            convInfo.inChannels +\n                                            d :\n                                        (xR * convInfo.inWidth + xC) * convInfo.inChannels + d;\n                                }\n                                else {\n                                    maxPosition = wR * effectiveFilterWidth + wC;\n                                }\n                            }\n                        }\n                    }\n                    maxPositions.set(maxPosition, b, yR, yC, d);\n                }\n            }\n        }\n    }\n    return maxPositions;\n}\nexport function pool3d(xValues, xShape, dtype, strides, convInfo, poolType) {\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const initialValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :\n        Number.POSITIVE_INFINITY);\n    const output = buffer(convInfo.outShape, dtype);\n    const outputVals = output.values;\n    const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] *\n        convInfo.outShape[3] * convInfo.outShape[4];\n    const outputDepthStrides = convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];\n    const outputRowStrides = convInfo.outShape[3] * convInfo.outShape[4];\n    const outputColStrides = convInfo.outShape[4];\n    for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n        const outputBatchOffset = batch * outputBatchStrides;\n        const inputBatchOffset = batch * strides[0];\n        for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n            for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n                const xDepthCorner = yDepth * strideDepth - padFront;\n                let xDepthMin = xDepthCorner;\n                while (xDepthMin < 0) {\n                    xDepthMin += dilationDepth;\n                }\n                const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n                const outputDepthOffset = outputBatchOffset + yDepth * outputDepthStrides;\n                for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n                    const xRowCorner = yRow * strideHeight - padTop;\n                    let xRowMin = xRowCorner;\n                    while (xRowMin < 0) {\n                        xRowMin += dilationHeight;\n                    }\n                    const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n                    const outputRowOffset = outputDepthOffset + yRow * outputRowStrides;\n                    for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n                        const xColCorner = yCol * strideWidth - padLeft;\n                        let xColMin = xColCorner;\n                        while (xColMin < 0) {\n                            xColMin += dilationWidth;\n                        }\n                        const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);\n                        // Shader code begins\n                        const outputColOffset = outputRowOffset + yCol * outputColStrides;\n                        let minMaxValue = initialValue;\n                        let avgValue = 0;\n                        let count = 0;\n                        for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n                            const xDepthOffset = inputBatchOffset + xDepth * strides[1];\n                            for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                                const xRowOffset = xDepthOffset + xRow * strides[2];\n                                for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                                    const xColOffset = xRowOffset + xCol * strides[3];\n                                    const pixel = xValues[xColOffset + channel];\n                                    if ((poolType === 'max' && pixel > minMaxValue)) {\n                                        minMaxValue = pixel;\n                                    }\n                                    else if (poolType === 'avg') {\n                                        avgValue += pixel;\n                                        count++;\n                                    }\n                                    if (isNaN(minMaxValue)) {\n                                        break;\n                                    }\n                                }\n                                if (isNaN(minMaxValue)) {\n                                    break;\n                                }\n                            }\n                            if (isNaN(minMaxValue)) {\n                                break;\n                            }\n                        }\n                        const outputOffset = outputColOffset + channel;\n                        outputVals[outputOffset] =\n                            poolType === 'avg' ? avgValue / count : minMaxValue;\n                    }\n                }\n            }\n        }\n    }\n    return output;\n}\nexport function maxPool3dPositions(xBuf, convInfo) {\n    const maxPositions = buffer(convInfo.outShape, 'int32');\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n        for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n            for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n                const xDepthCorner = yDepth * strideDepth - padFront;\n                let xDepthMin = xDepthCorner;\n                while (xDepthMin < 0) {\n                    xDepthMin += dilationDepth;\n                }\n                const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n                for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n                    const xRowCorner = yRow * strideHeight - padTop;\n                    let xRowMin = xRowCorner;\n                    while (xRowMin < 0) {\n                        xRowMin += dilationHeight;\n                    }\n                    const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n                    for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n                        const xColCorner = yCol * strideWidth - padLeft;\n                        let xColMin = xColCorner;\n                        while (xColMin < 0) {\n                            xColMin += dilationWidth;\n                        }\n                        const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);\n                        // Shader code begins\n                        let maxValue = Number.NEGATIVE_INFINITY;\n                        let maxPosition = -1;\n                        for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n                            const wDepth = xDepth - xDepthCorner;\n                            for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                                const wRow = xRow - xRowCorner;\n                                for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                                    const wCol = xCol - xColCorner;\n                                    const pixel = xBuf.get(batch, xDepth, xRow, xCol, channel);\n                                    if (pixel >= maxValue) {\n                                        maxValue = pixel;\n                                        maxPosition =\n                                            wDepth * effectiveFilterHeight * effectiveFilterWidth +\n                                                wRow * effectiveFilterHeight + wCol;\n                                    }\n                                }\n                            }\n                        }\n                        maxPositions.set(maxPosition, batch, yDepth, yRow, yCol, channel);\n                    }\n                }\n            }\n        }\n    }\n    return maxPositions;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}