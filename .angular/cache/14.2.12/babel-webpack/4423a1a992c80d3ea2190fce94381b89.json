{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { assert } from '../../util';\nimport { complex } from '../complex';\nimport { concat } from '../concat';\nimport { imag } from '../imag';\nimport { op } from '../operation';\nimport { real } from '../real';\nimport { reshape } from '../reshape';\nimport { slice } from '../slice';\nimport { split } from '../split';\nimport { zeros } from '../zeros';\nimport { zerosLike } from '../zeros_like';\nimport { fft } from './fft';\n/**\n * Real value input fast Fourier transform.\n *\n * Computes the 1-dimensional discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n *\n * real.rfft().print();\n * ```\n * @param input The real value input to compute an rfft over.\n *\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\n\nfunction rfft_(input, fftLength) {\n  assert(input.dtype === 'float32', () => `The dtype for rfft() must be real value but got ${input.dtype}`);\n  let innerDimensionSize = input.shape[input.shape.length - 1];\n  const batch = input.size / innerDimensionSize;\n  let adjustedInput;\n\n  if (fftLength != null && fftLength < innerDimensionSize) {\n    // Need to crop\n    const begin = input.shape.map(v => 0);\n    const size = input.shape.map(v => v);\n    size[input.shape.length - 1] = fftLength;\n    adjustedInput = slice(input, begin, size);\n    innerDimensionSize = fftLength;\n  } else if (fftLength != null && fftLength > innerDimensionSize) {\n    // Need to pad with zeros\n    const zerosShape = input.shape.map(v => v);\n    zerosShape[input.shape.length - 1] = fftLength - innerDimensionSize;\n    adjustedInput = concat([input, zeros(zerosShape)], input.shape.length - 1);\n    innerDimensionSize = fftLength;\n  } else {\n    adjustedInput = input;\n  } // Complement the input with zero imaginary numbers.\n\n\n  const zerosInput = zerosLike(adjustedInput);\n  const complexInput = reshape(complex(adjustedInput, zerosInput), [batch, innerDimensionSize]);\n  const ret = fft(complexInput); // Exclude complex conjugations. These conjugations are put symmetrically.\n\n  const half = Math.floor(innerDimensionSize / 2) + 1;\n  const realValues = real(ret);\n  const imagValues = imag(ret);\n  const realComplexConjugate = split(realValues, [half, innerDimensionSize - half], realValues.shape.length - 1);\n  const imagComplexConjugate = split(imagValues, [half, innerDimensionSize - half], imagValues.shape.length - 1);\n  const outputShape = adjustedInput.shape.slice();\n  outputShape[adjustedInput.shape.length - 1] = half;\n  return reshape(complex(realComplexConjugate[0], imagComplexConjugate[0]), outputShape);\n}\n\nexport const rfft = op({\n  rfft_\n});","map":{"version":3,"names":["assert","complex","concat","imag","op","real","reshape","slice","split","zeros","zerosLike","fft","rfft_","input","fftLength","dtype","innerDimensionSize","shape","length","batch","size","adjustedInput","begin","map","v","zerosShape","zerosInput","complexInput","ret","half","Math","floor","realValues","imagValues","realComplexConjugate","imagComplexConjugate","outputShape","rfft"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-core/dist/ops/spectral/rfft.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { assert } from '../../util';\nimport { complex } from '../complex';\nimport { concat } from '../concat';\nimport { imag } from '../imag';\nimport { op } from '../operation';\nimport { real } from '../real';\nimport { reshape } from '../reshape';\nimport { slice } from '../slice';\nimport { split } from '../split';\nimport { zeros } from '../zeros';\nimport { zerosLike } from '../zeros_like';\nimport { fft } from './fft';\n/**\n * Real value input fast Fourier transform.\n *\n * Computes the 1-dimensional discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n *\n * real.rfft().print();\n * ```\n * @param input The real value input to compute an rfft over.\n *\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction rfft_(input, fftLength) {\n    assert(input.dtype === 'float32', () => `The dtype for rfft() must be real value but got ${input.dtype}`);\n    let innerDimensionSize = input.shape[input.shape.length - 1];\n    const batch = input.size / innerDimensionSize;\n    let adjustedInput;\n    if (fftLength != null && fftLength < innerDimensionSize) {\n        // Need to crop\n        const begin = input.shape.map(v => 0);\n        const size = input.shape.map(v => v);\n        size[input.shape.length - 1] = fftLength;\n        adjustedInput = slice(input, begin, size);\n        innerDimensionSize = fftLength;\n    }\n    else if (fftLength != null && fftLength > innerDimensionSize) {\n        // Need to pad with zeros\n        const zerosShape = input.shape.map(v => v);\n        zerosShape[input.shape.length - 1] = fftLength - innerDimensionSize;\n        adjustedInput = concat([input, zeros(zerosShape)], input.shape.length - 1);\n        innerDimensionSize = fftLength;\n    }\n    else {\n        adjustedInput = input;\n    }\n    // Complement the input with zero imaginary numbers.\n    const zerosInput = zerosLike(adjustedInput);\n    const complexInput = reshape(complex(adjustedInput, zerosInput), [batch, innerDimensionSize]);\n    const ret = fft(complexInput);\n    // Exclude complex conjugations. These conjugations are put symmetrically.\n    const half = Math.floor(innerDimensionSize / 2) + 1;\n    const realValues = real(ret);\n    const imagValues = imag(ret);\n    const realComplexConjugate = split(realValues, [half, innerDimensionSize - half], realValues.shape.length - 1);\n    const imagComplexConjugate = split(imagValues, [half, innerDimensionSize - half], imagValues.shape.length - 1);\n    const outputShape = adjustedInput.shape.slice();\n    outputShape[adjustedInput.shape.length - 1] = half;\n    return reshape(complex(realComplexConjugate[0], imagComplexConjugate[0]), outputShape);\n}\nexport const rfft = op({ rfft_ });\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}