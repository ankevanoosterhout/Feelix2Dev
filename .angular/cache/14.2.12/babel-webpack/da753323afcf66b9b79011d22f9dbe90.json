{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport var RowPartitionType;\n\n(function (RowPartitionType) {\n  RowPartitionType[RowPartitionType[\"FIRST_DIM_SIZE\"] = 0] = \"FIRST_DIM_SIZE\";\n  RowPartitionType[RowPartitionType[\"VALUE_ROWIDS\"] = 1] = \"VALUE_ROWIDS\";\n  RowPartitionType[RowPartitionType[\"ROW_LENGTHS\"] = 2] = \"ROW_LENGTHS\";\n  RowPartitionType[RowPartitionType[\"ROW_SPLITS\"] = 3] = \"ROW_SPLITS\";\n  RowPartitionType[RowPartitionType[\"ROW_LIMITS\"] = 4] = \"ROW_LIMITS\";\n  RowPartitionType[RowPartitionType[\"ROW_STARTS\"] = 5] = \"ROW_STARTS\";\n})(RowPartitionType || (RowPartitionType = {}));\n\nexport function combineRaggedTensorToTensorShapes(raggedRank, shape, valueShape) {\n  // Test for consistency of valueShape and shape specified.\n  // If shape is unspecified and valueShape is specified, then copy\n  // over the size from the valueShape dimension.\n  let outputShape = new Array();\n\n  if (valueShape == null && shape == null) {\n    return outputShape;\n  }\n\n  if (shape == null) {\n    // Here, value_shape must be of known size.\n    while (outputShape.length < raggedRank + valueShape.length) {\n      outputShape.push(-1);\n    }\n  } else {\n    outputShape = shape.slice();\n  }\n\n  if (valueShape == null) {\n    return outputShape;\n  } // At this point, valueShape and output_shape have known ranks.\n\n\n  if (raggedRank + valueShape.length !== outputShape.length) {\n    throw new Error(`rt input.shape and shape=${shape} are incompatible: rt input.rank = ${raggedRank + valueShape.length}, but shape.rank = ${outputShape.length}`);\n  }\n\n  for (let i = 1; i < valueShape.length; ++i) {\n    const valueDim = valueShape[i];\n    const outputShapeDimIndex = outputShape[outputShape.length - valueShape.length + i];\n    const outputShapeDim = outputShape[outputShapeDimIndex];\n\n    if (valueDim >= 0) {\n      if (outputShapeDim >= 0) {\n        if (outputShapeDim !== valueDim) {\n          throw new Error(`rt input.shape and shape=${shape} are incompatible: rt input.shape[${i + raggedRank}] = ${valueDim} but shape[${i + raggedRank}] = ${outputShapeDim}`);\n        }\n      } else {\n        outputShape[outputShapeDimIndex] = valueDim;\n      }\n    }\n  }\n\n  return outputShape;\n}\nexport function getRowPartitionTypesHelper(rowPartitionTypeStrings) {\n  const stringToType = {\n    'FIRST_DIM_SIZE': RowPartitionType.FIRST_DIM_SIZE,\n    'VALUE_ROWIDS': RowPartitionType.VALUE_ROWIDS,\n    'ROW_LENGTHS': RowPartitionType.ROW_LENGTHS,\n    'ROW_SPLITS': RowPartitionType.ROW_SPLITS,\n    'ROW_LIMITS': RowPartitionType.ROW_LIMITS,\n    'ROW_STARTS': RowPartitionType.ROW_STARTS\n  };\n  const result = [];\n\n  for (const typeStr of rowPartitionTypeStrings) {\n    if (typeStr in stringToType) {\n      result.push(stringToType[typeStr]);\n    } else {\n      break;\n    }\n  }\n\n  return result;\n}\nexport function getRaggedRank(rowPartitionTypes) {\n  if (rowPartitionTypes.length === 0) {\n    return 0;\n  }\n\n  if (rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n    return rowPartitionTypes.length - 1;\n  }\n\n  return rowPartitionTypes.length;\n}\nexport function validateDefaultValueShape(defaultValueShape, valueShape) {\n  if (defaultValueShape == null || valueShape == null) {\n    return;\n  }\n\n  const defaultNDims = defaultValueShape.length;\n  const valuesNDims = valueShape.length;\n\n  if (defaultNDims >= valuesNDims) {\n    throw new Error(`defaultValue.shape=${defaultValueShape} and ragged tensor flatValues.shape=${valueShape}, are incompatible: defaultValue.rank = ${defaultNDims} must be less than ragged tensor input flatValues.rank = ${valuesNDims})`);\n  }\n\n  for (let i = 0; i < Math.min(defaultNDims, valuesNDims - 1); ++i) {\n    const defaultDim = defaultValueShape[i];\n    const valueDim = valueShape[i + 1];\n\n    if (defaultDim >= 0 && valueDim >= 0 && defaultDim !== 1 && defaultDim !== valueDim) {\n      throw new Error(`defaultValue.shape=${defaultValueShape}, and ragged tensor input flatValues.shape=${valueShape} are incompatible: defaultValue.shape[${i - defaultValueShape.length}] = ${defaultDim} but ragged tensor input.flatValues.shape[${i - defaultValueShape.length}] = ${valueDim}`);\n    }\n  }\n}","map":{"version":3,"names":["RowPartitionType","combineRaggedTensorToTensorShapes","raggedRank","shape","valueShape","outputShape","Array","length","push","slice","Error","i","valueDim","outputShapeDimIndex","outputShapeDim","getRowPartitionTypesHelper","rowPartitionTypeStrings","stringToType","FIRST_DIM_SIZE","VALUE_ROWIDS","ROW_LENGTHS","ROW_SPLITS","ROW_LIMITS","ROW_STARTS","result","typeStr","getRaggedRank","rowPartitionTypes","validateDefaultValueShape","defaultValueShape","defaultNDims","valuesNDims","Math","min","defaultDim"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-core/dist/ops/ragged_to_dense_util.js"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport var RowPartitionType;\n(function (RowPartitionType) {\n    RowPartitionType[RowPartitionType[\"FIRST_DIM_SIZE\"] = 0] = \"FIRST_DIM_SIZE\";\n    RowPartitionType[RowPartitionType[\"VALUE_ROWIDS\"] = 1] = \"VALUE_ROWIDS\";\n    RowPartitionType[RowPartitionType[\"ROW_LENGTHS\"] = 2] = \"ROW_LENGTHS\";\n    RowPartitionType[RowPartitionType[\"ROW_SPLITS\"] = 3] = \"ROW_SPLITS\";\n    RowPartitionType[RowPartitionType[\"ROW_LIMITS\"] = 4] = \"ROW_LIMITS\";\n    RowPartitionType[RowPartitionType[\"ROW_STARTS\"] = 5] = \"ROW_STARTS\";\n})(RowPartitionType || (RowPartitionType = {}));\nexport function combineRaggedTensorToTensorShapes(raggedRank, shape, valueShape) {\n    // Test for consistency of valueShape and shape specified.\n    // If shape is unspecified and valueShape is specified, then copy\n    // over the size from the valueShape dimension.\n    let outputShape = new Array();\n    if (valueShape == null && shape == null) {\n        return outputShape;\n    }\n    if (shape == null) {\n        // Here, value_shape must be of known size.\n        while (outputShape.length < raggedRank + valueShape.length) {\n            outputShape.push(-1);\n        }\n    }\n    else {\n        outputShape = shape.slice();\n    }\n    if (valueShape == null) {\n        return outputShape;\n    }\n    // At this point, valueShape and output_shape have known ranks.\n    if (raggedRank + valueShape.length !== outputShape.length) {\n        throw new Error(`rt input.shape and shape=${shape} are incompatible: rt input.rank = ${raggedRank +\n            valueShape.length}, but shape.rank = ${outputShape.length}`);\n    }\n    for (let i = 1; i < valueShape.length; ++i) {\n        const valueDim = valueShape[i];\n        const outputShapeDimIndex = outputShape[outputShape.length - valueShape.length + i];\n        const outputShapeDim = outputShape[outputShapeDimIndex];\n        if (valueDim >= 0) {\n            if (outputShapeDim >= 0) {\n                if (outputShapeDim !== valueDim) {\n                    throw new Error(`rt input.shape and shape=${shape} are incompatible: rt input.shape[${i + raggedRank}] = ${valueDim} but shape[${i + raggedRank}] = ${outputShapeDim}`);\n                }\n            }\n            else {\n                outputShape[outputShapeDimIndex] = valueDim;\n            }\n        }\n    }\n    return outputShape;\n}\nexport function getRowPartitionTypesHelper(rowPartitionTypeStrings) {\n    const stringToType = {\n        'FIRST_DIM_SIZE': RowPartitionType.FIRST_DIM_SIZE,\n        'VALUE_ROWIDS': RowPartitionType.VALUE_ROWIDS,\n        'ROW_LENGTHS': RowPartitionType.ROW_LENGTHS,\n        'ROW_SPLITS': RowPartitionType.ROW_SPLITS,\n        'ROW_LIMITS': RowPartitionType.ROW_LIMITS,\n        'ROW_STARTS': RowPartitionType.ROW_STARTS\n    };\n    const result = [];\n    for (const typeStr of rowPartitionTypeStrings) {\n        if (typeStr in stringToType) {\n            result.push(stringToType[typeStr]);\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\nexport function getRaggedRank(rowPartitionTypes) {\n    if (rowPartitionTypes.length === 0) {\n        return 0;\n    }\n    if (rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n        return rowPartitionTypes.length - 1;\n    }\n    return rowPartitionTypes.length;\n}\nexport function validateDefaultValueShape(defaultValueShape, valueShape) {\n    if (defaultValueShape == null || valueShape == null) {\n        return;\n    }\n    const defaultNDims = defaultValueShape.length;\n    const valuesNDims = valueShape.length;\n    if (defaultNDims >= valuesNDims) {\n        throw new Error(`defaultValue.shape=${defaultValueShape} and ragged tensor flatValues.shape=${valueShape}, are incompatible: defaultValue.rank = ${defaultNDims} must be less than ragged tensor input flatValues.rank = ${valuesNDims})`);\n    }\n    for (let i = 0; i < Math.min(defaultNDims, valuesNDims - 1); ++i) {\n        const defaultDim = defaultValueShape[i];\n        const valueDim = valueShape[i + 1];\n        if (defaultDim >= 0 && valueDim >= 0 && defaultDim !== 1 &&\n            defaultDim !== valueDim) {\n            throw new Error(`defaultValue.shape=${defaultValueShape}, and ragged tensor input flatValues.shape=${valueShape} are incompatible: defaultValue.shape[${i - defaultValueShape.length}] = ${defaultDim} but ragged tensor input.flatValues.shape[${i - defaultValueShape.length}] = ${valueDim}`);\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}