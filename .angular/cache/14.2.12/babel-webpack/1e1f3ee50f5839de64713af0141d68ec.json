{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { complex } from '../complex';\nimport { concat } from '../concat';\nimport { imag } from '../imag';\nimport { mul } from '../mul';\nimport { op } from '../operation';\nimport { real } from '../real';\nimport { reshape } from '../reshape';\nimport { reverse } from '../reverse';\nimport { scalar } from '../scalar';\nimport { slice } from '../slice';\nimport { ifft } from './ifft';\n/**\n * Inversed real value input fast Fourier transform.\n *\n * Computes the 1-dimensional inversed discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n * const imag = tf.tensor1d([0, 0, 0]);\n * const x = tf.complex(real, imag);\n *\n * x.irfft().print();\n * ```\n * @param input The real value input to compute an irfft over.\n *\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\n\nfunction irfft_(input) {\n  const innerDimensionSize = input.shape[input.shape.length - 1];\n  const batch = input.size / innerDimensionSize;\n  let ret;\n\n  if (innerDimensionSize <= 2) {\n    const complexInput = reshape(input, [batch, innerDimensionSize]);\n    ret = ifft(complexInput);\n  } else {\n    // The length of unique components of the DFT of a real-valued signal\n    // is 2 * (input_len - 1)\n    const outputShape = [batch, 2 * (innerDimensionSize - 1)];\n    const realInput = reshape(real(input), [batch, innerDimensionSize]);\n    const imagInput = reshape(imag(input), [batch, innerDimensionSize]);\n    const realConjugate = reverse(slice(realInput, [0, 1], [batch, innerDimensionSize - 2]), 1);\n    const imagConjugate = mul(reverse(slice(imagInput, [0, 1], [batch, innerDimensionSize - 2]), 1), scalar(-1));\n    const r = concat([realInput, realConjugate], 1);\n    const i = concat([imagInput, imagConjugate], 1);\n    const complexInput = reshape(complex(r, i), [outputShape[0], outputShape[1]]);\n    ret = ifft(complexInput);\n  }\n\n  ret = real(ret); // reshape the result if the input is 3D tensor.\n\n  if (input.rank === 3 && input.shape[0] !== 0) {\n    const temp = ret;\n    const batch = input.shape[0];\n    ret = reshape(ret, [batch, ret.shape[0] / batch, ret.shape[1]]);\n    temp.dispose();\n  }\n\n  return ret;\n}\n\nexport const irfft = op({\n  irfft_\n});","map":{"version":3,"names":["complex","concat","imag","mul","op","real","reshape","reverse","scalar","slice","ifft","irfft_","input","innerDimensionSize","shape","length","batch","size","ret","complexInput","outputShape","realInput","imagInput","realConjugate","imagConjugate","r","i","rank","temp","dispose","irfft"],"sources":["C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@tensorflow/tfjs-core/dist/ops/spectral/irfft.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { complex } from '../complex';\nimport { concat } from '../concat';\nimport { imag } from '../imag';\nimport { mul } from '../mul';\nimport { op } from '../operation';\nimport { real } from '../real';\nimport { reshape } from '../reshape';\nimport { reverse } from '../reverse';\nimport { scalar } from '../scalar';\nimport { slice } from '../slice';\nimport { ifft } from './ifft';\n/**\n * Inversed real value input fast Fourier transform.\n *\n * Computes the 1-dimensional inversed discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n * const imag = tf.tensor1d([0, 0, 0]);\n * const x = tf.complex(real, imag);\n *\n * x.irfft().print();\n * ```\n * @param input The real value input to compute an irfft over.\n *\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction irfft_(input) {\n    const innerDimensionSize = input.shape[input.shape.length - 1];\n    const batch = input.size / innerDimensionSize;\n    let ret;\n    if (innerDimensionSize <= 2) {\n        const complexInput = reshape(input, [batch, innerDimensionSize]);\n        ret = ifft(complexInput);\n    }\n    else {\n        // The length of unique components of the DFT of a real-valued signal\n        // is 2 * (input_len - 1)\n        const outputShape = [batch, 2 * (innerDimensionSize - 1)];\n        const realInput = reshape(real(input), [batch, innerDimensionSize]);\n        const imagInput = reshape(imag(input), [batch, innerDimensionSize]);\n        const realConjugate = reverse(slice(realInput, [0, 1], [batch, innerDimensionSize - 2]), 1);\n        const imagConjugate = mul(reverse(slice(imagInput, [0, 1], [batch, innerDimensionSize - 2]), 1), scalar(-1));\n        const r = concat([realInput, realConjugate], 1);\n        const i = concat([imagInput, imagConjugate], 1);\n        const complexInput = reshape(complex(r, i), [outputShape[0], outputShape[1]]);\n        ret = ifft(complexInput);\n    }\n    ret = real(ret);\n    // reshape the result if the input is 3D tensor.\n    if (input.rank === 3 && input.shape[0] !== 0) {\n        const temp = ret;\n        const batch = input.shape[0];\n        ret = reshape(ret, [batch, ret.shape[0] / batch, ret.shape[1]]);\n        temp.dispose();\n    }\n    return ret;\n}\nexport const irfft = op({ irfft_ });\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}