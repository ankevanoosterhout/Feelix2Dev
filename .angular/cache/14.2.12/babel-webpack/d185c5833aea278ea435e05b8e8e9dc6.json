{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Anke/Documents/Feelix documents/Feelix2.0-dev/Feelix v2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as tf from '@tensorflow/tfjs';\nimport { Subject } from 'rxjs';\nimport { DOCUMENT } from '@angular/common';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./tensorflow-main.service\";\nexport class TensorFlowTrainService {\n  constructor(document, tensorflowService) {\n    this.document = document;\n    this.tensorflowService = tensorflowService;\n    this.createPredictionModel = new Subject();\n    this.d = this.tensorflowService.d; // this.tensorflowService.createJSON.subscribe((res) => {\n    //   const JSONData = this.createJSONfromDataSet(res.data, res.train);\n    // });\n  }\n\n  predictOutput() {\n    let collectData = true;\n    let i = 0;\n\n    if (this.d.predictionDataset) {\n      for (const motor of this.d.predictionDataset.m) {\n        if (motor.d.length <= 20 && motor.d.length !== 0) {\n          collectData = false;\n        }\n\n        i++;\n\n        if (i >= this.d.predictionDataset.m.length && collectData) {\n          const data = this.createJSONfromDataSet([this.d.predictionDataset], false);\n          this.NN_Deploy(data.xs, this.d.selectedModel);\n          this.clearCollectedData();\n        }\n      }\n    }\n  }\n\n  clearCollectedData() {\n    this.d.recording.starttime = new Date().getTime();\n\n    for (const motor of this.d.predictionDataset.m) {\n      motor.d = [];\n    }\n  }\n\n  createJSONfromDataSet(dataSets, train = true) {\n    const data = {\n      xs: [],\n      ys: []\n    };\n    let dataSize = 0;\n    dataSets.forEach(set => {\n      let outputs = [];\n\n      if (set.output.label.id) {\n        for (const classifier of this.d.selectedModel.outputs) {\n          if (classifier.active && classifier.id === set.output.classifier_id) {\n            for (const label of classifier.labels) {\n              label.id === set.output.label.id ? outputs.push(1) : outputs.push(0);\n            }\n          }\n        }\n\n        if (outputs.length === 0) {\n          this.d.processing = false;\n          this.tensorflowService.updateProgess('cannot find outputs', 0);\n          return false;\n        } // console.log(outputs);\n\n      } // console.log(set.m);\n\n\n      let m = 0;\n      set.m.forEach(motor => {\n        let inputArray = [];\n        let i = 0;\n        let n = 0 + dataSize;\n\n        if (motor.d.length > 0) {\n          for (const d of motor.d) {\n            const inputs = [];\n\n            for (const input of d.inputs) {\n              const input_variable = this.d.selectedModel.inputs.filter(i => i.name === input.name)[0];\n\n              if (input_variable && input_variable.active) {\n                inputs.push(input.value);\n              }\n            }\n\n            if (m !== 0 && data.xs[n]) {\n              if (data.xs[n][i]) {\n                data.xs[n][i].push(inputs);\n              }\n            } else {\n              inputArray.push([inputs]);\n            }\n\n            i++;\n\n            if (i >= 20) {\n              if (m === 0) {\n                data.xs.push(inputArray);\n                data.ys.push(outputs);\n              } else {\n                n++;\n              }\n\n              i = 0;\n              inputArray = [];\n            }\n          }\n        }\n\n        m++;\n      });\n      dataSize = data.xs.length;\n    });\n    return data;\n  }\n\n  Regression_createModel(data, modelObj) {}\n\n  NN_createData(data, modelObj) {\n    this.d.selectedModel.model = tf.sequential();\n    this.createPredictionModel.next();\n    this.d.selectedModel.model.name = modelObj.name;\n    this.tensorflowService.updateProgess('model created', 10);\n\n    if (data.xs && data.ys) {\n      const inputShape = [null, data.xs[0][0][0].length, data.xs[0][0].length * data.xs[0].length];\n      const outputShape = [null, data.ys[0].length];\n      console.log(inputShape);\n      const numSamples = data.xs.length;\n      const iTensor = tf.tensor(data.xs, [numSamples, data.xs[0].length, data.xs[0][0].length, data.xs[0][0][0].length]);\n      const outputTensor = tf.tensor(data.ys, [numSamples, data.ys[0].length]);\n      const inputTensor = tf.reshape(iTensor, [numSamples, data.xs[0][0][0].length, data.xs[0][0].length * data.xs[0].length]);\n      console.log(iTensor, inputTensor, outputTensor);\n\n      for (let layer = 0; layer < this.d.selectedModel.options.hiddenUnits; layer++) {\n        const hiddenLayer = tf.layers.dense({\n          units: data.xs[0][0].length * data.xs[0].length,\n          inputShape: inputShape.slice(1),\n          activation: this.d.selectedModel.options.activation // make activation function adjustable in model settings\n\n        });\n        console.log(hiddenLayer);\n        this.d.selectedModel.model.add(hiddenLayer); // this.selectedModel.model.add(tf.layers.maxPooling2d({ poolSize: 2 }));\n      }\n\n      this.d.selectedModel.model.add(tf.layers.flatten());\n      const outputLayer = tf.layers.dense({\n        units: outputShape[1],\n        activation: this.d.selectedModel.options.activationOutputLayer\n      });\n      this.d.selectedModel.model.add(outputLayer); // const sgdOpt = tf.train.sgd(this.d.selectedModel.options.learningRate);\n\n      const optimizerFunction = this.d.selectedModel.options.optimizer(this.d.selectedModel.options.learningRate);\n      this.d.selectedModel.model.compile({\n        optimizer: optimizerFunction,\n        loss: this.d.selectedModel.options.losses,\n        metrics: [this.d.selectedModel.options.metrics]\n      }); // console.log(this.d.selectedModel.options);\n      // console.log(this.d.selectedModel.model);\n      //   this.selectedModel.model.normalizeData();\n\n      this.tensorflowService.updateProgess('start training', 20);\n      this.train(inputTensor, outputTensor, this.d.selectedModel.options.trainingOptions).then(() => {\n        console.log('training is complete');\n        this.document.body.style.cursor = 'default';\n        this.d.processing = false;\n        inputTensor.dispose();\n        outputTensor.dispose();\n        console.log(\"memory \" + tf.memory().numTensors);\n      });\n    } else {\n      this.tensorflowService.updateProgess('no data found, training canceled', 0);\n      this.d.processing = false;\n      this.document.body.style.cursor = 'default';\n      return false;\n    }\n  }\n\n  train(iTensor, oTensor, options) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // console.log(iTensor, oTensor);\n      for (let i = 0; i < options.epochs; i++) {\n        const response = yield _this.d.selectedModel.model.fit(iTensor, oTensor, {\n          verbose: true,\n          shuffle: true,\n          batchSize: options.batchSize,\n          epochs: 1\n        });\n\n        if (i < options.epochs - 1) {\n          if (i % 10 === 0) {\n            _this.tensorflowService.updateProgess('training, loss = ' + response.history.loss[0], 80 / options.epochs * i + 20);\n          }\n        } else {\n          _this.tensorflowService.updateProgess('finished training ' + response.history.loss[0], 100);\n        }\n      }\n    })();\n  }\n\n  NN_Deploy(input, selectedModel) {\n    // this.serialPath = path;\n    console.log('predict');\n    console.log(input);\n\n    if (selectedModel.type !== 'Regression') {\n      const iTensor = tf.tensor(input);\n      const inputTensor = tf.reshape(iTensor, [input.length, input[0][0][0].length, input[0][0].length * input[0].length]);\n      console.log(iTensor, inputTensor);\n      const outputs = this.d.selectedModel.multiple ? this.d.selectedModel.model.predictOnBatch(inputTensor) : this.d.selectedModel.model.predict(inputTensor);\n      console.log(outputs);\n      const prediction = Array.from(outputs.dataSync());\n      console.log(prediction);\n      this.updatePredictionClassifiers(prediction);\n      iTensor.dispose();\n    }\n  }\n\n  updatePredictionClassifiers(results) {\n    console.log(this.d.selectedModel.outputs);\n\n    for (const classifier of this.d.selectedModel.outputs) {\n      let i = 0;\n\n      for (const label of classifier.labels) {\n        console.log(label);\n        label.confidence = results[i];\n        this.document.getElementById('bar-' + classifier.id + '-' + label.id).style.width = label.confidence * 100 + '%';\n        this.document.getElementById('confidence-' + classifier.id + '-' + label.id).innerHTML = (label.confidence * 100).toFixed(2) + '%';\n        i++;\n      }\n    }\n  }\n\n}\n\nTensorFlowTrainService.ɵfac = function TensorFlowTrainService_Factory(t) {\n  return new (t || TensorFlowTrainService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(i1.TensorFlowMainService));\n};\n\nTensorFlowTrainService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: TensorFlowTrainService,\n  factory: TensorFlowTrainService.ɵfac\n});","map":{"version":3,"mappings":"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","names":["tf","Subject","DOCUMENT","TensorFlowTrainService","constructor","document","tensorflowService","d","predictOutput","collectData","i","predictionDataset","motor","m","length","data","createJSONfromDataSet","NN_Deploy","xs","selectedModel","clearCollectedData","recording","starttime","Date","getTime","dataSets","train","ys","dataSize","forEach","set","outputs","output","label","id","classifier","active","classifier_id","labels","push","processing","updateProgess","inputArray","n","inputs","input","input_variable","filter","name","value","Regression_createModel","modelObj","NN_createData","model","sequential","createPredictionModel","next","inputShape","outputShape","console","log","numSamples","iTensor","tensor","outputTensor","inputTensor","reshape","layer","options","hiddenUnits","hiddenLayer","layers","dense","units","slice","activation","add","flatten","outputLayer","activationOutputLayer","optimizerFunction","optimizer","learningRate","compile","loss","losses","metrics","trainingOptions","then","body","style","cursor","dispose","memory","numTensors","oTensor","epochs","response","fit","verbose","shuffle","batchSize","history","type","multiple","predictOnBatch","predict","prediction","Array","from","dataSync","updatePredictionClassifiers","results","confidence","getElementById","width","innerHTML","toFixed","i0","factory"],"sourceRoot":"","sources":["C:\\Users\\Anke\\Documents\\Feelix documents\\Feelix2.0-dev\\Feelix v2\\src\\app\\services\\tensorflow-train.service.ts"],"sourcesContent":["import { Injectable, Inject } from '@angular/core';\nimport * as tf from '@tensorflow/tfjs';\nimport { TensorFlowData } from '../models/tensorflow-data.model';\nimport { DataSet, Model } from '../models/tensorflow.model';\nimport { TensorFlowMainService } from './tensorflow-main.service';\nimport { Subject } from 'rxjs';\nimport { DOCUMENT } from '@angular/common';\n\n\n@Injectable()\nexport class TensorFlowTrainService {\n\n  public d: TensorFlowData;\n\n  createPredictionModel: Subject<any> = new Subject();\n\n  constructor(@Inject(DOCUMENT) private document: Document, private tensorflowService: TensorFlowMainService) {\n    this.d = this.tensorflowService.d;\n\n    // this.tensorflowService.createJSON.subscribe((res) => {\n    //   const JSONData = this.createJSONfromDataSet(res.data, res.train);\n    // });\n  }\n\n  predictOutput() {\n    let collectData = true;\n    let i = 0;\n    if (this.d.predictionDataset) {\n      for (const motor of this.d.predictionDataset.m) {\n        if (motor.d.length <= 20 && motor.d.length !== 0) {\n          collectData = false;\n        }\n        i++;\n\n        if (i >= this.d.predictionDataset.m.length && collectData) {\n\n          const data = this.createJSONfromDataSet([this.d.predictionDataset], false);\n          this.NN_Deploy(data.xs, this.d.selectedModel);\n          this.clearCollectedData();\n        }\n      }\n    }\n  }\n\n\n  clearCollectedData() {\n    this.d.recording.starttime = new Date().getTime();\n    for (const motor of this.d.predictionDataset.m) {\n      motor.d = [];\n    }\n  }\n\n\n\n  createJSONfromDataSet(dataSets: Array<DataSet>, train = true) {\n    const data = { xs: [], ys: [] };\n    let dataSize = 0;\n\n    dataSets.forEach(set => {\n\n      let outputs = [];\n      if (set.output.label.id) {\n\n        for (const classifier of this.d.selectedModel.outputs) {\n          if (classifier.active && classifier.id === set.output.classifier_id) {\n            for (const label of classifier.labels) {\n              label.id === set.output.label.id ? outputs.push(1) : outputs.push(0);\n            }\n          }\n        }\n        if (outputs.length === 0) {\n          this.d.processing = false;\n          this.tensorflowService.updateProgess('cannot find outputs', 0);\n          return false;\n        }\n        // console.log(outputs);\n      }\n\n      // console.log(set.m);\n\n      let m = 0;\n\n      set.m.forEach(motor => {\n        let inputArray = [];\n        let i = 0;\n        let n = 0 + dataSize;\n\n        if (motor.d.length > 0) {\n\n          for (const d of motor.d) {\n            const inputs = [];\n            for (const input of d.inputs) {\n              const input_variable = this.d.selectedModel.inputs.filter(i => i.name === input.name)[0];\n              if (input_variable && input_variable.active) {\n                inputs.push(input.value);\n              }\n            }\n\n            if (m !== 0 && data.xs[n]) {\n              if (data.xs[n][i]) {\n                data.xs[n][i].push(inputs);\n              }\n            } else {\n              inputArray.push([inputs]);\n            }\n\n            i++;\n\n            if (i >= 20) {\n              if (m === 0) {\n                data.xs.push(inputArray);\n                data.ys.push(outputs);\n              } else {\n                n++;\n              }\n              i = 0;\n              inputArray = [];\n            }\n          }\n        }\n        m++;\n      });\n\n      dataSize = data.xs.length;\n    });\n\n    return data;\n  }\n\n\n  Regression_createModel(data: any, modelObj: Model) {\n\n  }\n\n\n  NN_createData(data: any, modelObj: Model) {\n\n    this.d.selectedModel.model = tf.sequential();\n\n    this.createPredictionModel.next();\n\n    this.d.selectedModel.model.name = modelObj.name;\n\n    this.tensorflowService.updateProgess('model created', 10);\n\n    if (data.xs && data.ys) {\n\n      const inputShape = [null, data.xs[0][0][0].length, (data.xs[0][0].length * data.xs[0].length) ];\n      const outputShape = [null, data.ys[0].length]\n\n      console.log(inputShape);\n\n      const numSamples = data.xs.length;\n      const iTensor = tf.tensor(data.xs, [numSamples, data.xs[0].length, data.xs[0][0].length, data.xs[0][0][0].length]);\n      const outputTensor = tf.tensor(data.ys, [numSamples, data.ys[0].length]);\n\n      const inputTensor = tf.reshape(iTensor, [numSamples, data.xs[0][0][0].length, (data.xs[0][0].length * data.xs[0].length) ]);\n\n      console.log(iTensor, inputTensor, outputTensor);\n\n\n      for (let layer = 0; layer < this.d.selectedModel.options.hiddenUnits; layer++) {\n        const hiddenLayer = tf.layers.dense({\n          units: (data.xs[0][0].length * data.xs[0].length), //data.xs[0][0][0].length\n          inputShape: inputShape.slice(1), // [ number of inputs, batch size ]\n          activation: this.d.selectedModel.options.activation // make activation function adjustable in model settings\n        });\n\n        console.log(hiddenLayer);\n\n        this.d.selectedModel.model.add(hiddenLayer);\n        // this.selectedModel.model.add(tf.layers.maxPooling2d({ poolSize: 2 }));\n      }\n      this.d.selectedModel.model.add(tf.layers.flatten());\n\n\n      const outputLayer = tf.layers.dense({\n        units: outputShape[1],\n        activation: this.d.selectedModel.options.activationOutputLayer\n      });\n\n      this.d.selectedModel.model.add(outputLayer);\n\n      // const sgdOpt = tf.train.sgd(this.d.selectedModel.options.learningRate);\n      const optimizerFunction = this.d.selectedModel.options.optimizer(this.d.selectedModel.options.learningRate);\n\n      this.d.selectedModel.model.compile({\n        optimizer: optimizerFunction,\n        loss: this.d.selectedModel.options.losses,\n        metrics: [ this.d.selectedModel.options.metrics ]\n      });\n      // console.log(this.d.selectedModel.options);\n      // console.log(this.d.selectedModel.model);\n    //   this.selectedModel.model.normalizeData();\n\n      this.tensorflowService.updateProgess('start training', 20);\n\n\n\n\n      this.train(inputTensor, outputTensor, this.d.selectedModel.options.trainingOptions).then(() => {\n        console.log('training is complete');\n\n        this.document.body.style.cursor = 'default';\n\n        this.d.processing = false;\n\n        inputTensor.dispose();\n        outputTensor.dispose();\n\n        console.log(\"memory \" + tf.memory().numTensors);\n\n      });\n\n    } else {\n      this.tensorflowService.updateProgess('no data found, training canceled', 0);\n      this.d.processing = false;\n\n      this.document.body.style.cursor = 'default';\n\n      return false;\n    }\n  }\n\n\n  async train(iTensor: any, oTensor: any, options: any) {\n    // console.log(iTensor, oTensor);\n    for (let i = 0; i < options.epochs; i++) {\n      const response = await this.d.selectedModel.model.fit(iTensor, oTensor, {\n        verbose: true,\n        shuffle: true,\n        batchSize: options.batchSize,\n        epochs: 1\n      });\n      if (i < options.epochs - 1) {\n        if (i % 10 === 0) {\n          this.tensorflowService.updateProgess('training, loss = ' + response.history.loss[0], ((80/options.epochs) * i) + 20);\n        }\n      } else {\n        this.tensorflowService.updateProgess('finished training ' + response.history.loss[0], 100);\n      }\n    }\n  }\n\n\n\n\n  NN_Deploy(input: any, selectedModel: any) {\n\n    // this.serialPath = path;\n    console.log('predict');\n    console.log(input);\n\n    if (selectedModel.type !== 'Regression') {\n      const iTensor = tf.tensor(input);\n      const inputTensor = tf.reshape(iTensor, [input.length, input[0][0][0].length, (input[0][0].length * input[0].length) ]);\n      console.log(iTensor, inputTensor);\n      const outputs = this.d.selectedModel.multiple ? this.d.selectedModel.model.predictOnBatch(inputTensor) : this.d.selectedModel.model.predict(inputTensor);\n      console.log(outputs);\n      const prediction = Array.from((outputs as any).dataSync());\n      console.log(prediction);\n      this.updatePredictionClassifiers(prediction);\n\n      iTensor.dispose();\n    }\n  }\n\n\n  updatePredictionClassifiers(results: Array<any>) {\n    console.log(this.d.selectedModel.outputs);\n    for (const classifier of this.d.selectedModel.outputs) {\n      let i  = 0;\n      for (const label of classifier.labels) {\n        console.log(label);\n        label.confidence = results[i];\n        (this.document.getElementById('bar-' + classifier.id + '-' + label.id) as HTMLElement).style.width = (label.confidence * 100) + '%';\n        (this.document.getElementById('confidence-' + classifier.id + '-' + label.id) as HTMLElement).innerHTML = (label.confidence * 100).toFixed(2) + '%';\n\n        i++;\n      }\n    }\n  }\n\n\n\n\n    // handleRegressionResults = ((error: any, result: any) => {\n    //   if(error){\n    //     this.updateProgess(error, 0);\n    //     this.d.classify = false;\n    //     console.error(error);\n    //     return;\n    //   }\n    //   for (const output of this.d.selectedModel.outputs) {\n    //     for (const label of output.labels) {\n    //       const result_label = result.filter((r: { label: string; }) => r.label == label.name)[0];\n    //       // label.prediction = result_label.;\n    //       // this.document.getElementById('bar-' + output.name + '-' + label.name).style.width = (label.prediction * 100) + '%';\n    //       // this.document.getElementById('confidence-' + output.name + '-' + label.name).innerHTML = (label.prediction  * 100).toFixed(2) + '%';\n    //     }\n    //   }\n    // }).bind(this);\n\n\n    //   let filterArray = [];\n    //   let n = 0;\n\n    //   for (const filter of this.d.selectedModel.filters) {\n    //     const classifier = this.d.selectedModel.outputs.filter(o => o.name === filter.classifier.name)[0];\n    //     if (classifier && classifier.labels.length > 0) {\n    //       const highestConfidenceLabel = this.getHighestConfidenceLabel(classifier);\n    //       // console.log(highestConfidenceLabel.name);\n    //       let index = classifier.labels.indexOf(highestConfidenceLabel);\n\n    //       if (index > -1) {\n\n\n    //         if ((filter.type.name === 'amplify' || filter.type.name === 'constrain') && filter.functionVariable.value[index] !== filter.functionVariable.prevValue) {\n\n    //           let filterObj = { type: filter.type.slug, value: filter.functionVariable.value[index], smoothness: filter.type.interpolate };\n    //           filterArray.push(filterObj);\n\n    //           filter.functionVariable.prevValue = filter.functionVariable.value[index];\n\n    //         } else if (filter.type.name === 'noise') {\n\n    //           const newRandom = (Math.floor(Math.random() * ((filter.functionVariable.value[index] * 100) * 2)) - (filter.functionVariable.value[index] * 100)) / 100;\n    //           let filterObj = { type: filter.type.slug, value: newRandom, smoothness: filter.type.interpolate };\n\n    //           filterArray.push(filterObj);\n    //         }\n    //       }\n    //     }\n    //     if (n === this.d.selectedModel.filters.length - 1) {\n    //       if (filterArray.length > 0) {\n    //         // console.log('update filter');\n    //         const microcontroller = this.d.selectedMicrocontrollers.filter(m => m.serialPort.path === this.serialPath)[0];\n    //         if (microcontroller) {\n    //           const filterModel = new FilterModel(filterArray, microcontroller);\n    //           // console.log(filterModel);\n    //           this.electronService.ipcRenderer.send('updateFilter', filterModel);\n    //         }\n    //       }\n    //     }\n    //     n++;\n    //   }\n\n    // }).bind(this);\n\n\n\n    // getHighestConfidenceLabel(classifier: Classifier): Label {\n    //   let maxConfidence = classifier.labels[0];\n    //   for (const label of classifier.labels) {\n    //     if (label.confidence > maxConfidence.confidence) {\n    //       maxConfidence = label;\n    //     }\n    //   }\n    //   return maxConfidence;\n    // }\n\n}\n"]},"metadata":{},"sourceType":"module"}